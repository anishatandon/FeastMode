"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getLatestRelease;

function _https() {
  const data = _interopRequireDefault(require("https"));

  _https = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

var _logger = _interopRequireDefault(require("../logger"));

var _releaseCacheManager = _interopRequireDefault(require("./releaseCacheManager"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Checks via GitHub API if there is a newer stable React Native release and,
 * if it exists, returns the release data.
 *
 * If the latest release is not newer or if it's a prerelease, the function
 * will return undefined.
 */
async function getLatestRelease(name, currentVersion) {
  _logger.default.debug('Checking for a newer version of React Native');

  try {
    _logger.default.debug(`Current version: ${currentVersion}`);

    const cachedLatest = _releaseCacheManager.default.get(name, 'latestVersion');

    if (cachedLatest) {
      _logger.default.debug(`Cached release version: ${cachedLatest}`);
    }

    const aWeek = 7 * 24 * 60 * 60 * 1000;

    const lastChecked = _releaseCacheManager.default.get(name, 'lastChecked');

    const now = new Date();

    if (lastChecked && now - new Date(lastChecked) < aWeek) {
      _logger.default.debug('Cached release is still recent, skipping remote check');

      return;
    }

    _logger.default.debug('Checking for newer releases on GitHub');

    const eTag = _releaseCacheManager.default.get(name, 'eTag');

    const latestVersion = await getLatestRnDiffPurgeVersion(name, eTag);

    _logger.default.debug(`Latest release: ${latestVersion}`);

    if (_semver().default.compare(latestVersion, currentVersion) === 1 && !_semver().default.prerelease(latestVersion)) {
      return {
        version: latestVersion,
        changelogUrl: buildChangelogUrl(latestVersion)
      };
    }
  } catch (e) {
    _logger.default.debug('Something went wrong with remote version checking, moving on');

    _logger.default.debug(e);
  }
}

function buildChangelogUrl(version) {
  return `https://github.com/facebook/react-native/releases/tag/v${version}`;
}
/**
 * Returns the most recent React Native version available to upgrade to.
 */


async function getLatestRnDiffPurgeVersion(name, eTag) {
  const options = {
    hostname: 'api.github.com',
    path: '/repos/react-native-community/rn-diff-purge/tags',
    // https://developer.github.com/v3/#user-agent-required
    headers: {
      'User-Agent': 'React-Native-CLI'
    }
  };

  if (eTag) {
    options.headers['If-None-Match'] = eTag;
  }

  const response = await httpsGet(options); // Remote is newer.

  if (response.statusCode === 200) {
    const latestVersion = JSON.parse(response.body)[0].name.substring(8); // Update cache only if newer release is stable.

    if (!_semver().default.prerelease(latestVersion)) {
      _logger.default.debug(`Saving ${response.eTag} to cache`);

      _releaseCacheManager.default.set(name, 'eTag', response.eTag);

      _releaseCacheManager.default.set(name, 'latestVersion', latestVersion);
    }

    return latestVersion;
  } // Cache is still valid.


  if (response.statusCode === 304) {
    const latestVersion = _releaseCacheManager.default.get(name, 'latestVersion');

    if (latestVersion) {
      return latestVersion;
    }
  } // Should be returned only if something went wrong.


  return '0.0.0';
}

function httpsGet(options) {
  return new Promise((resolve, reject) => {
    _https().default.get(options, result => {
      let body = '';
      result.setEncoding('utf8');
      result.on('data', data => {
        body += data;
      });
      result.on('end', () => {
        resolve({
          body,
          eTag: result.headers.etag,
          statusCode: result.statusCode
        });
      });
      result.on('error', error => reject(error));
    }).on('error', error => reject(error));
  });
}