{"ast":null,"code":"'use strict'; // Load modules\n\nconst Net = require('net');\n\nconst Hoek = require('hoek');\n\nconst Isemail = require('isemail');\n\nconst Any = require('./any');\n\nconst Ref = require('./ref');\n\nconst JoiDate = require('./date');\n\nconst Uri = require('./string/uri');\n\nconst Ip = require('./string/ip'); // Declare internals\n\n\nconst internals = {\n  uriRegex: Uri.createUriRegex(),\n  ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional')\n};\ninternals.String = class extends Any {\n  constructor() {\n    super();\n    this._type = 'string';\n\n    this._invalids.add('');\n  }\n\n  _base(value, state, options) {\n    if (typeof value === 'string' && options.convert) {\n      if (this._flags.case) {\n        value = this._flags.case === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase();\n      }\n\n      if (this._flags.trim) {\n        value = value.trim();\n      }\n\n      if (this._inner.replacements) {\n        for (let i = 0; i < this._inner.replacements.length; ++i) {\n          const replacement = this._inner.replacements[i];\n          value = value.replace(replacement.pattern, replacement.replacement);\n        }\n      }\n\n      if (this._flags.truncate) {\n        for (let i = 0; i < this._tests.length; ++i) {\n          const test = this._tests[i];\n\n          if (test.name === 'max') {\n            value = value.slice(0, test.arg);\n            break;\n          }\n        }\n      }\n    }\n\n    return {\n      value,\n      errors: typeof value === 'string' ? null : this.createError('string.base', {\n        value\n      }, state, options)\n    };\n  }\n\n  insensitive() {\n    const obj = this.clone();\n    obj._flags.insensitive = true;\n    return obj;\n  }\n\n  creditCard() {\n    return this._test('creditCard', undefined, function (value, state, options) {\n      let i = value.length;\n      let sum = 0;\n      let mul = 1;\n\n      while (i--) {\n        const char = value.charAt(i) * mul;\n        sum = sum + (char - (char > 9) * 9);\n        mul = mul ^ 3;\n      }\n\n      const check = sum % 10 === 0 && sum > 0;\n      return check ? value : this.createError('string.creditCard', {\n        value\n      }, state, options);\n    });\n  }\n\n  regex(pattern, name) {\n    Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n    pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined); // Future version should break this and forbid unsupported regex flags\n\n    return this._test('regex', pattern, function (value, state, options) {\n      if (pattern.test(value)) {\n        return value;\n      }\n\n      return this.createError(name ? 'string.regex.name' : 'string.regex.base', {\n        name,\n        pattern,\n        value\n      }, state, options);\n    });\n  }\n\n  alphanum() {\n    return this._test('alphanum', undefined, function (value, state, options) {\n      if (/^[a-zA-Z0-9]+$/.test(value)) {\n        return value;\n      }\n\n      return this.createError('string.alphanum', {\n        value\n      }, state, options);\n    });\n  }\n\n  token() {\n    return this._test('token', undefined, function (value, state, options) {\n      if (/^\\w+$/.test(value)) {\n        return value;\n      }\n\n      return this.createError('string.token', {\n        value\n      }, state, options);\n    });\n  }\n\n  email(isEmailOptions) {\n    if (isEmailOptions) {\n      Hoek.assert(typeof isEmailOptions === 'object', 'email options must be an object');\n      Hoek.assert(typeof isEmailOptions.checkDNS === 'undefined', 'checkDNS option is not supported');\n      Hoek.assert(typeof isEmailOptions.tldWhitelist === 'undefined' || typeof isEmailOptions.tldWhitelist === 'object', 'tldWhitelist must be an array or object');\n      Hoek.assert(typeof isEmailOptions.minDomainAtoms === 'undefined' || Hoek.isInteger(isEmailOptions.minDomainAtoms) && isEmailOptions.minDomainAtoms > 0, 'minDomainAtoms must be a positive integer');\n      Hoek.assert(typeof isEmailOptions.errorLevel === 'undefined' || typeof isEmailOptions.errorLevel === 'boolean' || Hoek.isInteger(isEmailOptions.errorLevel) && isEmailOptions.errorLevel >= 0, 'errorLevel must be a non-negative integer or boolean');\n    }\n\n    return this._test('email', isEmailOptions, function (value, state, options) {\n      try {\n        const result = Isemail.validate(value, isEmailOptions);\n\n        if (result === true || result === 0) {\n          return value;\n        }\n      } catch (e) {}\n\n      return this.createError('string.email', {\n        value\n      }, state, options);\n    });\n  }\n\n  ip(ipOptions) {\n    let regex = internals.ipRegex;\n    ipOptions = ipOptions || {};\n    Hoek.assert(typeof ipOptions === 'object', 'options must be an object');\n\n    if (ipOptions.cidr) {\n      Hoek.assert(typeof ipOptions.cidr === 'string', 'cidr must be a string');\n      ipOptions.cidr = ipOptions.cidr.toLowerCase();\n      Hoek.assert(ipOptions.cidr in Ip.cidrs, 'cidr must be one of ' + Object.keys(Ip.cidrs).join(', ')); // If we only received a `cidr` setting, create a regex for it. But we don't need to create one if `cidr` is \"optional\" since that is the default\n\n      if (!ipOptions.version && ipOptions.cidr !== 'optional') {\n        regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], ipOptions.cidr);\n      }\n    } else {\n      // Set our default cidr strategy\n      ipOptions.cidr = 'optional';\n    }\n\n    let versions;\n\n    if (ipOptions.version) {\n      if (!Array.isArray(ipOptions.version)) {\n        ipOptions.version = [ipOptions.version];\n      }\n\n      Hoek.assert(ipOptions.version.length >= 1, 'version must have at least 1 version specified');\n      versions = [];\n\n      for (let i = 0; i < ipOptions.version.length; ++i) {\n        let version = ipOptions.version[i];\n        Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n        version = version.toLowerCase();\n        Hoek.assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));\n        versions.push(version);\n      } // Make sure we have a set of versions\n\n\n      versions = Hoek.unique(versions);\n      regex = Ip.createIpRegex(versions, ipOptions.cidr);\n    }\n\n    return this._test('ip', ipOptions, function (value, state, options) {\n      if (regex.test(value)) {\n        return value;\n      }\n\n      if (versions) {\n        return this.createError('string.ipVersion', {\n          value,\n          cidr: ipOptions.cidr,\n          version: versions\n        }, state, options);\n      }\n\n      return this.createError('string.ip', {\n        value,\n        cidr: ipOptions.cidr\n      }, state, options);\n    });\n  }\n\n  uri(uriOptions) {\n    let customScheme = '';\n    let allowRelative = false;\n    let regex = internals.uriRegex;\n\n    if (uriOptions) {\n      Hoek.assert(typeof uriOptions === 'object', 'options must be an object');\n\n      if (uriOptions.scheme) {\n        Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === 'string' || Array.isArray(uriOptions.scheme), 'scheme must be a RegExp, String, or Array');\n\n        if (!Array.isArray(uriOptions.scheme)) {\n          uriOptions.scheme = [uriOptions.scheme];\n        }\n\n        Hoek.assert(uriOptions.scheme.length >= 1, 'scheme must have at least 1 scheme specified'); // Flatten the array into a string to be used to match the schemes.\n\n        for (let i = 0; i < uriOptions.scheme.length; ++i) {\n          const scheme = uriOptions.scheme[i];\n          Hoek.assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String'); // Add OR separators if a value already exists\n\n          customScheme = customScheme + (customScheme ? '|' : ''); // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.\n\n          if (scheme instanceof RegExp) {\n            customScheme = customScheme + scheme.source;\n          } else {\n            Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\\.]*/.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');\n            customScheme = customScheme + Hoek.escapeRegex(scheme);\n          }\n        }\n      }\n\n      if (uriOptions.allowRelative) {\n        allowRelative = true;\n      }\n    }\n\n    if (customScheme || allowRelative) {\n      regex = Uri.createUriRegex(customScheme, allowRelative);\n    }\n\n    return this._test('uri', uriOptions, function (value, state, options) {\n      if (regex.test(value)) {\n        return value;\n      }\n\n      if (customScheme) {\n        return this.createError('string.uriCustomScheme', {\n          scheme: customScheme,\n          value\n        }, state, options);\n      }\n\n      return this.createError('string.uri', {\n        value\n      }, state, options);\n    });\n  }\n\n  isoDate() {\n    return this._test('isoDate', undefined, function (value, state, options) {\n      if (JoiDate._isIsoDate(value)) {\n        return value;\n      }\n\n      return this.createError('string.isoDate', {\n        value\n      }, state, options);\n    });\n  }\n\n  guid(guidOptions) {\n    const brackets = {\n      '{': '}',\n      '[': ']',\n      '(': ')',\n      '': ''\n    };\n    const uuids = {\n      'uuidv1': '1',\n      'uuidv2': '2',\n      'uuidv3': '3',\n      'uuidv4': '4',\n      'uuidv5': '5'\n    };\n    const versions = [];\n\n    if (guidOptions && guidOptions.version) {\n      if (!Array.isArray(guidOptions.version)) {\n        guidOptions.version = [guidOptions.version];\n      }\n\n      Hoek.assert(guidOptions.version.length >= 1, 'version must have at least 1 valid version specified');\n\n      for (let i = 0; i < guidOptions.version.length; ++i) {\n        let version = guidOptions.version[i];\n        Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n        version = version.toLowerCase();\n        Hoek.assert(uuids[version], 'version at position ' + i + ' must be one of ' + Object.keys(uuids).join(', '));\n        Hoek.assert(versions.indexOf(version) === -1, 'version at position ' + i + ' must not be a duplicate.');\n        versions.push(version);\n      }\n    }\n\n    const regex = /^([\\[{\\(]?)([0-9A-F]{8})([:-]?)([0-9A-F]{4})([:-]?)([0-9A-F]{4})([:-]?)([0-9A-F]{4})([:-]?)([0-9A-F]{12})([\\]}\\)]?)$/i;\n    return this._test('guid', guidOptions, function (value, state, options) {\n      const results = regex.exec(value);\n\n      if (!results) {\n        return this.createError('string.guid', {\n          value\n        }, state, options);\n      } // Matching braces\n\n\n      if (brackets[results[1]] !== results[11]) {\n        return this.createError('string.guid', {\n          value\n        }, state, options);\n      } // Matching separators\n\n\n      if (results[3] !== results[5] || results[3] !== results[7] || results[3] !== results[9]) {\n        return this.createError('string.guid', {\n          value\n        }, state, options);\n      } // Specific UUID versions\n\n\n      if (versions.length) {\n        const validVersions = versions.some(uuidVersion => {\n          return results[6][0] === uuids[uuidVersion];\n        }); // Valid version and 89AB check\n\n        if (!(validVersions && /[89AB]/i.test(results[8][0]))) {\n          return this.createError('string.guid', {\n            value\n          }, state, options);\n        }\n      }\n\n      return value;\n    });\n  }\n\n  hex() {\n    const regex = /^[a-f0-9]+$/i;\n    return this._test('hex', regex, function (value, state, options) {\n      if (regex.test(value)) {\n        return value;\n      }\n\n      return this.createError('string.hex', {\n        value\n      }, state, options);\n    });\n  }\n\n  hostname() {\n    const regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$/;\n    return this._test('hostname', undefined, function (value, state, options) {\n      if (value.length <= 255 && regex.test(value) || Net.isIPv6(value)) {\n        return value;\n      }\n\n      return this.createError('string.hostname', {\n        value\n      }, state, options);\n    });\n  }\n\n  lowercase() {\n    const obj = this._test('lowercase', undefined, function (value, state, options) {\n      if (options.convert || value === value.toLocaleLowerCase()) {\n        return value;\n      }\n\n      return this.createError('string.lowercase', {\n        value\n      }, state, options);\n    });\n\n    obj._flags.case = 'lower';\n    return obj;\n  }\n\n  uppercase() {\n    const obj = this._test('uppercase', undefined, function (value, state, options) {\n      if (options.convert || value === value.toLocaleUpperCase()) {\n        return value;\n      }\n\n      return this.createError('string.uppercase', {\n        value\n      }, state, options);\n    });\n\n    obj._flags.case = 'upper';\n    return obj;\n  }\n\n  trim() {\n    const obj = this._test('trim', undefined, function (value, state, options) {\n      if (options.convert || value === value.trim()) {\n        return value;\n      }\n\n      return this.createError('string.trim', {\n        value\n      }, state, options);\n    });\n\n    obj._flags.trim = true;\n    return obj;\n  }\n\n  replace(pattern, replacement) {\n    if (typeof pattern === 'string') {\n      pattern = new RegExp(Hoek.escapeRegex(pattern), 'g');\n    }\n\n    Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n    Hoek.assert(typeof replacement === 'string', 'replacement must be a String'); // This can not be considere a test like trim, we can't \"reject\"\n    // anything from this rule, so just clone the current object\n\n    const obj = this.clone();\n\n    if (!obj._inner.replacements) {\n      obj._inner.replacements = [];\n    }\n\n    obj._inner.replacements.push({\n      pattern,\n      replacement\n    });\n\n    return obj;\n  }\n\n  truncate(enabled) {\n    const obj = this.clone();\n    obj._flags.truncate = enabled === undefined ? true : !!enabled;\n    return obj;\n  }\n\n};\n\ninternals.compare = function (type, compare) {\n  return function (limit, encoding) {\n    const isRef = Ref.isRef(limit);\n    Hoek.assert(Hoek.isInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');\n    Hoek.assert(!encoding || Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n    return this._test(type, limit, function (value, state, options) {\n      let compareTo;\n\n      if (isRef) {\n        compareTo = limit(state.parent, options);\n\n        if (!Hoek.isInteger(compareTo)) {\n          return this.createError('string.ref', {\n            ref: limit.key\n          }, state, options);\n        }\n      } else {\n        compareTo = limit;\n      }\n\n      if (compare(value, compareTo, encoding)) {\n        return value;\n      }\n\n      return this.createError('string.' + type, {\n        limit: compareTo,\n        value,\n        encoding\n      }, state, options);\n    });\n  };\n};\n\ninternals.String.prototype.min = internals.compare('min', (value, limit, encoding) => {\n  const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n  return length >= limit;\n});\ninternals.String.prototype.max = internals.compare('max', (value, limit, encoding) => {\n  const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n  return length <= limit;\n});\ninternals.String.prototype.length = internals.compare('length', (value, limit, encoding) => {\n  const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n  return length === limit;\n}); // Aliases\n\ninternals.String.prototype.uuid = internals.String.prototype.guid;\nmodule.exports = new internals.String();","map":null,"metadata":{},"sourceType":"script"}