{"ast":null,"code":"var expat = require('node-expat');\n\nvar sanitizer = require('./sanitize.js');\n\nvar joi = require('joi');\n\nvar hoek = require('hoek'); // This object will hold the final result.\n\n\nvar obj = {};\nvar currentObject = {};\nvar ancestors = [];\nvar currentElementName = null;\nvar options = {}; //configuration options\n\nfunction startElement(name, attrs) {\n  currentElementName = name;\n\n  if (options.coerce) {\n    // Looping here in stead of making coerce generic as object walk is unnecessary\n    for (var key in attrs) {\n      attrs[key] = coerce(attrs[key], key);\n    }\n  }\n\n  if (!(name in currentObject)) {\n    if (options.arrayNotation) {\n      currentObject[name] = [attrs];\n    } else {\n      currentObject[name] = attrs;\n    }\n  } else if (!(currentObject[name] instanceof Array)) {\n    // Put the existing object in an array.\n    var newArray = [currentObject[name]]; // Add the new object to the array.\n\n    newArray.push(attrs); // Point to the new array.\n\n    currentObject[name] = newArray;\n  } else {\n    // An array already exists, push the attributes on to it.\n    currentObject[name].push(attrs);\n  } // Store the current (old) parent.\n\n\n  ancestors.push(currentObject); // We are now working with this object, so it becomes the current parent.\n\n  if (currentObject[name] instanceof Array) {\n    // If it is an array, get the last element of the array.\n    currentObject = currentObject[name][currentObject[name].length - 1];\n  } else {\n    // Otherwise, use the object itself.\n    currentObject = currentObject[name];\n  }\n}\n\nfunction text(data) {\n  currentObject['$t'] = (currentObject['$t'] || '') + data;\n}\n\nfunction endElement(name) {\n  if (currentObject['$t']) {\n    if (options.trim) {\n      currentObject['$t'] = currentObject['$t'].trim();\n    }\n\n    if (options.sanitize) {\n      currentObject['$t'] = sanitizer.sanitize(currentObject['$t'], true);\n    }\n\n    currentObject['$t'] = coerce(currentObject['$t'], name);\n  }\n\n  if (currentElementName !== name) {\n    delete currentObject['$t'];\n  } // This should check to make sure that the name we're ending\n  // matches the name we started on.\n\n\n  var ancestor = ancestors.pop();\n\n  if (!options.reversible) {\n    if ('$t' in currentObject && Object.keys(currentObject).length == 1) {\n      if (ancestor[name] instanceof Array) {\n        ancestor[name].push(ancestor[name].pop()['$t']);\n      } else {\n        ancestor[name] = currentObject['$t'];\n      }\n    }\n  }\n\n  currentObject = ancestor;\n}\n\nfunction coerce(value, key) {\n  if (!options.coerce || value.trim() === '') {\n    return value;\n  }\n\n  if (typeof options.coerce[key] === 'function') return options.coerce[key](value);\n  var num = Number(value);\n\n  if (!isNaN(num)) {\n    return num;\n  }\n\n  var _value = value.toLowerCase();\n\n  if (_value == 'true') {\n    return true;\n  }\n\n  if (_value == 'false') {\n    return false;\n  }\n\n  return value;\n}\n/**\n * Parses xml to json using node-expat.\n * @param {String|Buffer} xml The xml to be parsed to json.\n * @param {Object} _options An object with options provided by the user.\n * The available options are:\n *  - object: If true, the parser returns a Javascript object instead of\n *            a JSON string.\n *  - reversible: If true, the parser generates a reversible JSON, mainly\n *                characterized by the presence of the property $t.\n *  - sanitize_values: If true, the parser escapes any element value in the xml\n * that has any of the following characters: <, >, (, ), #, #, &, \", '.\n *\n * @return {String|Object} A String or an Object with the JSON representation\n * of the XML.\n */\n\n\nmodule.exports = function (xml, _options) {\n  _options = _options || {};\n  var parser = new expat.Parser('UTF-8');\n  parser.on('startElement', startElement);\n  parser.on('text', text);\n  parser.on('endElement', endElement);\n  obj = currentObject = {};\n  ancestors = [];\n  currentElementName = null;\n  var schema = {\n    object: joi.boolean().default(false),\n    reversible: joi.boolean().default(false),\n    coerce: joi.alternatives([joi.boolean(), joi.object()]).default(false),\n    sanitize: joi.boolean().default(true),\n    trim: joi.boolean().default(true),\n    arrayNotation: joi.boolean().default(false)\n  };\n  var validation = joi.validate(_options, schema);\n  hoek.assert(validation.error === null, validation.error);\n  options = validation.value;\n\n  if (!parser.parse(xml)) {\n    throw new Error('There are errors in your xml file: ' + parser.getError());\n  }\n\n  if (options.object) {\n    return obj;\n  }\n\n  var json = JSON.stringify(obj); //See: http://timelessrepo.com/json-isnt-a-javascript-subset\n\n  json = json.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n  return json;\n};","map":null,"metadata":{},"sourceType":"script"}