{"ast":null,"code":"'use strict'; // Load modules\n\nconst Hoek = require('hoek');\n\nconst Any = require('./any');\n\nconst Cast = require('./cast');\n\nconst Errors = require('./errors');\n\nconst Lazy = require('./lazy');\n\nconst Ref = require('./ref'); // Declare internals\n\n\nconst internals = {\n  alternatives: require('./alternatives'),\n  array: require('./array'),\n  boolean: require('./boolean'),\n  binary: require('./binary'),\n  date: require('./date'),\n  number: require('./number'),\n  object: require('./object'),\n  string: require('./string')\n};\n\ninternals.root = function () {\n  const any = new Any();\n  const root = any.clone();\n\n  root.any = function () {\n    return any;\n  };\n\n  root.alternatives = root.alt = function () {\n    return arguments.length ? internals.alternatives.try.apply(internals.alternatives, arguments) : internals.alternatives;\n  };\n\n  root.array = function () {\n    return internals.array;\n  };\n\n  root.boolean = root.bool = function () {\n    return internals.boolean;\n  };\n\n  root.binary = function () {\n    return internals.binary;\n  };\n\n  root.date = function () {\n    return internals.date;\n  };\n\n  root.func = function () {\n    return internals.object._func();\n  };\n\n  root.number = function () {\n    return internals.number;\n  };\n\n  root.object = function () {\n    return arguments.length ? internals.object.keys.apply(internals.object, arguments) : internals.object;\n  };\n\n  root.string = function () {\n    return internals.string;\n  };\n\n  root.ref = function () {\n    return Ref.create.apply(null, arguments);\n  };\n\n  root.isRef = function (ref) {\n    return Ref.isRef(ref);\n  };\n\n  root.validate = function (value\n  /*, [schema], [options], callback */\n  ) {\n    const last = arguments[arguments.length - 1];\n    const callback = typeof last === 'function' ? last : null;\n    const count = arguments.length - (callback ? 1 : 0);\n\n    if (count === 1) {\n      return any.validate(value, callback);\n    }\n\n    const options = count === 3 ? arguments[2] : {};\n    const schema = root.compile(arguments[1]);\n    return schema._validateWithOptions(value, options, callback);\n  };\n\n  root.describe = function () {\n    const schema = arguments.length ? root.compile(arguments[0]) : any;\n    return schema.describe();\n  };\n\n  root.compile = function (schema) {\n    try {\n      return Cast.schema(schema);\n    } catch (err) {\n      if (err.hasOwnProperty('path')) {\n        err.message = err.message + '(' + err.path + ')';\n      }\n\n      throw err;\n    }\n  };\n\n  root.assert = function (value, schema, message) {\n    root.attempt(value, schema, message);\n  };\n\n  root.attempt = function (value, schema, message) {\n    const result = root.validate(value, schema);\n    const error = result.error;\n\n    if (error) {\n      if (!message) {\n        error.message = error.annotate();\n        throw error;\n      }\n\n      if (!(message instanceof Error)) {\n        error.message = message + ' ' + error.annotate();\n        throw error;\n      }\n\n      throw message;\n    }\n\n    return result.value;\n  };\n\n  root.reach = function (schema, path) {\n    Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\n    Hoek.assert(typeof path === 'string', 'path must be a string');\n\n    if (path === '') {\n      return schema;\n    }\n\n    const parts = path.split('.');\n    const children = schema._inner.children;\n\n    if (!children) {\n      return;\n    }\n\n    const key = parts[0];\n\n    for (let i = 0; i < children.length; ++i) {\n      const child = children[i];\n\n      if (child.key === key) {\n        return this.reach(child.schema, path.substr(key.length + 1));\n      }\n    }\n  };\n\n  root.lazy = function (fn) {\n    return Lazy.set(fn);\n  };\n\n  root.extend = function () {\n    const extensions = Hoek.flatten(Array.prototype.slice.call(arguments));\n    Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\n    this.assert(extensions, root.extensionsSchema);\n    const joi = Object.create(this);\n\n    for (let i = 0; i < extensions.length; ++i) {\n      const extension = extensions[i];\n      const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\n\n      const ctor = base.constructor;\n      const type = class extends ctor {\n        // eslint-disable-line no-loop-func\n        constructor() {\n          super();\n\n          if (extension.base) {\n            Object.assign(this, base);\n          }\n\n          this._type = extension.name;\n\n          if (extension.language) {\n            this._settings = this._settings || {\n              language: {}\n            };\n            this._settings.language = Hoek.applyToDefaults(this._settings.language, {\n              [extension.name]: extension.language\n            });\n          }\n        }\n\n      };\n\n      if (extension.coerce) {\n        type.prototype._coerce = function (value, state, options) {\n          if (ctor.prototype._coerce) {\n            const baseRet = ctor.prototype._coerce.call(this, value, state, options);\n\n            if (baseRet.errors) {\n              return baseRet;\n            }\n\n            value = baseRet.value;\n          }\n\n          const ret = extension.coerce.call(this, value, state, options);\n\n          if (ret instanceof Errors.Err) {\n            return {\n              value,\n              errors: ret\n            };\n          }\n\n          return {\n            value: ret\n          };\n        };\n      }\n\n      if (extension.pre) {\n        type.prototype._base = function (value, state, options) {\n          if (ctor.prototype._base) {\n            const baseRet = ctor.prototype._base.call(this, value, state, options);\n\n            if (baseRet.errors) {\n              return baseRet;\n            }\n\n            value = baseRet.value;\n          }\n\n          const ret = extension.pre.call(this, value, state, options);\n\n          if (ret instanceof Errors.Err) {\n            return {\n              value,\n              errors: ret\n            };\n          }\n\n          return {\n            value: ret\n          };\n        };\n      }\n\n      if (extension.rules) {\n        for (let j = 0; j < extension.rules.length; ++j) {\n          const rule = extension.rules[j];\n          const ruleArgs = rule.params ? rule.params instanceof Any ? rule.params._inner.children.map(k => k.key) : Object.keys(rule.params) : [];\n          const validateArgs = rule.params ? Cast.schema(rule.params) : null;\n\n          type.prototype[rule.name] = function () {\n            // eslint-disable-line no-loop-func\n            if (arguments.length > ruleArgs.length) {\n              throw new Error('Unexpected number of arguments');\n            }\n\n            const args = Array.prototype.slice.call(arguments);\n            let hasRef = false;\n            const arg = {};\n\n            for (let k = 0; k < ruleArgs.length; ++k) {\n              arg[ruleArgs[k]] = args[k];\n\n              if (!hasRef && Ref.isRef(args[k])) {\n                hasRef = true;\n              }\n            }\n\n            if (validateArgs) {\n              joi.assert(arg, validateArgs);\n            }\n\n            let schema;\n\n            if (rule.validate) {\n              const validate = function (value, state, options) {\n                return rule.validate.call(this, arg, value, state, options);\n              };\n\n              schema = this._test(rule.name, arg, validate, {\n                description: rule.description,\n                hasRef\n              });\n            } else {\n              schema = this.clone();\n            }\n\n            if (rule.setup) {\n              rule.setup.call(schema, arg);\n            }\n\n            return schema;\n          };\n        }\n      }\n\n      if (extension.describe) {\n        type.prototype.describe = function () {\n          const description = ctor.prototype.describe.call(this);\n          return extension.describe.call(this, description);\n        };\n      }\n\n      const instance = new type();\n\n      joi[extension.name] = function () {\n        return instance;\n      };\n    }\n\n    return joi;\n  };\n\n  root.extensionsSchema = internals.array.items(internals.object.keys({\n    base: internals.object.type(Any, 'Joi object'),\n    name: internals.string.required(),\n    coerce: internals.object._func().arity(3),\n    pre: internals.object._func().arity(3),\n    language: internals.object,\n    describe: internals.object._func().arity(1),\n    rules: internals.array.items(internals.object.keys({\n      name: internals.string.required(),\n      setup: internals.object._func().arity(1),\n      validate: internals.object._func().arity(4),\n      params: [internals.object.pattern(/.*/, internals.object.type(Any, 'Joi object')), internals.object.type(internals.object.constructor, 'Joi object')],\n      description: [internals.string, internals.object._func().arity(1)]\n    }).or('setup', 'validate'))\n  })).strict();\n  return root;\n};\n\nmodule.exports = internals.root();","map":null,"metadata":{},"sourceType":"script"}