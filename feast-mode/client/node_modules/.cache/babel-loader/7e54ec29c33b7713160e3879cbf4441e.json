{"ast":null,"code":"'use strict'; // Load modules\n\nconst Hoek = require('hoek');\n\nconst Ref = require('./ref');\n\nconst Errors = require('./errors');\n\nlet Alternatives = null; // Delay-loaded to prevent circular dependencies\n\nlet Cast = null; // Declare internals\n\nconst internals = {};\ninternals.defaults = {\n  abortEarly: true,\n  convert: true,\n  allowUnknown: false,\n  skipFunctions: false,\n  stripUnknown: false,\n  language: {},\n  presence: 'optional',\n  strip: false,\n  noDefaults: false // context: null\n\n};\nmodule.exports = internals.Any = class {\n  constructor() {\n    Cast = Cast || require('./cast');\n    this.isJoi = true;\n    this._type = 'any';\n    this._settings = null;\n    this._valids = new internals.Set();\n    this._invalids = new internals.Set();\n    this._tests = [];\n    this._refs = [];\n    this._flags = {\n      /*\n       presence: 'optional',                   // optional, required, forbidden, ignore\n       allowOnly: false,\n       allowUnknown: undefined,\n       default: undefined,\n       forbidden: false,\n       encoding: undefined,\n       insensitive: false,\n       trim: false,\n       case: undefined,                        // upper, lower\n       empty: undefined,\n       func: false,\n       raw: false\n       */\n    };\n    this._description = null;\n    this._unit = null;\n    this._notes = [];\n    this._tags = [];\n    this._examples = [];\n    this._meta = [];\n    this._inner = {}; // Hash of arrays of immutable objects\n  }\n\n  createError(type, context, state, options) {\n    return Errors.create(type, context, state, options, this._flags);\n  }\n\n  checkOptions(options) {\n    const Schemas = require('./schemas');\n\n    const result = Schemas.options.validate(options);\n\n    if (result.error) {\n      throw new Error(result.error.details[0].message);\n    }\n  }\n\n  clone() {\n    const obj = Object.create(Object.getPrototypeOf(this));\n    obj.isJoi = true;\n    obj._type = this._type;\n    obj._settings = internals.concatSettings(this._settings);\n    obj._valids = Hoek.clone(this._valids);\n    obj._invalids = Hoek.clone(this._invalids);\n    obj._tests = this._tests.slice();\n    obj._refs = this._refs.slice();\n    obj._flags = Hoek.clone(this._flags);\n    obj._description = this._description;\n    obj._unit = this._unit;\n    obj._notes = this._notes.slice();\n    obj._tags = this._tags.slice();\n    obj._examples = this._examples.slice();\n    obj._meta = this._meta.slice();\n    obj._inner = {};\n    const inners = Object.keys(this._inner);\n\n    for (let i = 0; i < inners.length; ++i) {\n      const key = inners[i];\n      obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\n    }\n\n    return obj;\n  }\n\n  concat(schema) {\n    Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\n    Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\n    let obj = this.clone();\n\n    if (this._type === 'any' && schema._type !== 'any') {\n      // Reset values as if we were \"this\"\n      const tmpObj = schema.clone();\n      const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit', '_notes', '_tags', '_examples', '_meta', '_inner'];\n\n      for (let i = 0; i < keysToRestore.length; ++i) {\n        tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\n      }\n\n      obj = tmpObj;\n    }\n\n    obj._settings = obj._settings ? internals.concatSettings(obj._settings, schema._settings) : schema._settings;\n\n    obj._valids.merge(schema._valids, schema._invalids);\n\n    obj._invalids.merge(schema._invalids, schema._valids);\n\n    obj._tests = obj._tests.concat(schema._tests);\n    obj._refs = obj._refs.concat(schema._refs);\n    Hoek.merge(obj._flags, schema._flags);\n    obj._description = schema._description || obj._description;\n    obj._unit = schema._unit || obj._unit;\n    obj._notes = obj._notes.concat(schema._notes);\n    obj._tags = obj._tags.concat(schema._tags);\n    obj._examples = obj._examples.concat(schema._examples);\n    obj._meta = obj._meta.concat(schema._meta);\n    const inners = Object.keys(schema._inner);\n    const isObject = obj._type === 'object';\n\n    for (let i = 0; i < inners.length; ++i) {\n      const key = inners[i];\n      const source = schema._inner[key];\n\n      if (source) {\n        const target = obj._inner[key];\n\n        if (target) {\n          if (isObject && key === 'children') {\n            const keys = {};\n\n            for (let j = 0; j < target.length; ++j) {\n              keys[target[j].key] = j;\n            }\n\n            for (let j = 0; j < source.length; ++j) {\n              const sourceKey = source[j].key;\n\n              if (keys[sourceKey] >= 0) {\n                target[keys[sourceKey]] = {\n                  key: sourceKey,\n                  schema: target[keys[sourceKey]].schema.concat(source[j].schema)\n                };\n              } else {\n                target.push(source[j]);\n              }\n            }\n          } else {\n            obj._inner[key] = obj._inner[key].concat(source);\n          }\n        } else {\n          obj._inner[key] = source.slice();\n        }\n      }\n    }\n\n    return obj;\n  }\n\n  _test(name, arg, func, options) {\n    const obj = this.clone();\n\n    obj._tests.push({\n      func,\n      name,\n      arg,\n      options\n    });\n\n    return obj;\n  }\n\n  options(options) {\n    Hoek.assert(!options.context, 'Cannot override context');\n    this.checkOptions(options);\n    const obj = this.clone();\n    obj._settings = internals.concatSettings(obj._settings, options);\n    return obj;\n  }\n\n  strict(isStrict) {\n    const obj = this.clone();\n    obj._settings = obj._settings || {};\n    obj._settings.convert = isStrict === undefined ? false : !isStrict;\n    return obj;\n  }\n\n  raw(isRaw) {\n    const obj = this.clone();\n    obj._flags.raw = isRaw === undefined ? true : isRaw;\n    return obj;\n  }\n\n  error(err) {\n    Hoek.assert(err && err instanceof Error, 'Must provide a valid Error object');\n    const obj = this.clone();\n    obj._flags.error = err;\n    return obj;\n  }\n\n  _allow() {\n    const values = Hoek.flatten(Array.prototype.slice.call(arguments));\n\n    for (let i = 0; i < values.length; ++i) {\n      const value = values[i];\n      Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n\n      this._invalids.remove(value);\n\n      this._valids.add(value, this._refs);\n    }\n  }\n\n  allow() {\n    const obj = this.clone();\n\n    obj._allow.apply(obj, arguments);\n\n    return obj;\n  }\n\n  valid() {\n    const obj = this.allow.apply(this, arguments);\n    obj._flags.allowOnly = true;\n    return obj;\n  }\n\n  invalid(value) {\n    const obj = this.clone();\n    const values = Hoek.flatten(Array.prototype.slice.call(arguments));\n\n    for (let i = 0; i < values.length; ++i) {\n      value = values[i];\n      Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n\n      obj._valids.remove(value);\n\n      obj._invalids.add(value, this._refs);\n    }\n\n    return obj;\n  }\n\n  required() {\n    const obj = this.clone();\n    obj._flags.presence = 'required';\n    return obj;\n  }\n\n  optional() {\n    const obj = this.clone();\n    obj._flags.presence = 'optional';\n    return obj;\n  }\n\n  forbidden() {\n    const obj = this.clone();\n    obj._flags.presence = 'forbidden';\n    return obj;\n  }\n\n  strip() {\n    const obj = this.clone();\n    obj._flags.strip = true;\n    return obj;\n  }\n\n  applyFunctionToChildren(children, fn, args, root) {\n    children = [].concat(children);\n\n    if (children.length !== 1 || children[0] !== '') {\n      root = root ? root + '.' : '';\n      const extraChildren = (children[0] === '' ? children.slice(1) : children).map(child => {\n        return root + child;\n      });\n      throw new Error('unknown key(s) ' + extraChildren.join(', '));\n    }\n\n    return this[fn].apply(this, args);\n  }\n\n  default(value, description) {\n    if (typeof value === 'function' && !Ref.isRef(value)) {\n      if (!value.description && description) {\n        value.description = description;\n      }\n\n      if (!this._flags.func) {\n        Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\n      }\n    }\n\n    const obj = this.clone();\n    obj._flags.default = value;\n    Ref.push(obj._refs, value);\n    return obj;\n  }\n\n  empty(schema) {\n    const obj = this.clone();\n    obj._flags.empty = schema === undefined ? undefined : Cast.schema(schema);\n    return obj;\n  }\n\n  when(ref, options) {\n    Hoek.assert(options && typeof options === 'object', 'Invalid options');\n    Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n    const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(options.then)) : undefined;\n    const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(options.otherwise)) : undefined;\n    Alternatives = Alternatives || require('./alternatives');\n    const obj = Alternatives.when(ref, {\n      is: options.is,\n      then,\n      otherwise\n    });\n    obj._flags.presence = 'ignore';\n    obj._settings = internals.concatSettings(obj._settings, {\n      baseType: this\n    });\n    return obj;\n  }\n\n  description(desc) {\n    Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\n    const obj = this.clone();\n    obj._description = desc;\n    return obj;\n  }\n\n  notes(notes) {\n    Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\n    const obj = this.clone();\n    obj._notes = obj._notes.concat(notes);\n    return obj;\n  }\n\n  tags(tags) {\n    Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\n    const obj = this.clone();\n    obj._tags = obj._tags.concat(tags);\n    return obj;\n  }\n\n  meta(meta) {\n    Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\n    const obj = this.clone();\n    obj._meta = obj._meta.concat(meta);\n    return obj;\n  }\n\n  example(value) {\n    Hoek.assert(arguments.length, 'Missing example');\n\n    const result = this._validate(value, null, internals.defaults);\n\n    Hoek.assert(!result.errors, 'Bad example:', result.errors && Errors.process(result.errors, value));\n    const obj = this.clone();\n\n    obj._examples.push(value);\n\n    return obj;\n  }\n\n  unit(name) {\n    Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\n    const obj = this.clone();\n    obj._unit = name;\n    return obj;\n  }\n\n  _validate(value, state, options, reference) {\n    const originalValue = value; // Setup state and settings\n\n    state = state || {\n      key: '',\n      path: '',\n      parent: null,\n      reference\n    };\n\n    if (this._settings) {\n      options = internals.concatSettings(options, this._settings);\n    }\n\n    let errors = [];\n\n    const finish = () => {\n      let finalValue;\n\n      if (!this._flags.strip) {\n        if (value !== undefined) {\n          finalValue = this._flags.raw ? originalValue : value;\n        } else if (options.noDefaults) {\n          finalValue = originalValue;\n        } else if (Ref.isRef(this._flags.default)) {\n          finalValue = this._flags.default(state.parent, options);\n        } else if (typeof this._flags.default === 'function' && !(this._flags.func && !this._flags.default.description)) {\n          let args;\n\n          if (state.parent !== null && this._flags.default.length > 0) {\n            args = [Hoek.clone(state.parent), options];\n          }\n\n          const defaultValue = internals._try(this._flags.default, args);\n\n          finalValue = defaultValue.value;\n\n          if (defaultValue.error) {\n            errors.push(this.createError('any.default', defaultValue.error, state, options));\n          }\n        } else {\n          finalValue = Hoek.clone(this._flags.default);\n        }\n      }\n\n      return {\n        value: finalValue,\n        errors: errors.length ? errors : null\n      };\n    };\n\n    if (this._coerce) {\n      const coerced = this._coerce.call(this, value, state, options);\n\n      if (coerced.errors) {\n        value = coerced.value;\n        errors = errors.concat(coerced.errors);\n        return finish(); // Coerced error always aborts early\n      }\n\n      value = coerced.value;\n    }\n\n    if (this._flags.empty && !this._flags.empty._validate(value, null, internals.defaults).errors) {\n      value = undefined;\n    } // Check presence requirements\n\n\n    const presence = this._flags.presence || options.presence;\n\n    if (presence === 'optional') {\n      if (value === undefined) {\n        const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\n\n        if (isDeepDefault && this._type === 'object') {\n          value = {};\n        } else {\n          return finish();\n        }\n      }\n    } else if (presence === 'required' && value === undefined) {\n      errors.push(this.createError('any.required', null, state, options));\n      return finish();\n    } else if (presence === 'forbidden') {\n      if (value === undefined) {\n        return finish();\n      }\n\n      errors.push(this.createError('any.unknown', null, state, options));\n      return finish();\n    } // Check allowed and denied values using the original value\n\n\n    if (this._valids.has(value, state, options, this._flags.insensitive)) {\n      return finish();\n    }\n\n    if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n      errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', null, state, options));\n\n      if (options.abortEarly || value === undefined) {\n        // No reason to keep validating missing value\n        return finish();\n      }\n    } // Convert value and validate type\n\n\n    if (this._base) {\n      const base = this._base.call(this, value, state, options);\n\n      if (base.errors) {\n        value = base.value;\n        errors = errors.concat(base.errors);\n        return finish(); // Base error always aborts early\n      }\n\n      if (base.value !== value) {\n        value = base.value; // Check allowed and denied values using the converted value\n\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\n          return finish();\n        }\n\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n          errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', null, state, options));\n\n          if (options.abortEarly) {\n            return finish();\n          }\n        }\n      }\n    } // Required values did not match\n\n\n    if (this._flags.allowOnly) {\n      errors.push(this.createError('any.allowOnly', {\n        valids: this._valids.values({\n          stripUndefined: true\n        })\n      }, state, options));\n\n      if (options.abortEarly) {\n        return finish();\n      }\n    } // Helper.validate tests\n\n\n    for (let i = 0; i < this._tests.length; ++i) {\n      const test = this._tests[i];\n      const ret = test.func.call(this, value, state, options);\n\n      if (ret instanceof Errors.Err) {\n        errors.push(ret);\n\n        if (options.abortEarly) {\n          return finish();\n        }\n      } else {\n        value = ret;\n      }\n    }\n\n    return finish();\n  }\n\n  _validateWithOptions(value, options, callback) {\n    if (options) {\n      this.checkOptions(options);\n    }\n\n    const settings = internals.concatSettings(internals.defaults, options);\n\n    const result = this._validate(value, null, settings);\n\n    const errors = Errors.process(result.errors, value);\n\n    if (callback) {\n      return callback(errors, result.value);\n    }\n\n    return {\n      error: errors,\n      value: result.value\n    };\n  }\n\n  validate(value, options, callback) {\n    if (typeof options === 'function') {\n      return this._validateWithOptions(value, null, options);\n    }\n\n    return this._validateWithOptions(value, options, callback);\n  }\n\n  describe() {\n    const description = {\n      type: this._type\n    };\n    const flags = Object.keys(this._flags);\n\n    if (flags.length) {\n      if (['empty', 'default', 'lazy', 'label'].some(flag => this._flags.hasOwnProperty(flag))) {\n        description.flags = {};\n\n        for (let i = 0; i < flags.length; ++i) {\n          const flag = flags[i];\n\n          if (flag === 'empty') {\n            description.flags[flag] = this._flags[flag].describe();\n          } else if (flag === 'default') {\n            if (Ref.isRef(this._flags[flag])) {\n              description.flags[flag] = this._flags[flag].toString();\n            } else if (typeof this._flags[flag] === 'function') {\n              description.flags[flag] = this._flags[flag].description;\n            } else {\n              description.flags[flag] = this._flags[flag];\n            }\n          } else if (flag === 'lazy' || flag === 'label') {// We don't want it in the description\n          } else {\n            description.flags[flag] = this._flags[flag];\n          }\n        }\n      } else {\n        description.flags = this._flags;\n      }\n    }\n\n    if (this._description) {\n      description.description = this._description;\n    }\n\n    if (this._notes.length) {\n      description.notes = this._notes;\n    }\n\n    if (this._tags.length) {\n      description.tags = this._tags;\n    }\n\n    if (this._meta.length) {\n      description.meta = this._meta;\n    }\n\n    if (this._examples.length) {\n      description.examples = this._examples;\n    }\n\n    if (this._unit) {\n      description.unit = this._unit;\n    }\n\n    const valids = this._valids.values();\n\n    if (valids.length) {\n      description.valids = valids.map(v => {\n        return Ref.isRef(v) ? v.toString() : v;\n      });\n    }\n\n    const invalids = this._invalids.values();\n\n    if (invalids.length) {\n      description.invalids = invalids.map(v => {\n        return Ref.isRef(v) ? v.toString() : v;\n      });\n    }\n\n    description.rules = [];\n\n    for (let i = 0; i < this._tests.length; ++i) {\n      const validator = this._tests[i];\n      const item = {\n        name: validator.name\n      };\n\n      if (validator.arg !== void 0) {\n        item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\n      }\n\n      const options = validator.options;\n\n      if (options) {\n        if (options.hasRef) {\n          item.arg = {};\n          const keys = Object.keys(validator.arg);\n\n          for (let j = 0; j < keys.length; ++j) {\n            const key = keys[j];\n            const value = validator.arg[key];\n            item.arg[key] = Ref.isRef(value) ? value.toString() : value;\n          }\n        }\n\n        if (typeof options.description === 'string') {\n          item.description = options.description;\n        } else if (typeof options.description === 'function') {\n          item.description = options.description(item.arg);\n        }\n      }\n\n      description.rules.push(item);\n    }\n\n    if (!description.rules.length) {\n      delete description.rules;\n    }\n\n    const label = this._getLabel();\n\n    if (label) {\n      description.label = label;\n    }\n\n    return description;\n  }\n\n  label(name) {\n    Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\n    const obj = this.clone();\n    obj._flags.label = name;\n    return obj;\n  }\n\n  _getLabel(def) {\n    return this._flags.label || def;\n  }\n\n};\ninternals.Any.prototype.isImmutable = true; // Prevents Hoek from deep cloning schema objects\n// Aliases\n\ninternals.Any.prototype.only = internals.Any.prototype.equal = internals.Any.prototype.valid;\ninternals.Any.prototype.disallow = internals.Any.prototype.not = internals.Any.prototype.invalid;\ninternals.Any.prototype.exist = internals.Any.prototype.required;\n\ninternals._try = function (fn, args) {\n  let err;\n  let result;\n\n  try {\n    result = fn.apply(null, args);\n  } catch (e) {\n    err = e;\n  }\n\n  return {\n    value: result,\n    error: err\n  };\n};\n\ninternals.Set = class {\n  constructor() {\n    this._set = [];\n  }\n\n  add(value, refs) {\n    if (!Ref.isRef(value) && this.has(value, null, null, false)) {\n      return;\n    }\n\n    if (refs !== undefined) {\n      // If it's a merge, we don't have any refs\n      Ref.push(refs, value);\n    }\n\n    this._set.push(value);\n  }\n\n  merge(add, remove) {\n    for (let i = 0; i < add._set.length; ++i) {\n      this.add(add._set[i]);\n    }\n\n    for (let i = 0; i < remove._set.length; ++i) {\n      this.remove(remove._set[i]);\n    }\n  }\n\n  remove(value) {\n    this._set = this._set.filter(item => value !== item);\n  }\n\n  has(value, state, options, insensitive) {\n    for (let i = 0; i < this._set.length; ++i) {\n      let items = this._set[i];\n\n      if (state && Ref.isRef(items)) {\n        // Only resolve references if there is a state, otherwise it's a merge\n        items = items(state.reference || state.parent, options);\n      }\n\n      if (!Array.isArray(items)) {\n        items = [items];\n      }\n\n      for (let j = 0; j < items.length; ++j) {\n        const item = items[j];\n\n        if (typeof value !== typeof item) {\n          continue;\n        }\n\n        if (value === item || value instanceof Date && item instanceof Date && value.getTime() === item.getTime() || insensitive && typeof value === 'string' && value.toLowerCase() === item.toLowerCase() || Buffer.isBuffer(value) && Buffer.isBuffer(item) && value.length === item.length && value.toString('binary') === item.toString('binary')) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  values(options) {\n    if (options && options.stripUndefined) {\n      const values = [];\n\n      for (let i = 0; i < this._set.length; ++i) {\n        const item = this._set[i];\n\n        if (item !== undefined) {\n          values.push(item);\n        }\n      }\n\n      return values;\n    }\n\n    return this._set.slice();\n  }\n\n};\n\ninternals.concatSettings = function (target, source) {\n  // Used to avoid cloning context\n  if (!target && !source) {\n    return null;\n  }\n\n  const obj = {};\n\n  if (target) {\n    Object.assign(obj, target);\n  }\n\n  if (source) {\n    const sKeys = Object.keys(source);\n\n    for (let i = 0; i < sKeys.length; ++i) {\n      const key = sKeys[i];\n\n      if (key !== 'language' || !obj.hasOwnProperty(key)) {\n        obj[key] = source[key];\n      } else {\n        obj[key] = Hoek.applyToDefaults(obj[key], source[key]);\n      }\n    }\n  }\n\n  return obj;\n};","map":null,"metadata":{},"sourceType":"script"}