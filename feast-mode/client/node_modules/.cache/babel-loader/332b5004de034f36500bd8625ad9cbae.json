{"ast":null,"code":"'use strict'; // Load modules\n\nconst Hoek = require('hoek');\n\nconst Topo = require('topo');\n\nconst Any = require('./any');\n\nconst Errors = require('./errors');\n\nconst Cast = require('./cast');\n\nconst Ref = require('./ref'); // Declare internals\n\n\nconst internals = {};\ninternals.Object = class extends Any {\n  constructor() {\n    super();\n    this._type = 'object';\n    this._inner.children = null;\n    this._inner.renames = [];\n    this._inner.dependencies = [];\n    this._inner.patterns = [];\n  }\n\n  _base(value, state, options) {\n    let target = value;\n    const errors = [];\n\n    const finish = () => {\n      return {\n        value: target,\n        errors: errors.length ? errors : null\n      };\n    };\n\n    if (typeof value === 'string' && options.convert) {\n      value = internals.safeParse(value);\n    }\n\n    const type = this._flags.func ? 'function' : 'object';\n\n    if (!value || typeof value !== type || Array.isArray(value)) {\n      errors.push(this.createError(type + '.base', null, state, options));\n      return finish();\n    } // Skip if there are no other rules to test\n\n\n    if (!this._inner.renames.length && !this._inner.dependencies.length && !this._inner.children && // null allows any keys\n    !this._inner.patterns.length) {\n      target = value;\n      return finish();\n    } // Ensure target is a local copy (parsed) or shallow copy\n\n\n    if (target === value) {\n      if (type === 'object') {\n        target = Object.create(Object.getPrototypeOf(value));\n      } else {\n        target = function () {\n          return value.apply(this, arguments);\n        };\n\n        target.prototype = Hoek.clone(value.prototype);\n      }\n\n      const valueKeys = Object.keys(value);\n\n      for (let i = 0; i < valueKeys.length; ++i) {\n        target[valueKeys[i]] = value[valueKeys[i]];\n      }\n    } else {\n      target = value;\n    } // Rename keys\n\n\n    const renamed = {};\n\n    for (let i = 0; i < this._inner.renames.length; ++i) {\n      const rename = this._inner.renames[i];\n\n      if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\n        continue;\n      }\n\n      if (!rename.options.multiple && renamed[rename.to]) {\n        errors.push(this.createError('object.rename.multiple', {\n          from: rename.from,\n          to: rename.to\n        }, state, options));\n\n        if (options.abortEarly) {\n          return finish();\n        }\n      }\n\n      if (Object.prototype.hasOwnProperty.call(target, rename.to) && !rename.options.override && !renamed[rename.to]) {\n        errors.push(this.createError('object.rename.override', {\n          from: rename.from,\n          to: rename.to\n        }, state, options));\n\n        if (options.abortEarly) {\n          return finish();\n        }\n      }\n\n      if (target[rename.from] === undefined) {\n        delete target[rename.to];\n      } else {\n        target[rename.to] = target[rename.from];\n      }\n\n      renamed[rename.to] = true;\n\n      if (!rename.options.alias) {\n        delete target[rename.from];\n      }\n    } // Validate schema\n\n\n    if (!this._inner.children && // null allows any keys\n    !this._inner.patterns.length && !this._inner.dependencies.length) {\n      return finish();\n    }\n\n    const unprocessed = Hoek.mapToObject(Object.keys(target));\n\n    if (this._inner.children) {\n      for (let i = 0; i < this._inner.children.length; ++i) {\n        const child = this._inner.children[i];\n        const key = child.key;\n        const item = target[key];\n        delete unprocessed[key];\n        const localState = {\n          key,\n          path: (state.path || '') + (state.path && key ? '.' : '') + key,\n          parent: target,\n          reference: state.reference\n        };\n\n        const result = child.schema._validate(item, localState, options);\n\n        if (result.errors) {\n          errors.push(this.createError('object.child', {\n            key,\n            child: child.schema._getLabel(key),\n            reason: result.errors\n          }, localState, options));\n\n          if (options.abortEarly) {\n            return finish();\n          }\n        }\n\n        if (child.schema._flags.strip || result.value === undefined && result.value !== item) {\n          delete target[key];\n        } else if (result.value !== undefined) {\n          target[key] = result.value;\n        }\n      }\n    } // Unknown keys\n\n\n    let unprocessedKeys = Object.keys(unprocessed);\n\n    if (unprocessedKeys.length && this._inner.patterns.length) {\n      for (let i = 0; i < unprocessedKeys.length; ++i) {\n        const key = unprocessedKeys[i];\n        const localState = {\n          key,\n          path: (state.path ? state.path + '.' : '') + key,\n          parent: target,\n          reference: state.reference\n        };\n        const item = target[key];\n\n        for (let j = 0; j < this._inner.patterns.length; ++j) {\n          const pattern = this._inner.patterns[j];\n\n          if (pattern.regex.test(key)) {\n            delete unprocessed[key];\n\n            const result = pattern.rule._validate(item, localState, options);\n\n            if (result.errors) {\n              errors.push(this.createError('object.child', {\n                key,\n                child: pattern.rule._getLabel(key),\n                reason: result.errors\n              }, localState, options));\n\n              if (options.abortEarly) {\n                return finish();\n              }\n            }\n\n            if (result.value !== undefined) {\n              target[key] = result.value;\n            }\n          }\n        }\n      }\n\n      unprocessedKeys = Object.keys(unprocessed);\n    }\n\n    if ((this._inner.children || this._inner.patterns.length) && unprocessedKeys.length) {\n      if (options.stripUnknown || options.skipFunctions) {\n        const stripUnknown = options.stripUnknown ? options.stripUnknown === true ? true : !!options.stripUnknown.objects : false;\n\n        for (let i = 0; i < unprocessedKeys.length; ++i) {\n          const key = unprocessedKeys[i];\n\n          if (stripUnknown) {\n            delete target[key];\n            delete unprocessed[key];\n          } else if (typeof target[key] === 'function') {\n            delete unprocessed[key];\n          }\n        }\n\n        unprocessedKeys = Object.keys(unprocessed);\n      }\n\n      if (unprocessedKeys.length && (this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\n        for (let i = 0; i < unprocessedKeys.length; ++i) {\n          const unprocessedKey = unprocessedKeys[i];\n          errors.push(this.createError('object.allowUnknown', {\n            child: unprocessedKey\n          }, {\n            key: unprocessedKey,\n            path: state.path + (state.path ? '.' : '') + unprocessedKey\n          }, options));\n        }\n      }\n    } // Validate dependencies\n\n\n    for (let i = 0; i < this._inner.dependencies.length; ++i) {\n      const dep = this._inner.dependencies[i];\n      const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, {\n        key: dep.key,\n        path: (state.path || '') + (dep.key ? '.' + dep.key : '')\n      }, options);\n\n      if (err instanceof Errors.Err) {\n        errors.push(err);\n\n        if (options.abortEarly) {\n          return finish();\n        }\n      }\n    }\n\n    return finish();\n  }\n\n  _func() {\n    const obj = this.clone();\n    obj._flags.func = true;\n    return obj;\n  }\n\n  keys(schema) {\n    Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\n    Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\n    const obj = this.clone();\n\n    if (!schema) {\n      obj._inner.children = null;\n      return obj;\n    }\n\n    const children = Object.keys(schema);\n\n    if (!children.length) {\n      obj._inner.children = [];\n      return obj;\n    }\n\n    const topo = new Topo();\n\n    if (obj._inner.children) {\n      for (let i = 0; i < obj._inner.children.length; ++i) {\n        const child = obj._inner.children[i]; // Only add the key if we are not going to replace it later\n\n        if (children.indexOf(child.key) === -1) {\n          topo.add(child, {\n            after: child._refs,\n            group: child.key\n          });\n        }\n      }\n    }\n\n    for (let i = 0; i < children.length; ++i) {\n      const key = children[i];\n      const child = schema[key];\n\n      try {\n        const cast = Cast.schema(child);\n        topo.add({\n          key,\n          schema: cast\n        }, {\n          after: cast._refs,\n          group: key\n        });\n      } catch (castErr) {\n        if (castErr.hasOwnProperty('path')) {\n          castErr.path = key + '.' + castErr.path;\n        } else {\n          castErr.path = key;\n        }\n\n        throw castErr;\n      }\n    }\n\n    obj._inner.children = topo.nodes;\n    return obj;\n  }\n\n  unknown(allow) {\n    const obj = this.clone();\n    obj._flags.allowUnknown = allow !== false;\n    return obj;\n  }\n\n  length(limit) {\n    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n    return this._test('length', limit, function (value, state, options) {\n      if (Object.keys(value).length === limit) {\n        return value;\n      }\n\n      return this.createError('object.length', {\n        limit\n      }, state, options);\n    });\n  }\n\n  arity(n) {\n    Hoek.assert(Hoek.isInteger(n) && n >= 0, 'n must be a positive integer');\n    return this._test('arity', n, function (value, state, options) {\n      if (value.length === n) {\n        return value;\n      }\n\n      return this.createError('function.arity', {\n        n\n      }, state, options);\n    });\n  }\n\n  minArity(n) {\n    Hoek.assert(Hoek.isInteger(n) && n > 0, 'n must be a strict positive integer');\n    return this._test('minArity', n, function (value, state, options) {\n      if (value.length >= n) {\n        return value;\n      }\n\n      return this.createError('function.minArity', {\n        n\n      }, state, options);\n    });\n  }\n\n  maxArity(n) {\n    Hoek.assert(Hoek.isInteger(n) && n >= 0, 'n must be a positive integer');\n    return this._test('maxArity', n, function (value, state, options) {\n      if (value.length <= n) {\n        return value;\n      }\n\n      return this.createError('function.maxArity', {\n        n\n      }, state, options);\n    });\n  }\n\n  min(limit) {\n    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n    return this._test('min', limit, function (value, state, options) {\n      if (Object.keys(value).length >= limit) {\n        return value;\n      }\n\n      return this.createError('object.min', {\n        limit\n      }, state, options);\n    });\n  }\n\n  max(limit) {\n    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n    return this._test('max', limit, function (value, state, options) {\n      if (Object.keys(value).length <= limit) {\n        return value;\n      }\n\n      return this.createError('object.max', {\n        limit\n      }, state, options);\n    });\n  }\n\n  pattern(pattern, schema) {\n    Hoek.assert(pattern instanceof RegExp, 'Invalid regular expression');\n    Hoek.assert(schema !== undefined, 'Invalid rule');\n    pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined); // Future version should break this and forbid unsupported regex flags\n\n    try {\n      schema = Cast.schema(schema);\n    } catch (castErr) {\n      if (castErr.hasOwnProperty('path')) {\n        castErr.message = castErr.message + '(' + castErr.path + ')';\n      }\n\n      throw castErr;\n    }\n\n    const obj = this.clone();\n\n    obj._inner.patterns.push({\n      regex: pattern,\n      rule: schema\n    });\n\n    return obj;\n  }\n\n  schema() {\n    return this._test('schema', null, function (value, state, options) {\n      if (value instanceof Any) {\n        return value;\n      }\n\n      return this.createError('object.schema', null, state, options);\n    });\n  }\n\n  with(key, peers) {\n    return this._dependency('with', key, peers);\n  }\n\n  without(key, peers) {\n    return this._dependency('without', key, peers);\n  }\n\n  xor() {\n    const peers = Hoek.flatten(Array.prototype.slice.call(arguments));\n    return this._dependency('xor', null, peers);\n  }\n\n  or() {\n    const peers = Hoek.flatten(Array.prototype.slice.call(arguments));\n    return this._dependency('or', null, peers);\n  }\n\n  and() {\n    const peers = Hoek.flatten(Array.prototype.slice.call(arguments));\n    return this._dependency('and', null, peers);\n  }\n\n  nand() {\n    const peers = Hoek.flatten(Array.prototype.slice.call(arguments));\n    return this._dependency('nand', null, peers);\n  }\n\n  requiredKeys(children) {\n    children = Hoek.flatten(Array.prototype.slice.call(arguments));\n    return this.applyFunctionToChildren(children, 'required');\n  }\n\n  optionalKeys(children) {\n    children = Hoek.flatten(Array.prototype.slice.call(arguments));\n    return this.applyFunctionToChildren(children, 'optional');\n  }\n\n  rename(from, to, options) {\n    Hoek.assert(typeof from === 'string', 'Rename missing the from argument');\n    Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\n    Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\n\n    for (let i = 0; i < this._inner.renames.length; ++i) {\n      Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\n    }\n\n    const obj = this.clone();\n\n    obj._inner.renames.push({\n      from,\n      to,\n      options: Hoek.applyToDefaults(internals.renameDefaults, options || {})\n    });\n\n    return obj;\n  }\n\n  applyFunctionToChildren(children, fn, args, root) {\n    children = [].concat(children);\n    Hoek.assert(children.length > 0, 'expected at least one children');\n    const groupedChildren = internals.groupChildren(children);\n    let obj;\n\n    if ('' in groupedChildren) {\n      obj = this[fn].apply(this, args);\n      delete groupedChildren[''];\n    } else {\n      obj = this.clone();\n    }\n\n    if (obj._inner.children) {\n      root = root ? root + '.' : '';\n\n      for (let i = 0; i < obj._inner.children.length; ++i) {\n        const child = obj._inner.children[i];\n        const group = groupedChildren[child.key];\n\n        if (group) {\n          obj._inner.children[i] = {\n            key: child.key,\n            _refs: child._refs,\n            schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\n          };\n          delete groupedChildren[child.key];\n        }\n      }\n    }\n\n    const remaining = Object.keys(groupedChildren);\n    Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\n    return obj;\n  }\n\n  _dependency(type, key, peers) {\n    peers = [].concat(peers);\n\n    for (let i = 0; i < peers.length; ++i) {\n      Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\n    }\n\n    const obj = this.clone();\n\n    obj._inner.dependencies.push({\n      type,\n      key,\n      peers\n    });\n\n    return obj;\n  }\n\n  describe(shallow) {\n    const description = Any.prototype.describe.call(this);\n\n    if (description.rules) {\n      for (let i = 0; i < description.rules.length; ++i) {\n        const rule = description.rules[i]; // Coverage off for future-proof descriptions, only object().assert() is use right now\n\n        if (\n        /* $lab:coverage:off$ */\n        rule.arg && typeof rule.arg === 'object' && rule.arg.schema && rule.arg.ref\n        /* $lab:coverage:on$ */\n        ) {\n            rule.arg = {\n              schema: rule.arg.schema.describe(),\n              ref: rule.arg.ref.toString()\n            };\n          }\n      }\n    }\n\n    if (this._inner.children && !shallow) {\n      description.children = {};\n\n      for (let i = 0; i < this._inner.children.length; ++i) {\n        const child = this._inner.children[i];\n        description.children[child.key] = child.schema.describe();\n      }\n    }\n\n    if (this._inner.dependencies.length) {\n      description.dependencies = Hoek.clone(this._inner.dependencies);\n    }\n\n    if (this._inner.patterns.length) {\n      description.patterns = [];\n\n      for (let i = 0; i < this._inner.patterns.length; ++i) {\n        const pattern = this._inner.patterns[i];\n        description.patterns.push({\n          regex: pattern.regex.toString(),\n          rule: pattern.rule.describe()\n        });\n      }\n    }\n\n    return description;\n  }\n\n  assert(ref, schema, message) {\n    ref = Cast.ref(ref);\n    Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\n    message = message || 'pass the assertion test';\n\n    try {\n      schema = Cast.schema(schema);\n    } catch (castErr) {\n      if (castErr.hasOwnProperty('path')) {\n        castErr.message = castErr.message + '(' + castErr.path + ')';\n      }\n\n      throw castErr;\n    }\n\n    const key = ref.path[ref.path.length - 1];\n    const path = ref.path.join('.');\n    return this._test('assert', {\n      schema,\n      ref\n    }, function (value, state, options) {\n      const result = schema._validate(ref(value), null, options, value);\n\n      if (!result.errors) {\n        return value;\n      }\n\n      const localState = Hoek.merge({}, state);\n      localState.key = key;\n      localState.path = path;\n      return this.createError('object.assert', {\n        ref: localState.path,\n        message\n      }, localState, options);\n    });\n  }\n\n  type(constructor, name) {\n    Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\n    name = name || constructor.name;\n    return this._test('type', name, function (value, state, options) {\n      if (value instanceof constructor) {\n        return value;\n      }\n\n      return this.createError('object.type', {\n        type: name\n      }, state, options);\n    });\n  }\n\n  ref() {\n    return this._test('ref', null, function (value, state, options) {\n      if (Ref.isRef(value)) {\n        return value;\n      }\n\n      return this.createError('function.ref', null, state, options);\n    });\n  }\n\n};\n\ninternals.safeParse = function (value) {\n  try {\n    return JSON.parse(value);\n  } catch (parseErr) {}\n\n  return value;\n};\n\ninternals.renameDefaults = {\n  alias: false,\n  // Keep old value in place\n  multiple: false,\n  // Allow renaming multiple keys into the same target\n  override: false // Overrides an existing key\n\n};\n\ninternals.groupChildren = function (children) {\n  children.sort();\n  const grouped = {};\n\n  for (let i = 0; i < children.length; ++i) {\n    const child = children[i];\n    Hoek.assert(typeof child === 'string', 'children must be strings');\n    const group = child.split('.')[0];\n    const childGroup = grouped[group] = grouped[group] || [];\n    childGroup.push(child.substring(group.length + 1));\n  }\n\n  return grouped;\n};\n\ninternals.with = function (value, peers, parent, state, options) {\n  if (value === undefined) {\n    return value;\n  }\n\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n\n    if (!Object.prototype.hasOwnProperty.call(parent, peer) || parent[peer] === undefined) {\n      return this.createError('object.with', {\n        peer\n      }, state, options);\n    }\n  }\n\n  return value;\n};\n\ninternals.without = function (value, peers, parent, state, options) {\n  if (value === undefined) {\n    return value;\n  }\n\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n\n    if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== undefined) {\n      return this.createError('object.without', {\n        peer\n      }, state, options);\n    }\n  }\n\n  return value;\n};\n\ninternals.xor = function (value, peers, parent, state, options) {\n  const present = [];\n\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n\n    if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== undefined) {\n      present.push(peer);\n    }\n  }\n\n  if (present.length === 1) {\n    return value;\n  }\n\n  if (present.length === 0) {\n    return this.createError('object.missing', {\n      peers\n    }, state, options);\n  }\n\n  return this.createError('object.xor', {\n    peers\n  }, state, options);\n};\n\ninternals.or = function (value, peers, parent, state, options) {\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n\n    if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== undefined) {\n      return value;\n    }\n  }\n\n  return this.createError('object.missing', {\n    peers\n  }, state, options);\n};\n\ninternals.and = function (value, peers, parent, state, options) {\n  const missing = [];\n  const present = [];\n  const count = peers.length;\n\n  for (let i = 0; i < count; ++i) {\n    const peer = peers[i];\n\n    if (!Object.prototype.hasOwnProperty.call(parent, peer) || parent[peer] === undefined) {\n      missing.push(peer);\n    } else {\n      present.push(peer);\n    }\n  }\n\n  const aon = missing.length === count || present.length === count;\n  return !aon ? this.createError('object.and', {\n    present,\n    missing\n  }, state, options) : null;\n};\n\ninternals.nand = function (value, peers, parent, state, options) {\n  const present = [];\n\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n\n    if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== undefined) {\n      present.push(peer);\n    }\n  }\n\n  const values = Hoek.clone(peers);\n  const main = values.splice(0, 1)[0];\n  const allPresent = present.length === peers.length;\n  return allPresent ? this.createError('object.nand', {\n    main,\n    peers: values\n  }, state, options) : null;\n};\n\nmodule.exports = new internals.Object();","map":null,"metadata":{},"sourceType":"script"}