{"ast":null,"code":"'use strict'; // Load modules\n\nconst Any = require('./any');\n\nconst Cast = require('./cast');\n\nconst Hoek = require('hoek'); // Declare internals\n\n\nconst internals = {};\n\ninternals.fastSplice = function (arr, i) {\n  let pos = i;\n\n  while (pos < arr.length) {\n    arr[pos++] = arr[pos];\n  }\n\n  --arr.length;\n};\n\ninternals.Array = class extends Any {\n  constructor() {\n    super();\n    this._type = 'array';\n    this._inner.items = [];\n    this._inner.ordereds = [];\n    this._inner.inclusions = [];\n    this._inner.exclusions = [];\n    this._inner.requireds = [];\n    this._flags.sparse = false;\n  }\n\n  _base(value, state, options) {\n    const result = {\n      value\n    };\n\n    if (typeof value === 'string' && options.convert) {\n      internals.safeParse(value, result);\n    }\n\n    let isArray = Array.isArray(result.value);\n    const wasArray = isArray;\n\n    if (options.convert && this._flags.single && !isArray) {\n      result.value = [result.value];\n      isArray = true;\n    }\n\n    if (!isArray) {\n      result.errors = this.createError('array.base', null, state, options);\n      return result;\n    }\n\n    if (this._inner.inclusions.length || this._inner.exclusions.length || this._inner.requireds.length || this._inner.ordereds.length || !this._flags.sparse) {\n      // Clone the array so that we don't modify the original\n      if (wasArray) {\n        result.value = result.value.slice(0);\n      }\n\n      result.errors = this._checkItems.call(this, result.value, wasArray, state, options);\n\n      if (result.errors && wasArray && options.convert && this._flags.single) {\n        // Attempt a 2nd pass by putting the array inside one.\n        const previousErrors = result.errors;\n        result.value = [result.value];\n        result.errors = this._checkItems.call(this, result.value, wasArray, state, options);\n\n        if (result.errors) {\n          // Restore previous errors and value since this didn't validate either.\n          result.errors = previousErrors;\n          result.value = result.value[0];\n        }\n      }\n    }\n\n    return result;\n  }\n\n  _checkItems(items, wasArray, state, options) {\n    const errors = [];\n    let errored;\n\n    const requireds = this._inner.requireds.slice();\n\n    const ordereds = this._inner.ordereds.slice();\n\n    const inclusions = this._inner.inclusions.concat(requireds);\n\n    let il = items.length;\n\n    for (let i = 0; i < il; ++i) {\n      errored = false;\n      const item = items[i];\n      let isValid = false;\n      const key = wasArray ? i : state.key;\n      const path = wasArray ? (state.path ? state.path + '.' : '') + i : state.path;\n      const localState = {\n        key,\n        path,\n        parent: state.parent,\n        reference: state.reference\n      };\n      let res; // Sparse\n\n      if (!this._flags.sparse && item === undefined) {\n        errors.push(this.createError('array.sparse', null, {\n          key: state.key,\n          path: localState.path,\n          pos: i\n        }, options));\n\n        if (options.abortEarly) {\n          return errors;\n        }\n\n        continue;\n      } // Exclusions\n\n\n      for (let j = 0; j < this._inner.exclusions.length; ++j) {\n        res = this._inner.exclusions[j]._validate(item, localState, {}); // Not passing options to use defaults\n\n        if (!res.errors) {\n          errors.push(this.createError(wasArray ? 'array.excludes' : 'array.excludesSingle', {\n            pos: i,\n            value: item\n          }, {\n            key: state.key,\n            path: localState.path\n          }, options));\n          errored = true;\n\n          if (options.abortEarly) {\n            return errors;\n          }\n\n          break;\n        }\n      }\n\n      if (errored) {\n        continue;\n      } // Ordered\n\n\n      if (this._inner.ordereds.length) {\n        if (ordereds.length > 0) {\n          const ordered = ordereds.shift();\n          res = ordered._validate(item, localState, options);\n\n          if (!res.errors) {\n            if (ordered._flags.strip) {\n              internals.fastSplice(items, i);\n              --i;\n              --il;\n            } else if (!this._flags.sparse && res.value === undefined) {\n              errors.push(this.createError('array.sparse', null, {\n                key: state.key,\n                path: localState.path,\n                pos: i\n              }, options));\n\n              if (options.abortEarly) {\n                return errors;\n              }\n\n              continue;\n            } else {\n              items[i] = res.value;\n            }\n          } else {\n            errors.push(this.createError('array.ordered', {\n              pos: i,\n              reason: res.errors,\n              value: item\n            }, {\n              key: state.key,\n              path: localState.path\n            }, options));\n\n            if (options.abortEarly) {\n              return errors;\n            }\n          }\n\n          continue;\n        } else if (!this._inner.items.length) {\n          errors.push(this.createError('array.orderedLength', {\n            pos: i,\n            limit: this._inner.ordereds.length\n          }, {\n            key: state.key,\n            path: localState.path\n          }, options));\n\n          if (options.abortEarly) {\n            return errors;\n          }\n\n          continue;\n        }\n      } // Requireds\n\n\n      const requiredChecks = [];\n      let jl = requireds.length;\n\n      for (let j = 0; j < jl; ++j) {\n        res = requiredChecks[j] = requireds[j]._validate(item, localState, options);\n\n        if (!res.errors) {\n          items[i] = res.value;\n          isValid = true;\n          internals.fastSplice(requireds, j);\n          --j;\n          --jl;\n\n          if (!this._flags.sparse && res.value === undefined) {\n            errors.push(this.createError('array.sparse', null, {\n              key: state.key,\n              path: localState.path,\n              pos: i\n            }, options));\n\n            if (options.abortEarly) {\n              return errors;\n            }\n          }\n\n          break;\n        }\n      }\n\n      if (isValid) {\n        continue;\n      } // Inclusions\n\n\n      const stripUnknown = options.stripUnknown ? options.stripUnknown === true ? true : !!options.stripUnknown.arrays : false;\n      jl = inclusions.length;\n\n      for (let j = 0; j < jl; ++j) {\n        const inclusion = inclusions[j]; // Avoid re-running requireds that already didn't match in the previous loop\n\n        const previousCheck = requireds.indexOf(inclusion);\n\n        if (previousCheck !== -1) {\n          res = requiredChecks[previousCheck];\n        } else {\n          res = inclusion._validate(item, localState, options);\n\n          if (!res.errors) {\n            if (inclusion._flags.strip) {\n              internals.fastSplice(items, i);\n              --i;\n              --il;\n            } else if (!this._flags.sparse && res.value === undefined) {\n              errors.push(this.createError('array.sparse', null, {\n                key: state.key,\n                path: localState.path,\n                pos: i\n              }, options));\n              errored = true;\n            } else {\n              items[i] = res.value;\n            }\n\n            isValid = true;\n            break;\n          }\n        } // Return the actual error if only one inclusion defined\n\n\n        if (jl === 1) {\n          if (stripUnknown) {\n            internals.fastSplice(items, i);\n            --i;\n            --il;\n            isValid = true;\n            break;\n          }\n\n          errors.push(this.createError(wasArray ? 'array.includesOne' : 'array.includesOneSingle', {\n            pos: i,\n            reason: res.errors,\n            value: item\n          }, {\n            key: state.key,\n            path: localState.path\n          }, options));\n          errored = true;\n\n          if (options.abortEarly) {\n            return errors;\n          }\n\n          break;\n        }\n      }\n\n      if (errored) {\n        continue;\n      }\n\n      if (this._inner.inclusions.length && !isValid) {\n        if (stripUnknown) {\n          internals.fastSplice(items, i);\n          --i;\n          --il;\n          continue;\n        }\n\n        errors.push(this.createError(wasArray ? 'array.includes' : 'array.includesSingle', {\n          pos: i,\n          value: item\n        }, {\n          key: state.key,\n          path: localState.path\n        }, options));\n\n        if (options.abortEarly) {\n          return errors;\n        }\n      }\n    }\n\n    if (requireds.length) {\n      this._fillMissedErrors.call(this, errors, requireds, state, options);\n    }\n\n    if (ordereds.length) {\n      this._fillOrderedErrors.call(this, errors, ordereds, state, options);\n    }\n\n    return errors.length ? errors : null;\n  }\n\n  describe() {\n    const description = Any.prototype.describe.call(this);\n\n    if (this._inner.ordereds.length) {\n      description.orderedItems = [];\n\n      for (let i = 0; i < this._inner.ordereds.length; ++i) {\n        description.orderedItems.push(this._inner.ordereds[i].describe());\n      }\n    }\n\n    if (this._inner.items.length) {\n      description.items = [];\n\n      for (let i = 0; i < this._inner.items.length; ++i) {\n        description.items.push(this._inner.items[i].describe());\n      }\n    }\n\n    return description;\n  }\n\n  items() {\n    const obj = this.clone();\n    Hoek.flatten(Array.prototype.slice.call(arguments)).forEach((type, index) => {\n      try {\n        type = Cast.schema(type);\n      } catch (castErr) {\n        if (castErr.hasOwnProperty('path')) {\n          castErr.path = index + '.' + castErr.path;\n        } else {\n          castErr.path = index;\n        }\n\n        castErr.message = castErr.message + '(' + castErr.path + ')';\n        throw castErr;\n      }\n\n      obj._inner.items.push(type);\n\n      if (type._flags.presence === 'required') {\n        obj._inner.requireds.push(type);\n      } else if (type._flags.presence === 'forbidden') {\n        obj._inner.exclusions.push(type.optional());\n      } else {\n        obj._inner.inclusions.push(type);\n      }\n    });\n    return obj;\n  }\n\n  ordered() {\n    const obj = this.clone();\n    Hoek.flatten(Array.prototype.slice.call(arguments)).forEach((type, index) => {\n      try {\n        type = Cast.schema(type);\n      } catch (castErr) {\n        if (castErr.hasOwnProperty('path')) {\n          castErr.path = index + '.' + castErr.path;\n        } else {\n          castErr.path = index;\n        }\n\n        castErr.message = castErr.message + '(' + castErr.path + ')';\n        throw castErr;\n      }\n\n      obj._inner.ordereds.push(type);\n    });\n    return obj;\n  }\n\n  min(limit) {\n    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n    return this._test('min', limit, function (value, state, options) {\n      if (value.length >= limit) {\n        return value;\n      }\n\n      return this.createError('array.min', {\n        limit,\n        value\n      }, state, options);\n    });\n  }\n\n  max(limit) {\n    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n    return this._test('max', limit, function (value, state, options) {\n      if (value.length <= limit) {\n        return value;\n      }\n\n      return this.createError('array.max', {\n        limit,\n        value\n      }, state, options);\n    });\n  }\n\n  length(limit) {\n    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n    return this._test('length', limit, function (value, state, options) {\n      if (value.length === limit) {\n        return value;\n      }\n\n      return this.createError('array.length', {\n        limit,\n        value\n      }, state, options);\n    });\n  }\n\n  unique(comparator) {\n    const isCustom = !!comparator;\n    comparator = comparator || Hoek.deepEqual;\n    Hoek.assert(typeof comparator === 'function', 'comparator must be a function');\n    return this._test('unique', undefined, function (value, state, options) {\n      const found = {\n        string: {},\n        number: {},\n        undefined: {},\n        boolean: {},\n        object: [],\n        function: [],\n        custom: []\n      };\n\n      for (let i = 0; i < value.length; ++i) {\n        const item = value[i];\n        const type = typeof item;\n        const records = isCustom ? found.custom : found[type]; // All available types are supported, so it's not possible to reach 100% coverage without ignoring this line.\n        // I still want to keep the test for future js versions with new types (eg. Symbol).\n\n        if (\n        /* $lab:coverage:off$ */\n        records\n        /* $lab:coverage:on$ */\n        ) {\n            if (Array.isArray(records)) {\n              for (let j = 0; j < records.length; ++j) {\n                if (comparator(records[j], item)) {\n                  return this.createError('array.unique', {\n                    pos: i,\n                    value: item\n                  }, state, options);\n                }\n              }\n\n              records.push(item);\n            } else {\n              if (records[item]) {\n                return this.createError('array.unique', {\n                  pos: i,\n                  value: item\n                }, state, options);\n              }\n\n              records[item] = true;\n            }\n          }\n      }\n\n      return value;\n    });\n  }\n\n  sparse(enabled) {\n    const obj = this.clone();\n    obj._flags.sparse = enabled === undefined ? true : !!enabled;\n    return obj;\n  }\n\n  single(enabled) {\n    const obj = this.clone();\n    obj._flags.single = enabled === undefined ? true : !!enabled;\n    return obj;\n  }\n\n  _fillMissedErrors(errors, requireds, state, options) {\n    const knownMisses = [];\n    let unknownMisses = 0;\n\n    for (let i = 0; i < requireds.length; ++i) {\n      const label = requireds[i]._getLabel();\n\n      if (label) {\n        knownMisses.push(label);\n      } else {\n        ++unknownMisses;\n      }\n    }\n\n    if (knownMisses.length) {\n      if (unknownMisses) {\n        errors.push(this.createError('array.includesRequiredBoth', {\n          knownMisses,\n          unknownMisses\n        }, {\n          key: state.key,\n          path: state.path\n        }, options));\n      } else {\n        errors.push(this.createError('array.includesRequiredKnowns', {\n          knownMisses\n        }, {\n          key: state.key,\n          path: state.path\n        }, options));\n      }\n    } else {\n      errors.push(this.createError('array.includesRequiredUnknowns', {\n        unknownMisses\n      }, {\n        key: state.key,\n        path: state.path\n      }, options));\n    }\n  }\n\n  _fillOrderedErrors(errors, ordereds, state, options) {\n    const requiredOrdereds = [];\n\n    for (let i = 0; i < ordereds.length; ++i) {\n      const presence = Hoek.reach(ordereds[i], '_flags.presence');\n\n      if (presence === 'required') {\n        requiredOrdereds.push(ordereds[i]);\n      }\n    }\n\n    if (requiredOrdereds.length) {\n      this._fillMissedErrors.call(this, errors, requiredOrdereds, state, options);\n    }\n  }\n\n};\n\ninternals.safeParse = function (value, result) {\n  try {\n    const converted = JSON.parse(value);\n\n    if (Array.isArray(converted)) {\n      result.value = converted;\n    }\n  } catch (e) {}\n};\n\nmodule.exports = new internals.Array();","map":null,"metadata":{},"sourceType":"script"}