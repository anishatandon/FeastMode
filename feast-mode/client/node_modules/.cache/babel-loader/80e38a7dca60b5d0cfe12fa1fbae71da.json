{"ast":null,"code":"!function (t, e) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = e(require(\"react\")) : \"function\" == typeof define && define.amd ? define([\"react\"], e) : \"object\" == typeof exports ? exports.reactAvatar = e(require(\"react\")) : t.reactAvatar = e(t.react);\n}(window, function (t) {\n  return function (t) {\n    var e = {};\n\n    function i(n) {\n      if (e[n]) return e[n].exports;\n      var a = e[n] = {\n        i: n,\n        l: !1,\n        exports: {}\n      };\n      return t[n].call(a.exports, a, a.exports, i), a.l = !0, a.exports;\n    }\n\n    return i.m = t, i.c = e, i.d = function (t, e, n) {\n      i.o(t, e) || Object.defineProperty(t, e, {\n        configurable: !1,\n        enumerable: !0,\n        get: n\n      });\n    }, i.r = function (t) {\n      Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      });\n    }, i.n = function (t) {\n      var e = t && t.__esModule ? function () {\n        return t.default;\n      } : function () {\n        return t;\n      };\n      return i.d(e, \"a\", e), e;\n    }, i.o = function (t, e) {\n      return Object.prototype.hasOwnProperty.call(t, e);\n    }, i.p = \"\", i(i.s = 22);\n  }([function (e, i) {\n    e.exports = t;\n  }, function (t, e, i) {\n    t.exports = i(21), i(19), i(18), i(17), i(16), i(15), i(14), i(13), i(12), i(11), i(10), i(9), i(8);\n  }, function (t, e) {\n    !function () {\n      \"use strict\";\n\n      Konva.DD = {\n        anim: new Konva.Animation(function () {\n          var t = this.dirty;\n          return this.dirty = !1, t;\n        }),\n        isDragging: !1,\n        justDragged: !1,\n        offset: {\n          x: 0,\n          y: 0\n        },\n        node: null,\n        _drag: function (t) {\n          var e = Konva.DD,\n              i = e.node;\n\n          if (i) {\n            if (!e.isDragging) {\n              var n = i.getStage().getPointerPosition();\n              n || (i.getStage()._setPointerPosition(t), n = i.getStage().getPointerPosition());\n              var a = i.dragDistance();\n              if (Math.max(Math.abs(n.x - e.startPointerPos.x), Math.abs(n.y - e.startPointerPos.y)) < a) return;\n            }\n\n            if (i.getStage()._setPointerPosition(t), !e.isDragging && (e.isDragging = !0, i.fire(\"dragstart\", {\n              type: \"dragstart\",\n              target: i,\n              evt: t\n            }, !0), !i.isDragging())) return;\n            i._setDragPosition(t), i.fire(\"dragmove\", {\n              type: \"dragmove\",\n              target: i,\n              evt: t\n            }, !0);\n          }\n        },\n        _endDragBefore: function (t) {\n          var e,\n              i = Konva.DD,\n              n = i.node;\n          n && (e = n.getLayer(), i.anim.stop(), i.isDragging && (i.isDragging = !1, i.justDragged = !0, Konva.listenClickTap = !1, t && (t.dragEndNode = n)), delete i.node, (n.getLayer() || e || n instanceof Konva.Stage) && (e || n).draw());\n        },\n        _endDragAfter: function (t) {\n          var e = (t = t || {}).dragEndNode;\n          t && e && e.fire(\"dragend\", {\n            type: \"dragend\",\n            target: e,\n            evt: t\n          }, !0);\n        }\n      }, Konva.Node.prototype.startDrag = function () {\n        var t = Konva.DD,\n            e = this.getStage(),\n            i = this.getLayer(),\n            n = e.getPointerPosition(),\n            a = this.getAbsolutePosition();\n        n && (t.node && t.node.stopDrag(), t.node = this, t.startPointerPos = n, t.offset.x = n.x - a.x, t.offset.y = n.y - a.y, t.anim.setLayers(i || this.getLayers()), t.anim.start(), this._setDragPosition());\n      }, Konva.Node.prototype._setDragPosition = function (t) {\n        var e = Konva.DD,\n            i = this.getStage().getPointerPosition(),\n            n = this.getDragBoundFunc();\n\n        if (i) {\n          var a = {\n            x: i.x - e.offset.x,\n            y: i.y - e.offset.y\n          };\n          void 0 !== n && (a = n.call(this, a, t)), this.setAbsolutePosition(a), this._lastPos && this._lastPos.x === a.x && this._lastPos.y === a.y || (e.anim.dirty = !0), this._lastPos = a;\n        }\n      }, Konva.Node.prototype.stopDrag = function () {\n        var t = Konva.DD,\n            e = {};\n        t._endDragBefore(e), t._endDragAfter(e);\n      }, Konva.Node.prototype.setDraggable = function (t) {\n        this._setAttr(\"draggable\", t), this._dragChange();\n      };\n      var t = Konva.Node.prototype.remove;\n      Konva.Node.prototype.__originalRemove = t, Konva.Node.prototype.remove = function () {\n        var e = Konva.DD;\n        e.node && e.node._id === this._id && this.stopDrag(), t.call(this);\n      }, Konva.Node.prototype.isDragging = function () {\n        var t = Konva.DD;\n        return !(!t.node || t.node._id !== this._id || !t.isDragging);\n      }, Konva.Node.prototype._listenDrag = function () {\n        var t = this;\n        this._dragCleanup(), \"Stage\" === this.getClassName() ? this.on(\"contentMousedown.konva contentTouchstart.konva\", function (e) {\n          Konva.DD.node || t.startDrag(e);\n        }) : this.on(\"mousedown.konva touchstart.konva\", function (e) {\n          1 !== e.evt.button && 2 !== e.evt.button && (Konva.DD.node || t.startDrag(e));\n        });\n      }, Konva.Node.prototype._dragChange = function () {\n        if (this.attrs.draggable) this._listenDrag();else {\n          this._dragCleanup();\n\n          var t = this.getStage(),\n              e = Konva.DD;\n          t && e.node && e.node._id === this._id && e.node.stopDrag();\n        }\n      }, Konva.Node.prototype._dragCleanup = function () {\n        \"Stage\" === this.getClassName() ? (this.off(\"contentMousedown.konva\"), this.off(\"contentTouchstart.konva\")) : (this.off(\"mousedown.konva\"), this.off(\"touchstart.konva\"));\n      }, Konva.Factory.addGetterSetter(Konva.Node, \"dragBoundFunc\"), Konva.Factory.addGetter(Konva.Node, \"draggable\", !1), Konva.Factory.addOverloadedGetterSetter(Konva.Node, \"draggable\"), Konva.isBrowser && (window.addEventListener(\"mouseup\", Konva.DD._endDragBefore, !0), window.addEventListener(\"touchend\", Konva.DD._endDragBefore, !0), window.addEventListener(\"mousemove\", Konva.DD._drag), window.addEventListener(\"touchmove\", Konva.DD._drag), window.addEventListener(\"mouseup\", Konva.DD._endDragAfter, !1), window.addEventListener(\"touchend\", Konva.DD._endDragAfter, !1));\n    }();\n  }, function (t, e) {\n    !function (t) {\n      \"use strict\";\n\n      var e = t.global.performance && t.global.performance.now ? function () {\n        return t.global.performance.now();\n      } : function () {\n        return new Date().getTime();\n      };\n\n      var i = t.global.requestAnimationFrame || t.global.webkitRequestAnimationFrame || t.global.mozRequestAnimationFrame || t.global.oRequestAnimationFrame || t.global.msRequestAnimationFrame || function (t) {\n        setTimeout(t, 1e3 / 60);\n      };\n\n      function n() {\n        return i.apply(t.global, arguments);\n      }\n\n      t.Animation = function (i, n) {\n        var a = t.Animation;\n        this.func = i, this.setLayers(n), this.id = a.animIdCounter++, this.frame = {\n          time: 0,\n          timeDiff: 0,\n          lastTime: e()\n        };\n      }, t.Animation.prototype = {\n        setLayers: function (t) {\n          var e;\n          return e = t ? t.length > 0 ? t : [t] : [], this.layers = e, this;\n        },\n        getLayers: function () {\n          return this.layers;\n        },\n        addLayer: function (t) {\n          var e,\n              i = this.layers,\n              n = i.length;\n\n          for (e = 0; e < n; e++) if (i[e]._id === t._id) return !1;\n\n          return this.layers.push(t), !0;\n        },\n        isRunning: function () {\n          var e,\n              i = t.Animation.animations,\n              n = i.length;\n\n          for (e = 0; e < n; e++) if (i[e].id === this.id) return !0;\n\n          return !1;\n        },\n        start: function () {\n          var i = t.Animation;\n          return this.stop(), this.frame.timeDiff = 0, this.frame.lastTime = e(), i._addAnimation(this), this;\n        },\n        stop: function () {\n          return t.Animation._removeAnimation(this), this;\n        },\n        _updateFrameObject: function (t) {\n          this.frame.timeDiff = t - this.frame.lastTime, this.frame.lastTime = t, this.frame.time += this.frame.timeDiff, this.frame.frameRate = 1e3 / this.frame.timeDiff;\n        }\n      }, t.Animation.animations = [], t.Animation.animIdCounter = 0, t.Animation.animRunning = !1, t.Animation._addAnimation = function (t) {\n        this.animations.push(t), this._handleAnimation();\n      }, t.Animation._removeAnimation = function (t) {\n        var e,\n            i = t.id,\n            n = this.animations,\n            a = n.length;\n\n        for (e = 0; e < a; e++) if (n[e].id === i) {\n          this.animations.splice(e, 1);\n          break;\n        }\n      }, t.Animation._runFrames = function () {\n        var t,\n            i,\n            n,\n            a,\n            r,\n            o,\n            s,\n            h,\n            l = {},\n            c = this.animations;\n\n        for (a = 0; a < c.length; a++) if (i = (t = c[a]).layers, n = t.func, t._updateFrameObject(e()), o = i.length, !n || !1 !== n.call(t, t.frame)) for (r = 0; r < o; r++) void 0 !== (s = i[r])._id && (l[s._id] = s);\n\n        for (h in l) l.hasOwnProperty(h) && l[h].draw();\n      }, t.Animation._animationLoop = function () {\n        var e = t.Animation;\n        e.animations.length ? (e._runFrames(), n(e._animationLoop)) : e.animRunning = !1;\n      }, t.Animation._handleAnimation = function () {\n        this.animRunning || (this.animRunning = !0, n(this._animationLoop));\n      }, t.BaseLayer.prototype.batchDraw = function () {\n        var e = this,\n            i = t.Animation;\n        return this.batchAnim || (this.batchAnim = new i(function () {\n          e.batchAnim.stop();\n        }, this)), this.batchAnim.isRunning() || this.batchAnim.start(), this;\n      }, t.Stage.prototype.batchDraw = function () {\n        return this.getChildren().each(function (t) {\n          t.batchDraw();\n        }), this;\n      };\n    }(Konva);\n  }, function (t, e) {\n    !function () {\n      \"use strict\";\n\n      Konva.Path = function (t) {\n        this.___init(t);\n      }, Konva.Path.prototype = {\n        ___init: function (t) {\n          this.dataArray = [];\n          var e = this;\n          Konva.Shape.call(this, t), this.className = \"Path\", this.dataArray = Konva.Path.parsePathData(this.getData()), this.pathLength = 0;\n\n          for (var i = 0; i < this.dataArray.length; ++i) this.pathLength += this.dataArray[i].pathLength;\n\n          this.on(\"dataChange.konva\", function () {\n            e.dataArray = Konva.Path.parsePathData(this.getData()), this.pathLength = 0;\n\n            for (var t = 0; t < this.dataArray.length; ++t) this.pathLength += this.dataArray[t].pathLength;\n          }), this.sceneFunc(this._sceneFunc);\n        },\n        _sceneFunc: function (t) {\n          var e = this.dataArray;\n          t.beginPath();\n\n          for (var i = 0; i < e.length; i++) {\n            var n = e[i].command,\n                a = e[i].points;\n\n            switch (n) {\n              case \"L\":\n                t.lineTo(a[0], a[1]);\n                break;\n\n              case \"M\":\n                t.moveTo(a[0], a[1]);\n                break;\n\n              case \"C\":\n                t.bezierCurveTo(a[0], a[1], a[2], a[3], a[4], a[5]);\n                break;\n\n              case \"Q\":\n                t.quadraticCurveTo(a[0], a[1], a[2], a[3]);\n                break;\n\n              case \"A\":\n                var r = a[0],\n                    o = a[1],\n                    s = a[2],\n                    h = a[3],\n                    l = a[4],\n                    c = a[5],\n                    d = a[6],\n                    u = a[7],\n                    f = s > h ? s : h,\n                    g = s > h ? 1 : s / h,\n                    v = s > h ? h / s : 1;\n                t.translate(r, o), t.rotate(d), t.scale(g, v), t.arc(0, 0, f, l, l + c, 1 - u), t.scale(1 / g, 1 / v), t.rotate(-d), t.translate(-r, -o);\n                break;\n\n              case \"z\":\n                t.closePath();\n            }\n          }\n\n          t.fillStrokeShape(this);\n        },\n        getSelfRect: function () {\n          var t = [];\n          this.dataArray.forEach(function (e) {\n            t = t.concat(e.points);\n          });\n\n          for (var e, i, n = t[0], a = t[0], r = t[1], o = t[1], s = 0; s < t.length / 2; s++) e = t[2 * s], i = t[2 * s + 1], isNaN(e) || (n = Math.min(n, e), a = Math.max(a, e)), isNaN(i) || (r = Math.min(r, i), o = Math.max(o, i));\n\n          return {\n            x: Math.round(n),\n            y: Math.round(r),\n            width: Math.round(a - n),\n            height: Math.round(o - r)\n          };\n        },\n        getLength: function () {\n          return this.pathLength;\n        },\n        getPointAtLength: function (t) {\n          var e,\n              i = 0,\n              n = this.dataArray.length;\n          if (!n) return null;\n\n          for (; i < n && t > this.dataArray[i].pathLength;) t -= this.dataArray[i].pathLength, ++i;\n\n          if (i === n) return {\n            x: (e = this.dataArray[i - 1].points.slice(-2))[0],\n            y: e[1]\n          };\n          if (t < .01) return {\n            x: (e = this.dataArray[i].points.slice(0, 2))[0],\n            y: e[1]\n          };\n          var a = this.dataArray[i],\n              r = a.points;\n\n          switch (a.command) {\n            case \"L\":\n              return Konva.Path.getPointOnLine(t, a.start.x, a.start.y, r[0], r[1]);\n\n            case \"C\":\n              return Konva.Path.getPointOnCubicBezier(t / a.pathLength, a.start.x, a.start.y, r[0], r[1], r[2], r[3], r[4], r[5]);\n\n            case \"Q\":\n              return Konva.Path.getPointOnQuadraticBezier(t / a.pathLength, a.start.x, a.start.y, r[0], r[1], r[2], r[3]);\n\n            case \"A\":\n              var o = r[0],\n                  s = r[1],\n                  h = r[2],\n                  l = r[3],\n                  c = r[4],\n                  d = r[5],\n                  u = r[6];\n              return c += d * t / a.pathLength, Konva.Path.getPointOnEllipticalArc(o, s, h, l, c, u);\n          }\n\n          return null;\n        }\n      }, Konva.Util.extend(Konva.Path, Konva.Shape), Konva.Path.getLineLength = function (t, e, i, n) {\n        return Math.sqrt((i - t) * (i - t) + (n - e) * (n - e));\n      }, Konva.Path.getPointOnLine = function (t, e, i, n, a, r, o) {\n        void 0 === r && (r = e), void 0 === o && (o = i);\n        var s = (a - i) / (n - e + 1e-8),\n            h = Math.sqrt(t * t / (1 + s * s));\n        n < e && (h *= -1);\n        var l,\n            c = s * h;\n        if (n === e) l = {\n          x: r,\n          y: o + c\n        };else if ((o - i) / (r - e + 1e-8) === s) l = {\n          x: r + h,\n          y: o + c\n        };else {\n          var d,\n              u,\n              f = this.getLineLength(e, i, n, a);\n          if (f < 1e-8) return;\n          var g = (r - e) * (n - e) + (o - i) * (a - i);\n          d = e + (g /= f * f) * (n - e), u = i + g * (a - i);\n          var v = this.getLineLength(r, o, d, u),\n              p = Math.sqrt(t * t - v * v);\n          h = Math.sqrt(p * p / (1 + s * s)), n < e && (h *= -1), l = {\n            x: d + h,\n            y: u + (c = s * h)\n          };\n        }\n        return l;\n      }, Konva.Path.getPointOnCubicBezier = function (t, e, i, n, a, r, o, s, h) {\n        function l(t) {\n          return t * t * t;\n        }\n\n        function c(t) {\n          return 3 * t * t * (1 - t);\n        }\n\n        function d(t) {\n          return 3 * t * (1 - t) * (1 - t);\n        }\n\n        function u(t) {\n          return (1 - t) * (1 - t) * (1 - t);\n        }\n\n        return {\n          x: s * l(t) + r * c(t) + n * d(t) + e * u(t),\n          y: h * l(t) + o * c(t) + a * d(t) + i * u(t)\n        };\n      }, Konva.Path.getPointOnQuadraticBezier = function (t, e, i, n, a, r, o) {\n        function s(t) {\n          return t * t;\n        }\n\n        function h(t) {\n          return 2 * t * (1 - t);\n        }\n\n        function l(t) {\n          return (1 - t) * (1 - t);\n        }\n\n        return {\n          x: r * s(t) + n * h(t) + e * l(t),\n          y: o * s(t) + a * h(t) + i * l(t)\n        };\n      }, Konva.Path.getPointOnEllipticalArc = function (t, e, i, n, a, r) {\n        var o = Math.cos(r),\n            s = Math.sin(r),\n            h = i * Math.cos(a),\n            l = n * Math.sin(a);\n        return {\n          x: t + (h * o - l * s),\n          y: e + (h * s + l * o)\n        };\n      }, Konva.Path.parsePathData = function (t) {\n        if (!t) return [];\n        var e = t,\n            i = [\"m\", \"M\", \"l\", \"L\", \"v\", \"V\", \"h\", \"H\", \"z\", \"Z\", \"c\", \"C\", \"q\", \"Q\", \"t\", \"T\", \"s\", \"S\", \"a\", \"A\"];\n        e = e.replace(new RegExp(\" \", \"g\"), \",\");\n\n        for (var n = 0; n < i.length; n++) e = e.replace(new RegExp(i[n], \"g\"), \"|\" + i[n]);\n\n        var a,\n            r = e.split(\"|\"),\n            o = [],\n            s = [],\n            h = 0,\n            l = 0,\n            c = /([-+]?((\\d+\\.\\d+)|((\\d+)|(\\.\\d+)))(?:e[-+]?\\d+)?)/gi;\n\n        for (n = 1; n < r.length; n++) {\n          var d = r[n],\n              u = d.charAt(0);\n\n          for (d = d.slice(1), s.length = 0; a = c.exec(d);) s.push(a[0]);\n\n          for (var f = [], g = 0, v = s.length; g < v; g++) {\n            var p = parseFloat(s[g]);\n            isNaN(p) ? f.push(0) : f.push(p);\n          }\n\n          for (; f.length > 0 && !isNaN(f[0]);) {\n            var m,\n                y,\n                _,\n                b,\n                C,\n                S,\n                w,\n                x,\n                K,\n                k,\n                A = null,\n                P = [],\n                D = h,\n                L = l;\n\n            switch (u) {\n              case \"l\":\n                h += f.shift(), l += f.shift(), A = \"L\", P.push(h, l);\n                break;\n\n              case \"L\":\n                h = f.shift(), l = f.shift(), P.push(h, l);\n                break;\n\n              case \"m\":\n                var F = f.shift(),\n                    T = f.shift();\n                if (h += F, l += T, A = \"M\", o.length > 2 && \"z\" === o[o.length - 1].command) for (var G = o.length - 2; G >= 0; G--) if (\"M\" === o[G].command) {\n                  h = o[G].points[0] + F, l = o[G].points[1] + T;\n                  break;\n                }\n                P.push(h, l), u = \"l\";\n                break;\n\n              case \"M\":\n                h = f.shift(), l = f.shift(), A = \"M\", P.push(h, l), u = \"L\";\n                break;\n\n              case \"h\":\n                h += f.shift(), A = \"L\", P.push(h, l);\n                break;\n\n              case \"H\":\n                h = f.shift(), A = \"L\", P.push(h, l);\n                break;\n\n              case \"v\":\n                l += f.shift(), A = \"L\", P.push(h, l);\n                break;\n\n              case \"V\":\n                l = f.shift(), A = \"L\", P.push(h, l);\n                break;\n\n              case \"C\":\n                P.push(f.shift(), f.shift(), f.shift(), f.shift()), h = f.shift(), l = f.shift(), P.push(h, l);\n                break;\n\n              case \"c\":\n                P.push(h + f.shift(), l + f.shift(), h + f.shift(), l + f.shift()), h += f.shift(), l += f.shift(), A = \"C\", P.push(h, l);\n                break;\n\n              case \"S\":\n                y = h, _ = l, \"C\" === (m = o[o.length - 1]).command && (y = h + (h - m.points[2]), _ = l + (l - m.points[3])), P.push(y, _, f.shift(), f.shift()), h = f.shift(), l = f.shift(), A = \"C\", P.push(h, l);\n                break;\n\n              case \"s\":\n                y = h, _ = l, \"C\" === (m = o[o.length - 1]).command && (y = h + (h - m.points[2]), _ = l + (l - m.points[3])), P.push(y, _, h + f.shift(), l + f.shift()), h += f.shift(), l += f.shift(), A = \"C\", P.push(h, l);\n                break;\n\n              case \"Q\":\n                P.push(f.shift(), f.shift()), h = f.shift(), l = f.shift(), P.push(h, l);\n                break;\n\n              case \"q\":\n                P.push(h + f.shift(), l + f.shift()), h += f.shift(), l += f.shift(), A = \"Q\", P.push(h, l);\n                break;\n\n              case \"T\":\n                y = h, _ = l, \"Q\" === (m = o[o.length - 1]).command && (y = h + (h - m.points[0]), _ = l + (l - m.points[1])), h = f.shift(), l = f.shift(), A = \"Q\", P.push(y, _, h, l);\n                break;\n\n              case \"t\":\n                y = h, _ = l, \"Q\" === (m = o[o.length - 1]).command && (y = h + (h - m.points[0]), _ = l + (l - m.points[1])), h += f.shift(), l += f.shift(), A = \"Q\", P.push(y, _, h, l);\n                break;\n\n              case \"A\":\n                b = f.shift(), C = f.shift(), S = f.shift(), w = f.shift(), x = f.shift(), K = h, k = l, h = f.shift(), l = f.shift(), A = \"A\", P = this.convertEndpointToCenterParameterization(K, k, h, l, w, x, b, C, S);\n                break;\n\n              case \"a\":\n                b = f.shift(), C = f.shift(), S = f.shift(), w = f.shift(), x = f.shift(), K = h, k = l, h += f.shift(), l += f.shift(), A = \"A\", P = this.convertEndpointToCenterParameterization(K, k, h, l, w, x, b, C, S);\n            }\n\n            o.push({\n              command: A || u,\n              points: P,\n              start: {\n                x: D,\n                y: L\n              },\n              pathLength: this.calcLength(D, L, A || u, P)\n            });\n          }\n\n          \"z\" !== u && \"Z\" !== u || o.push({\n            command: \"z\",\n            points: [],\n            start: void 0,\n            pathLength: 0\n          });\n        }\n\n        return o;\n      }, Konva.Path.calcLength = function (t, e, i, n) {\n        var a,\n            r,\n            o,\n            s,\n            h = Konva.Path;\n\n        switch (i) {\n          case \"L\":\n            return h.getLineLength(t, e, n[0], n[1]);\n\n          case \"C\":\n            for (a = 0, r = h.getPointOnCubicBezier(0, t, e, n[0], n[1], n[2], n[3], n[4], n[5]), s = .01; s <= 1; s += .01) o = h.getPointOnCubicBezier(s, t, e, n[0], n[1], n[2], n[3], n[4], n[5]), a += h.getLineLength(r.x, r.y, o.x, o.y), r = o;\n\n            return a;\n\n          case \"Q\":\n            for (a = 0, r = h.getPointOnQuadraticBezier(0, t, e, n[0], n[1], n[2], n[3]), s = .01; s <= 1; s += .01) o = h.getPointOnQuadraticBezier(s, t, e, n[0], n[1], n[2], n[3]), a += h.getLineLength(r.x, r.y, o.x, o.y), r = o;\n\n            return a;\n\n          case \"A\":\n            a = 0;\n            var l = n[4],\n                c = n[5],\n                d = n[4] + c,\n                u = Math.PI / 180;\n            if (Math.abs(l - d) < u && (u = Math.abs(l - d)), r = h.getPointOnEllipticalArc(n[0], n[1], n[2], n[3], l, 0), c < 0) for (s = l - u; s > d; s -= u) o = h.getPointOnEllipticalArc(n[0], n[1], n[2], n[3], s, 0), a += h.getLineLength(r.x, r.y, o.x, o.y), r = o;else for (s = l + u; s < d; s += u) o = h.getPointOnEllipticalArc(n[0], n[1], n[2], n[3], s, 0), a += h.getLineLength(r.x, r.y, o.x, o.y), r = o;\n            return o = h.getPointOnEllipticalArc(n[0], n[1], n[2], n[3], d, 0), a + h.getLineLength(r.x, r.y, o.x, o.y);\n        }\n\n        return 0;\n      }, Konva.Path.convertEndpointToCenterParameterization = function (t, e, i, n, a, r, o, s, h) {\n        var l = h * (Math.PI / 180),\n            c = Math.cos(l) * (t - i) / 2 + Math.sin(l) * (e - n) / 2,\n            d = -1 * Math.sin(l) * (t - i) / 2 + Math.cos(l) * (e - n) / 2,\n            u = c * c / (o * o) + d * d / (s * s);\n        u > 1 && (o *= Math.sqrt(u), s *= Math.sqrt(u));\n        var f = Math.sqrt((o * o * (s * s) - o * o * (d * d) - s * s * (c * c)) / (o * o * (d * d) + s * s * (c * c)));\n        a === r && (f *= -1), isNaN(f) && (f = 0);\n\n        var g = f * o * d / s,\n            v = f * -s * c / o,\n            p = (t + i) / 2 + Math.cos(l) * g - Math.sin(l) * v,\n            m = (e + n) / 2 + Math.sin(l) * g + Math.cos(l) * v,\n            y = function (t) {\n          return Math.sqrt(t[0] * t[0] + t[1] * t[1]);\n        },\n            _ = function (t, e) {\n          return (t[0] * e[0] + t[1] * e[1]) / (y(t) * y(e));\n        },\n            b = function (t, e) {\n          return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(_(t, e));\n        },\n            C = b([1, 0], [(c - g) / o, (d - v) / s]),\n            S = [(c - g) / o, (d - v) / s],\n            w = [(-1 * c - g) / o, (-1 * d - v) / s],\n            x = b(S, w);\n\n        return _(S, w) <= -1 && (x = Math.PI), _(S, w) >= 1 && (x = 0), 0 === r && x > 0 && (x -= 2 * Math.PI), 1 === r && x < 0 && (x += 2 * Math.PI), [p, m, o, s, C, x, l, r];\n      }, Konva.Factory.addGetterSetter(Konva.Path, \"data\"), Konva.Collection.mapMethods(Konva.Path);\n    }();\n  }, function (t, e) {\n    !function () {\n      \"use strict\";\n\n      Konva.Rect = function (t) {\n        this.___init(t);\n      }, Konva.Rect.prototype = {\n        ___init: function (t) {\n          Konva.Shape.call(this, t), this.className = \"Rect\", this.sceneFunc(this._sceneFunc);\n        },\n        _sceneFunc: function (t) {\n          var e = this.getCornerRadius(),\n              i = this.getWidth(),\n              n = this.getHeight();\n          t.beginPath(), e ? (e = Math.min(e, i / 2, n / 2), t.moveTo(e, 0), t.lineTo(i - e, 0), t.arc(i - e, e, e, 3 * Math.PI / 2, 0, !1), t.lineTo(i, n - e), t.arc(i - e, n - e, e, 0, Math.PI / 2, !1), t.lineTo(e, n), t.arc(e, n - e, e, Math.PI / 2, Math.PI, !1), t.lineTo(0, e), t.arc(e, e, e, Math.PI, 3 * Math.PI / 2, !1)) : t.rect(0, 0, i, n), t.closePath(), t.fillStrokeShape(this);\n        }\n      }, Konva.Util.extend(Konva.Rect, Konva.Shape), Konva.Factory.addGetterSetter(Konva.Rect, \"cornerRadius\", 0, Konva.Validators.getNumberValidator()), Konva.Collection.mapMethods(Konva.Rect);\n    }();\n  }, function (t, e) {\n    !function (t) {\n      \"use strict\";\n\n      var e = 2 * Math.PI - 1e-4;\n      t.Circle = function (t) {\n        this.___init(t);\n      }, t.Circle.prototype = {\n        _centroid: !0,\n        ___init: function (e) {\n          t.Shape.call(this, e), this.className = \"Circle\", this.sceneFunc(this._sceneFunc);\n        },\n        _sceneFunc: function (t) {\n          t.beginPath(), t.arc(0, 0, this.getRadius(), 0, e, !1), t.closePath(), t.fillStrokeShape(this);\n        },\n        getWidth: function () {\n          return 2 * this.getRadius();\n        },\n        getHeight: function () {\n          return 2 * this.getRadius();\n        },\n        setWidth: function (e) {\n          t.Node.prototype.setWidth.call(this, e), this.radius() !== e / 2 && this.setRadius(e / 2);\n        },\n        setHeight: function (e) {\n          t.Node.prototype.setHeight.call(this, e), this.radius() !== e / 2 && this.setRadius(e / 2);\n        }\n      }, t.Util.extend(t.Circle, t.Shape), t.Factory.addGetterSetter(t.Circle, \"radius\", 0, t.Validators.getNumberValidator()), t.Factory.addOverloadedGetterSetter(t.Circle, \"radius\"), t.Collection.mapMethods(t.Circle);\n    }(Konva);\n  }, function (t, e) {\n    !function () {\n      \"use strict\";\n\n      Konva.Image = function (t) {\n        this.___init(t);\n      }, Konva.Image.prototype = {\n        ___init: function (t) {\n          Konva.Shape.call(this, t), this.className = \"Image\", this.sceneFunc(this._sceneFunc), this.hitFunc(this._hitFunc);\n        },\n        _useBufferCanvas: function () {\n          return (this.hasShadow() || 1 !== this.getAbsoluteOpacity()) && this.hasStroke() && this.getStage();\n        },\n        _sceneFunc: function (t) {\n          var e,\n              i,\n              n,\n              a = this.getWidth(),\n              r = this.getHeight(),\n              o = this.getImage();\n          o && (e = this.getCropWidth(), i = this.getCropHeight(), n = e && i ? [o, this.getCropX(), this.getCropY(), e, i, 0, 0, a, r] : [o, 0, 0, a, r]), (this.hasFill() || this.hasStroke()) && (t.beginPath(), t.rect(0, 0, a, r), t.closePath(), t.fillStrokeShape(this)), o && t.drawImage.apply(t, n);\n        },\n        _hitFunc: function (t) {\n          var e = this.getWidth(),\n              i = this.getHeight();\n          t.beginPath(), t.rect(0, 0, e, i), t.closePath(), t.fillStrokeShape(this);\n        },\n        getWidth: function () {\n          var t = this.getImage();\n          return this.attrs.width || (t ? t.width : 0);\n        },\n        getHeight: function () {\n          var t = this.getImage();\n          return this.attrs.height || (t ? t.height : 0);\n        }\n      }, Konva.Util.extend(Konva.Image, Konva.Shape), Konva.Factory.addGetterSetter(Konva.Image, \"image\"), Konva.Factory.addComponentsGetterSetter(Konva.Image, \"crop\", [\"x\", \"y\", \"width\", \"height\"]), Konva.Factory.addGetterSetter(Konva.Image, \"cropX\", 0, Konva.Validators.getNumberValidator()), Konva.Factory.addGetterSetter(Konva.Image, \"cropY\", 0, Konva.Validators.getNumberValidator()), Konva.Factory.addGetterSetter(Konva.Image, \"cropWidth\", 0, Konva.Validators.getNumberValidator()), Konva.Factory.addGetterSetter(Konva.Image, \"cropHeight\", 0, Konva.Validators.getNumberValidator()), Konva.Collection.mapMethods(Konva.Image), Konva.Image.fromURL = function (t, e) {\n        var i = new Image();\n        i.onload = function () {\n          var t = new Konva.Image({\n            image: i\n          });\n          e(t);\n        }, i.crossOrigin = \"Anonymous\", i.src = t;\n      };\n    }();\n  }, function (t, e) {\n    !function () {\n      \"use strict\";\n\n      Konva.Group = function (t) {\n        this.___init(t);\n      }, Konva.Util.addMethods(Konva.Group, {\n        ___init: function (t) {\n          this.nodeType = \"Group\", Konva.Container.call(this, t);\n        },\n        _validateAdd: function (t) {\n          var e = t.getType();\n          \"Group\" !== e && \"Shape\" !== e && Konva.Util.throw(\"You may only add groups and shapes to groups.\");\n        }\n      }), Konva.Util.extend(Konva.Group, Konva.Container), Konva.Collection.mapMethods(Konva.Group);\n    }();\n  }, function (t, e) {\n    !function () {\n      \"use strict\";\n\n      Konva.FastLayer = function (t) {\n        this.____init(t);\n      }, Konva.Util.addMethods(Konva.FastLayer, {\n        ____init: function (t) {\n          this.nodeType = \"Layer\", this.canvas = new Konva.SceneCanvas(), Konva.BaseLayer.call(this, t);\n        },\n        _validateAdd: function (t) {\n          \"Shape\" !== t.getType() && Konva.Util.throw(\"You may only add shapes to a fast layer.\");\n        },\n        _setCanvasSize: function (t, e) {\n          this.canvas.setSize(t, e);\n        },\n        hitGraphEnabled: function () {\n          return !1;\n        },\n        getIntersection: function () {\n          return null;\n        },\n        drawScene: function (t) {\n          var e = this.getLayer(),\n              i = t || e && e.getCanvas();\n          return this.getClearBeforeDraw() && i.getContext().clear(), Konva.Container.prototype.drawScene.call(this, i), this;\n        },\n        draw: function () {\n          return this.drawScene(), this;\n        },\n        setVisible: function (t) {\n          return Konva.Node.prototype.setVisible.call(this, t), this.getCanvas()._canvas.style.display = t ? \"block\" : \"none\", this;\n        }\n      }), Konva.Util.extend(Konva.FastLayer, Konva.BaseLayer), Konva.Collection.mapMethods(Konva.FastLayer);\n    }();\n  }, function (t, e) {\n    !function () {\n      \"use strict\";\n\n      var t = [{\n        x: 0,\n        y: 0\n      }, {\n        x: -1,\n        y: -1\n      }, {\n        x: 1,\n        y: -1\n      }, {\n        x: 1,\n        y: 1\n      }, {\n        x: -1,\n        y: 1\n      }],\n          e = t.length;\n      Konva.Layer = function (t) {\n        this.____init(t);\n      }, Konva.Util.addMethods(Konva.Layer, {\n        ____init: function (t) {\n          this.nodeType = \"Layer\", this.canvas = new Konva.SceneCanvas(), this.hitCanvas = new Konva.HitCanvas({\n            pixelRatio: 1\n          }), Konva.BaseLayer.call(this, t);\n        },\n        _setCanvasSize: function (t, e) {\n          this.canvas.setSize(t, e), this.hitCanvas.setSize(t, e);\n        },\n        _validateAdd: function (t) {\n          var e = t.getType();\n          \"Group\" !== e && \"Shape\" !== e && Konva.Util.throw(\"You may only add groups and shapes to a layer.\");\n        },\n        getIntersection: function (i, n) {\n          var a, r, o, s;\n          if (!this.hitGraphEnabled() || !this.isVisible()) return null;\n\n          for (var h = 1, l = !1;;) {\n            for (r = 0; r < e; r++) {\n              if (o = t[r], (s = (a = this._getIntersection({\n                x: i.x + o.x * h,\n                y: i.y + o.y * h\n              })).shape) && n) return s.findAncestor(n, !0);\n              if (s) return s;\n              if (l = !!a.antialiased, !a.antialiased) break;\n            }\n\n            if (!l) return null;\n            h += 1;\n          }\n        },\n        _getImageData: function (t, e) {\n          var i = this.hitCanvas.width || 1,\n              n = this.hitCanvas.height || 1,\n              a = Math.round(e) * i + Math.round(t);\n          return this._hitImageData || (this._hitImageData = this.hitCanvas.context.getImageData(0, 0, i, n)), [this._hitImageData.data[4 * a + 0], this._hitImageData.data[4 * a + 1], this._hitImageData.data[4 * a + 2], this._hitImageData.data[4 * a + 3]];\n        },\n        _getIntersection: function (t) {\n          var e,\n              i,\n              n = this.hitCanvas.pixelRatio,\n              a = this.hitCanvas.context.getImageData(Math.round(t.x * n), Math.round(t.y * n), 1, 1).data,\n              r = a[3];\n          return 255 === r ? (e = Konva.Util._rgbToHex(a[0], a[1], a[2]), (i = Konva.shapes[\"#\" + e]) ? {\n            shape: i\n          } : {\n            antialiased: !0\n          }) : r > 0 ? {\n            antialiased: !0\n          } : {};\n        },\n        drawScene: function (t, e) {\n          var i = this.getLayer(),\n              n = t || i && i.getCanvas();\n          return this._fire(\"beforeDraw\", {\n            node: this\n          }), this.getClearBeforeDraw() && n.getContext().clear(), Konva.Container.prototype.drawScene.call(this, n, e), this._fire(\"draw\", {\n            node: this\n          }), this;\n        },\n        drawHit: function (t, e) {\n          var i = this.getLayer(),\n              n = t || i && i.hitCanvas;\n          return i && i.getClearBeforeDraw() && i.getHitCanvas().getContext().clear(), Konva.Container.prototype.drawHit.call(this, n, e), this.imageData = null, this;\n        },\n        clear: function (t) {\n          return Konva.BaseLayer.prototype.clear.call(this, t), this.getHitCanvas().getContext().clear(t), this.imageData = null, this;\n        },\n        setVisible: function (t) {\n          return Konva.Node.prototype.setVisible.call(this, t), t ? (this.getCanvas()._canvas.style.display = \"block\", this.hitCanvas._canvas.style.display = \"block\") : (this.getCanvas()._canvas.style.display = \"none\", this.hitCanvas._canvas.style.display = \"none\"), this;\n        },\n        enableHitGraph: function () {\n          return this.setHitGraphEnabled(!0), this;\n        },\n        disableHitGraph: function () {\n          return this.setHitGraphEnabled(!1), this;\n        },\n        setSize: function (t, e) {\n          return Konva.BaseLayer.prototype.setSize.call(this, t, e), this.hitCanvas.setSize(t, e), this;\n        }\n      }), Konva.Util.extend(Konva.Layer, Konva.BaseLayer), Konva.Factory.addGetterSetter(Konva.Layer, \"hitGraphEnabled\", !0), Konva.Collection.mapMethods(Konva.Layer);\n    }();\n  }, function (t, e) {\n    !function (t) {\n      \"use strict\";\n\n      t.BaseLayer = function (t) {\n        this.___init(t);\n      }, t.Util.addMethods(t.BaseLayer, {\n        ___init: function (e) {\n          this.nodeType = \"Layer\", t.Container.call(this, e);\n        },\n        createPNGStream: function () {\n          return this.canvas._canvas.createPNGStream();\n        },\n        getCanvas: function () {\n          return this.canvas;\n        },\n        getHitCanvas: function () {\n          return this.hitCanvas;\n        },\n        getContext: function () {\n          return this.getCanvas().getContext();\n        },\n        clear: function (t) {\n          return this.getContext().clear(t), this;\n        },\n        clearHitCache: function () {\n          this._hitImageData = void 0;\n        },\n        setZIndex: function (e) {\n          t.Node.prototype.setZIndex.call(this, e);\n          var i = this.getStage();\n          return i && (i.content.removeChild(this.getCanvas()._canvas), e < i.getChildren().length - 1 ? i.content.insertBefore(this.getCanvas()._canvas, i.getChildren()[e + 1].getCanvas()._canvas) : i.content.appendChild(this.getCanvas()._canvas)), this;\n        },\n        moveToTop: function () {\n          t.Node.prototype.moveToTop.call(this);\n          var e = this.getStage();\n          return e && (e.content.removeChild(this.getCanvas()._canvas), e.content.appendChild(this.getCanvas()._canvas)), this;\n        },\n        moveUp: function () {\n          if (!t.Node.prototype.moveUp.call(this)) return this;\n          var e = this.getStage();\n          return e ? (e.content.removeChild(this.getCanvas()._canvas), this.index < e.getChildren().length - 1 ? e.content.insertBefore(this.getCanvas()._canvas, e.getChildren()[this.index + 1].getCanvas()._canvas) : e.content.appendChild(this.getCanvas()._canvas), this) : this;\n        },\n        moveDown: function () {\n          if (t.Node.prototype.moveDown.call(this)) {\n            var e = this.getStage();\n\n            if (e) {\n              var i = e.getChildren();\n              e.content.removeChild(this.getCanvas()._canvas), e.content.insertBefore(this.getCanvas()._canvas, i[this.index + 1].getCanvas()._canvas);\n            }\n          }\n\n          return this;\n        },\n        moveToBottom: function () {\n          if (t.Node.prototype.moveToBottom.call(this)) {\n            var e = this.getStage();\n\n            if (e) {\n              var i = e.getChildren();\n              e.content.removeChild(this.getCanvas()._canvas), e.content.insertBefore(this.getCanvas()._canvas, i[1].getCanvas()._canvas);\n            }\n          }\n\n          return this;\n        },\n        getLayer: function () {\n          return this;\n        },\n        remove: function () {\n          var e = this.getCanvas()._canvas;\n\n          return t.Node.prototype.remove.call(this), e && e.parentNode && t.Util._isInDocument(e) && e.parentNode.removeChild(e), this;\n        },\n        getStage: function () {\n          return this.parent;\n        },\n        setSize: function (t, e) {\n          return this.canvas.setSize(t, e), this;\n        },\n        _toKonvaCanvas: function (e) {\n          return (e = e || {}).width = e.width || this.getWidth(), e.height = e.height || this.getHeight(), e.x = void 0 !== e.x ? e.x : this.getX(), e.y = void 0 !== e.y ? e.y : this.getY(), t.Node.prototype._toKonvaCanvas.call(this, e);\n        },\n        getWidth: function () {\n          if (this.parent) return this.parent.getWidth();\n        },\n        setWidth: function () {\n          t.Util.warn('Can not change width of layer. Use \"stage.width(value)\" function instead.');\n        },\n        getHeight: function () {\n          if (this.parent) return this.parent.getHeight();\n        },\n        setHeight: function () {\n          t.Util.warn('Can not change height of layer. Use \"stage.height(value)\" function instead.');\n        },\n        _applyTransform: function (t, e, i) {\n          var n = t.getAbsoluteTransform(i).getMatrix();\n          e.transform(n[0], n[1], n[2], n[3], n[4], n[5]);\n        }\n      }), t.Util.extend(t.BaseLayer, t.Container), t.Factory.addGetterSetter(t.BaseLayer, \"clearBeforeDraw\", !0), t.Collection.mapMethods(t.BaseLayer);\n    }(Konva);\n  }, function (t, e) {\n    !function () {\n      \"use strict\";\n\n      var t = \"_\",\n          e = [\"mousedown\", \"mousemove\", \"mouseup\", \"mouseout\", \"touchstart\", \"touchmove\", \"touchend\", \"mouseover\", \"wheel\", \"contextmenu\"],\n          i = e.length;\n\n      function n(e, i) {\n        e.content.addEventListener(i, function (n) {\n          e[t + i](n);\n        }, !1);\n      }\n\n      Konva.Stage = function (t) {\n        this.___init(t);\n      }, Konva.Util.addMethods(Konva.Stage, {\n        ___init: function (t) {\n          this.nodeType = \"Stage\", Konva.Container.call(this, t), this._id = Konva.idCounter++, this._buildDOM(), this._bindContentEvents(), this._enableNestedTransforms = !1, Konva.stages.push(this);\n        },\n        _validateAdd: function (t) {\n          \"Layer\" !== t.getType() && Konva.Util.throw(\"You may only add layers to the stage.\");\n        },\n        setContainer: function (t) {\n          if (\"string\" == typeof t) {\n            if (\".\" === t.charAt(0)) {\n              var e = t.slice(1);\n              t = Konva.document.getElementsByClassName(e)[0];\n            } else {\n              var i;\n              i = \"#\" !== t.charAt(0) ? t : t.slice(1), t = Konva.document.getElementById(i);\n            }\n\n            if (!t) throw \"Can not find container in document with id \" + i;\n          }\n\n          return this._setAttr(\"container\", t), this;\n        },\n        shouldDrawHit: function () {\n          return !0;\n        },\n        draw: function () {\n          return Konva.Node.prototype.draw.call(this), this;\n        },\n        setHeight: function (t) {\n          return Konva.Node.prototype.setHeight.call(this, t), this._resizeDOM(), this;\n        },\n        setWidth: function (t) {\n          return Konva.Node.prototype.setWidth.call(this, t), this._resizeDOM(), this;\n        },\n        clear: function () {\n          var t,\n              e = this.children,\n              i = e.length;\n\n          for (t = 0; t < i; t++) e[t].clear();\n\n          return this;\n        },\n        clone: function (t) {\n          return t || (t = {}), t.container = Konva.document.createElement(\"div\"), Konva.Container.prototype.clone.call(this, t);\n        },\n        destroy: function () {\n          var t = this.content;\n          Konva.Container.prototype.destroy.call(this), t && Konva.Util._isInDocument(t) && this.getContainer().removeChild(t);\n          var e = Konva.stages.indexOf(this);\n          return e > -1 && Konva.stages.splice(e, 1), this;\n        },\n        getPointerPosition: function () {\n          return this.pointerPos;\n        },\n        getStage: function () {\n          return this;\n        },\n        getContent: function () {\n          return this.content;\n        },\n        _toKonvaCanvas: function (t) {\n          var e = (t = t || {}).x || 0,\n              i = t.y || 0,\n              n = new Konva.SceneCanvas({\n            width: t.width || this.getWidth(),\n            height: t.height || this.getHeight(),\n            pixelRatio: t.pixelRatio || 1\n          }),\n              a = n.getContext()._context,\n              r = this.children;\n\n          return (e || i) && a.translate(-1 * e, -1 * i), r.each(function (n) {\n            if (n.isVisible()) {\n              var r = n._toKonvaCanvas(t);\n\n              a.drawImage(r._canvas, e, i, r.getWidth() / r.getPixelRatio(), r.getHeight() / r.getPixelRatio());\n            }\n          }), n;\n        },\n        toImage: function (t) {\n          var e = t.callback;\n          t.callback = function (t) {\n            Konva.Util._getImage(t, function (t) {\n              e(t);\n            });\n          }, this.toDataURL(t);\n        },\n        getIntersection: function (t, e) {\n          var i,\n              n,\n              a = this.getChildren();\n\n          for (i = a.length - 1; i >= 0; i--) if (n = a[i].getIntersection(t, e)) return n;\n\n          return null;\n        },\n        _resizeDOM: function () {\n          if (this.content) {\n            var t,\n                e,\n                i = this.getWidth(),\n                n = this.getHeight(),\n                a = this.getChildren(),\n                r = a.length;\n\n            for (this.content.style.width = i + \"px\", this.content.style.height = n + \"px\", this.bufferCanvas.setSize(i, n), this.bufferHitCanvas.setSize(i, n), t = 0; t < r; t++) (e = a[t]).setSize(i, n), e.draw();\n          }\n        },\n        add: function (t) {\n          if (arguments.length > 1) {\n            for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);\n\n            return this;\n          }\n\n          return Konva.Container.prototype.add.call(this, t), t._setCanvasSize(this.width(), this.height()), t.draw(), Konva.isBrowser && this.content.appendChild(t.canvas._canvas), this;\n        },\n        getParent: function () {\n          return null;\n        },\n        getLayer: function () {\n          return null;\n        },\n        getLayers: function () {\n          return this.getChildren();\n        },\n        _bindContentEvents: function () {\n          if (Konva.isBrowser) for (var t = 0; t < i; t++) n(this, e[t]);\n        },\n        _mouseover: function (t) {\n          Konva.UA.mobile || (this._setPointerPosition(t), this._fire(\"contentMouseover\", {\n            evt: t\n          }));\n        },\n        _mouseout: function (t) {\n          if (!Konva.UA.mobile) {\n            this._setPointerPosition(t);\n\n            var e = this.targetShape;\n            e && !Konva.isDragging() && (e._fireAndBubble(\"mouseout\", {\n              evt: t\n            }), e._fireAndBubble(\"mouseleave\", {\n              evt: t\n            }), this.targetShape = null), this.pointerPos = void 0, this._fire(\"contentMouseout\", {\n              evt: t\n            });\n          }\n        },\n        _mousemove: function (t) {\n          return Konva.UA.ieMobile ? this._touchmove(t) : void 0 === t.movementX && void 0 === t.movementY || 0 !== t.movementY || 0 !== t.movementX ? Konva.UA.mobile ? null : (this._setPointerPosition(t), Konva.isDragging() || ((e = this.getIntersection(this.getPointerPosition())) && e.isListening() ? Konva.isDragging() || this.targetShape && this.targetShape._id === e._id ? e._fireAndBubble(\"mousemove\", {\n            evt: t\n          }) : (this.targetShape && (this.targetShape._fireAndBubble(\"mouseout\", {\n            evt: t\n          }, e), this.targetShape._fireAndBubble(\"mouseleave\", {\n            evt: t\n          }, e)), e._fireAndBubble(\"mouseover\", {\n            evt: t\n          }, this.targetShape), e._fireAndBubble(\"mouseenter\", {\n            evt: t\n          }, this.targetShape), this.targetShape = e) : (this.targetShape && !Konva.isDragging() && (this.targetShape._fireAndBubble(\"mouseout\", {\n            evt: t\n          }), this.targetShape._fireAndBubble(\"mouseleave\", {\n            evt: t\n          }), this.targetShape = null), this._fire(\"mousemove\", {\n            evt: t,\n            target: this,\n            currentTarget: this\n          })), this._fire(\"contentMousemove\", {\n            evt: t\n          })), void (t.cancelable && t.preventDefault())) : null;\n          var e;\n        },\n        _mousedown: function (t) {\n          if (Konva.UA.ieMobile) return this._touchstart(t);\n\n          if (!Konva.UA.mobile) {\n            this._setPointerPosition(t);\n\n            var e = this.getIntersection(this.getPointerPosition());\n            Konva.listenClickTap = !0, e && e.isListening() ? (this.clickStartShape = e, e._fireAndBubble(\"mousedown\", {\n              evt: t\n            })) : this._fire(\"mousedown\", {\n              evt: t,\n              target: this,\n              currentTarget: this\n            }), this._fire(\"contentMousedown\", {\n              evt: t\n            });\n          }\n        },\n        _mouseup: function (t) {\n          if (Konva.UA.ieMobile) return this._touchend(t);\n\n          if (!Konva.UA.mobile) {\n            this._setPointerPosition(t);\n\n            var e = this.getIntersection(this.getPointerPosition()),\n                i = this.clickStartShape,\n                n = this.clickEndShape,\n                a = !1,\n                r = Konva.DD;\n            Konva.inDblClickWindow ? (a = !0, clearTimeout(this.dblTimeout)) : r && r.justDragged ? r && (r.justDragged = !1) : (Konva.inDblClickWindow = !0, clearTimeout(this.dblTimeout)), this.dblTimeout = setTimeout(function () {\n              Konva.inDblClickWindow = !1;\n            }, Konva.dblClickWindow), e && e.isListening() ? (this.clickEndShape = e, e._fireAndBubble(\"mouseup\", {\n              evt: t\n            }), Konva.listenClickTap && i && i._id === e._id && (e._fireAndBubble(\"click\", {\n              evt: t\n            }), a && n && n._id === e._id && e._fireAndBubble(\"dblclick\", {\n              evt: t\n            }))) : (this._fire(\"mouseup\", {\n              evt: t,\n              target: this,\n              currentTarget: this\n            }), Konva.listenClickTap && this._fire(\"click\", {\n              evt: t,\n              target: this,\n              currentTarget: this\n            }), a && this._fire(\"dblclick\", {\n              evt: t,\n              target: this,\n              currentTarget: this\n            })), this._fire(\"contentMouseup\", {\n              evt: t\n            }), Konva.listenClickTap && (this._fire(\"contentClick\", {\n              evt: t\n            }), a && this._fire(\"contentDblclick\", {\n              evt: t\n            })), Konva.listenClickTap = !1;\n          }\n\n          t.cancelable && t.preventDefault();\n        },\n        _contextmenu: function (t) {\n          this._setPointerPosition(t);\n\n          var e = this.getIntersection(this.getPointerPosition());\n          e && e.isListening() ? e._fireAndBubble(\"contextmenu\", {\n            evt: t\n          }) : this._fire(\"contextmenu\", {\n            evt: t,\n            target: this,\n            currentTarget: this\n          }), this._fire(\"contentContextmenu\", {\n            evt: t\n          });\n        },\n        _touchstart: function (t) {\n          this._setPointerPosition(t);\n\n          var e = this.getIntersection(this.getPointerPosition());\n          Konva.listenClickTap = !0, e && e.isListening() ? (this.tapStartShape = e, e._fireAndBubble(\"touchstart\", {\n            evt: t\n          }), e.isListening() && e.preventDefault() && t.cancelable && t.preventDefault()) : this._fire(\"touchstart\", {\n            evt: t,\n            target: this,\n            currentTarget: this\n          }), this._fire(\"contentTouchstart\", {\n            evt: t\n          });\n        },\n        _touchend: function (t) {\n          this._setPointerPosition(t);\n\n          var e = this.getIntersection(this.getPointerPosition()),\n              i = !1;\n          Konva.inDblClickWindow ? (i = !0, clearTimeout(this.dblTimeout)) : (Konva.inDblClickWindow = !0, clearTimeout(this.dblTimeout)), this.dblTimeout = setTimeout(function () {\n            Konva.inDblClickWindow = !1;\n          }, Konva.dblClickWindow), e && e.isListening() ? (e._fireAndBubble(\"touchend\", {\n            evt: t\n          }), Konva.listenClickTap && this.tapStartShape && e._id === this.tapStartShape._id && (e._fireAndBubble(\"tap\", {\n            evt: t\n          }), i && e._fireAndBubble(\"dbltap\", {\n            evt: t\n          })), e.isListening() && e.preventDefault() && t.cancelable && t.preventDefault()) : (this._fire(\"touchend\", {\n            evt: t,\n            target: this,\n            currentTarget: this\n          }), Konva.listenClickTap && this._fire(\"tap\", {\n            evt: t,\n            target: this,\n            currentTarget: this\n          }), i && this._fire(\"dbltap\", {\n            evt: t,\n            target: this,\n            currentTarget: this\n          })), this._fire(\"contentTouchend\", {\n            evt: t\n          }), Konva.listenClickTap && (this._fire(\"contentTap\", {\n            evt: t\n          }), i && this._fire(\"contentDbltap\", {\n            evt: t\n          })), Konva.listenClickTap = !1;\n        },\n        _touchmove: function (t) {\n          this._setPointerPosition(t);\n\n          var e,\n              i = Konva.DD;\n          Konva.isDragging() || ((e = this.getIntersection(this.getPointerPosition())) && e.isListening() ? (e._fireAndBubble(\"touchmove\", {\n            evt: t\n          }), e.isListening() && e.preventDefault() && t.cancelable && t.preventDefault()) : this._fire(\"touchmove\", {\n            evt: t,\n            target: this,\n            currentTarget: this\n          }), this._fire(\"contentTouchmove\", {\n            evt: t\n          })), i && Konva.isDragging() && Konva.DD.node.preventDefault() && t.cancelable && t.preventDefault();\n        },\n        _wheel: function (t) {\n          this._setPointerPosition(t);\n\n          var e = this.getIntersection(this.getPointerPosition());\n          e && e.isListening() ? e._fireAndBubble(\"wheel\", {\n            evt: t\n          }) : this._fire(\"wheel\", {\n            evt: t,\n            target: this,\n            currentTarget: this\n          }), this._fire(\"contentWheel\", {\n            evt: t\n          });\n        },\n        _setPointerPosition: function (t) {\n          var e = this._getContentPosition(),\n              i = null,\n              n = null;\n\n          if (void 0 !== (t = t || window.event).touches) {\n            if (t.touches.length > 0) {\n              var a = t.touches[0];\n              i = a.clientX - e.left, n = a.clientY - e.top;\n            }\n          } else i = t.clientX - e.left, n = t.clientY - e.top;\n\n          null !== i && null !== n && (this.pointerPos = {\n            x: i,\n            y: n\n          });\n        },\n        _getContentPosition: function () {\n          var t = this.content.getBoundingClientRect ? this.content.getBoundingClientRect() : {\n            top: 0,\n            left: 0\n          };\n          return {\n            top: t.top,\n            left: t.left\n          };\n        },\n        _buildDOM: function () {\n          if (this.bufferCanvas = new Konva.SceneCanvas(), this.bufferHitCanvas = new Konva.HitCanvas({\n            pixelRatio: 1\n          }), Konva.isBrowser) {\n            var t = this.getContainer();\n            if (!t) throw \"Stage has no container. A container is required.\";\n            t.innerHTML = \"\", this.content = Konva.document.createElement(\"div\"), this.content.style.position = \"relative\", this.content.style.userSelect = \"none\", this.content.className = \"konvajs-content\", this.content.setAttribute(\"role\", \"presentation\"), t.appendChild(this.content), this._resizeDOM();\n          }\n        },\n        _onContent: function (t, e) {\n          var i,\n              n,\n              a = t.split(\" \"),\n              r = a.length;\n\n          for (i = 0; i < r; i++) n = a[i], this.content.addEventListener(n, e, !1);\n        },\n        cache: function () {\n          Konva.Util.warn(\"Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.\");\n        },\n        clearCache: function () {}\n      }), Konva.Util.extend(Konva.Stage, Konva.Container), Konva.Factory.addGetter(Konva.Stage, \"container\"), Konva.Factory.addOverloadedGetterSetter(Konva.Stage, \"container\");\n    }();\n  }, function (t, e) {\n    !function (t) {\n      \"use strict\";\n\n      var e = \"hasShadow\",\n          i = \"shadowRGBA\";\n\n      function n(t) {\n        t.fill();\n      }\n\n      function a(t) {\n        t.stroke();\n      }\n\n      function r(t) {\n        t.fill();\n      }\n\n      function o(t) {\n        t.stroke();\n      }\n\n      function s() {\n        this._clearCache(e);\n      }\n\n      function h() {\n        this._clearCache(i);\n      }\n\n      t.Shape = function (t) {\n        this.__init(t);\n      }, t.Util.addMethods(t.Shape, {\n        __init: function (e) {\n          this.nodeType = \"Shape\", this._fillFunc = n, this._strokeFunc = a, this._fillFuncHit = r, this._strokeFuncHit = o;\n\n          for (var i, l = t.shapes; !(i = t.Util.getRandomColor()) || i in l;);\n\n          this.colorKey = i, l[i] = this, t.Node.call(this, e), this.on(\"shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva\", s), this.on(\"shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva\", h);\n        },\n        hasChildren: function () {\n          return !1;\n        },\n        getChildren: function () {\n          return [];\n        },\n        getContext: function () {\n          return this.getLayer().getContext();\n        },\n        getCanvas: function () {\n          return this.getLayer().getCanvas();\n        },\n        hasShadow: function () {\n          return this._getCache(e, this._hasShadow);\n        },\n        _hasShadow: function () {\n          return this.getShadowEnabled() && 0 !== this.getShadowOpacity() && !!(this.getShadowColor() || this.getShadowBlur() || this.getShadowOffsetX() || this.getShadowOffsetY());\n        },\n        getShadowRGBA: function () {\n          return this._getCache(i, this._getShadowRGBA);\n        },\n        _getShadowRGBA: function () {\n          if (this.hasShadow()) {\n            var e = t.Util.colorToRGBA(this.shadowColor());\n            return \"rgba(\" + e.r + \",\" + e.g + \",\" + e.b + \",\" + e.a * (this.getShadowOpacity() || 1) + \")\";\n          }\n        },\n        hasFill: function () {\n          return !!(this.getFill() || this.getFillPatternImage() || this.getFillLinearGradientColorStops() || this.getFillRadialGradientColorStops());\n        },\n        hasStroke: function () {\n          return this.strokeEnabled() && !(!this.stroke() && !this.getStrokeLinearGradientColorStops());\n        },\n        intersects: function (t) {\n          var e = this.getStage().bufferHitCanvas;\n          return e.getContext().clear(), this.drawHit(e), e.context.getImageData(Math.round(t.x), Math.round(t.y), 1, 1).data[3] > 0;\n        },\n        destroy: function () {\n          return t.Node.prototype.destroy.call(this), delete t.shapes[this.colorKey], this;\n        },\n        _useBufferCanvas: function (t) {\n          return !t && this.perfectDrawEnabled() && 1 !== this.getAbsoluteOpacity() && this.hasFill() && this.hasStroke() && this.getStage() || this.perfectDrawEnabled() && this.hasShadow() && 1 !== this.getAbsoluteOpacity() && this.hasFill() && this.hasStroke() && this.getStage();\n        },\n        getSelfRect: function () {\n          var t = this.getSize();\n          return {\n            x: this._centroid ? Math.round(-t.width / 2) : 0,\n            y: this._centroid ? Math.round(-t.height / 2) : 0,\n            width: t.width,\n            height: t.height\n          };\n        },\n        getClientRect: function (t) {\n          var e = (t = t || {}).skipTransform,\n              i = t.relativeTo,\n              n = this.getSelfRect(),\n              a = this.hasStroke() && this.strokeWidth() || 0,\n              r = n.width + a,\n              o = n.height + a,\n              s = !t.skipShadow && this.hasShadow(),\n              h = s ? this.shadowOffsetX() : 0,\n              l = s ? this.shadowOffsetY() : 0,\n              c = r + Math.abs(h),\n              d = o + Math.abs(l),\n              u = s && this.shadowBlur() || 0,\n              f = c + 2 * u,\n              g = d + 2 * u,\n              v = 0;\n          Math.round(a / 2) !== a / 2 && (v = 1);\n          var p = {\n            width: f + v,\n            height: g + v,\n            x: -Math.round(a / 2 + u) + Math.min(h, 0) + n.x,\n            y: -Math.round(a / 2 + u) + Math.min(l, 0) + n.y\n          };\n          return e ? p : this._transformedRect(p, i);\n        },\n        drawScene: function (t, e, i, n) {\n          var a,\n              r,\n              o = this.getLayer(),\n              s = t || o.getCanvas(),\n              h = s.getContext(),\n              l = this._cache.canvas,\n              c = this.sceneFunc(),\n              d = this.hasShadow(),\n              u = this.hasStroke();\n          if (!this.isVisible() && !i) return this;\n          if (l) return h.save(), o._applyTransform(this, h, e), this._drawCachedSceneCanvas(h), h.restore(), this;\n          if (!c) return this;\n\n          if (h.save(), this._useBufferCanvas(i) && !n) {\n            if ((r = (a = this.getStage().bufferCanvas).getContext()).clear(), r.save(), r._applyLineJoin(this), !i) if (o) o._applyTransform(this, r, e);else {\n              var f = this.getAbsoluteTransform(e).getMatrix();\n              h.transform(f[0], f[1], f[2], f[3], f[4], f[5]);\n            }\n            c.call(this, r, this), r.restore();\n            var g = a.pixelRatio;\n            d && !s.hitCanvas ? (h.save(), h._applyShadow(this), h._applyOpacity(this), h._applyGlobalCompositeOperation(this), h.drawImage(a._canvas, 0, 0, a.width / g, a.height / g), h.restore()) : (h._applyOpacity(this), h._applyGlobalCompositeOperation(this), h.drawImage(a._canvas, 0, 0, a.width / g, a.height / g));\n          } else {\n            if (h._applyLineJoin(this), !i) if (o) o._applyTransform(this, h, e);else {\n              var v = this.getAbsoluteTransform(e).getMatrix();\n              h.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n            }\n            d && u && !s.hitCanvas ? (h.save(), i || (h._applyOpacity(this), h._applyGlobalCompositeOperation(this)), h._applyShadow(this), c.call(this, h, this), h.restore(), this.hasFill() && this.getShadowForStrokeEnabled() && c.call(this, h, this)) : d && !s.hitCanvas ? (h.save(), i || (h._applyOpacity(this), h._applyGlobalCompositeOperation(this)), h._applyShadow(this), c.call(this, h, this), h.restore()) : (i || (h._applyOpacity(this), h._applyGlobalCompositeOperation(this)), c.call(this, h, this));\n          }\n\n          return h.restore(), this;\n        },\n        drawHit: function (t, e, i) {\n          var n = this.getLayer(),\n              a = t || n.hitCanvas,\n              r = a.getContext(),\n              o = this.hitFunc() || this.sceneFunc(),\n              s = this._cache.canvas,\n              h = s && s.hit;\n          if (!this.shouldDrawHit(a) && !i) return this;\n          if (n && n.clearHitCache(), h) return r.save(), n._applyTransform(this, r, e), this._drawCachedHitCanvas(r), r.restore(), this;\n          if (!o) return this;\n          if (r.save(), r._applyLineJoin(this), !i) if (n) n._applyTransform(this, r, e);else {\n            var l = this.getAbsoluteTransform(e).getMatrix();\n            r.transform(l[0], l[1], l[2], l[3], l[4], l[5]);\n          }\n          return o.call(this, r, this), r.restore(), this;\n        },\n        drawHitFromCache: function (e) {\n          var i,\n              n,\n              a,\n              r,\n              o,\n              s = e || 0,\n              h = this._cache.canvas,\n              l = this._getCachedSceneCanvas(),\n              c = h.hit,\n              d = c.getContext(),\n              u = c.getWidth(),\n              f = c.getHeight();\n\n          d.clear(), d.drawImage(l._canvas, 0, 0, u, f);\n\n          try {\n            for (a = (n = (i = d.getImageData(0, 0, u, f)).data).length, r = t.Util._hexToRgb(this.colorKey), o = 0; o < a; o += 4) n[o + 3] > s ? (n[o] = r.r, n[o + 1] = r.g, n[o + 2] = r.b, n[o + 3] = 255) : n[o + 3] = 0;\n\n            d.putImageData(i, 0, 0);\n          } catch (e) {\n            t.Util.error(\"Unable to draw hit graph from cached scene canvas. \" + e.message);\n          }\n\n          return this;\n        }\n      }), t.Util.extend(t.Shape, t.Node), t.Factory.addGetterSetter(t.Shape, \"stroke\", void 0, t.Validators.getStringValidator()), t.Factory.addGetterSetter(t.Shape, \"strokeWidth\", 2, t.Validators.getNumberValidator()), t.Factory.addGetterSetter(t.Shape, \"strokeHitEnabled\", !0, t.Validators.getBooleanValidator()), t.Factory.addGetterSetter(t.Shape, \"perfectDrawEnabled\", !0, t.Validators.getBooleanValidator()), t.Factory.addGetterSetter(t.Shape, \"shadowForStrokeEnabled\", !0, t.Validators.getBooleanValidator()), t.Factory.addGetterSetter(t.Shape, \"lineJoin\"), t.Factory.addGetterSetter(t.Shape, \"lineCap\"), t.Factory.addGetterSetter(t.Shape, \"sceneFunc\"), t.Factory.addGetterSetter(t.Shape, \"hitFunc\"), t.Factory.addGetterSetter(t.Shape, \"dash\"), t.Factory.addGetterSetter(t.Shape, \"dashOffset\", 0, t.Validators.getNumberValidator()), t.Factory.addGetterSetter(t.Shape, \"shadowColor\", void 0, t.Validators.getStringValidator()), t.Factory.addGetterSetter(t.Shape, \"shadowBlur\", 0, t.Validators.getNumberValidator()), t.Factory.addGetterSetter(t.Shape, \"shadowOpacity\", 1, t.Validators.getNumberValidator()), t.Factory.addComponentsGetterSetter(t.Shape, \"shadowOffset\", [\"x\", \"y\"]), t.Factory.addGetterSetter(t.Shape, \"shadowOffsetX\", 0, t.Validators.getNumberValidator()), t.Factory.addGetterSetter(t.Shape, \"shadowOffsetY\", 0, t.Validators.getNumberValidator()), t.Factory.addGetterSetter(t.Shape, \"fillPatternImage\"), t.Factory.addGetterSetter(t.Shape, \"fill\", void 0, t.Validators.getStringValidator()), t.Factory.addGetterSetter(t.Shape, \"fillPatternX\", 0, t.Validators.getNumberValidator()), t.Factory.addGetterSetter(t.Shape, \"fillPatternY\", 0, t.Validators.getNumberValidator()), t.Factory.addGetterSetter(t.Shape, \"fillLinearGradientColorStops\"), t.Factory.addGetterSetter(t.Shape, \"strokeLinearGradientColorStops\"), t.Factory.addGetterSetter(t.Shape, \"fillRadialGradientStartRadius\", 0), t.Factory.addGetterSetter(t.Shape, \"fillRadialGradientEndRadius\", 0), t.Factory.addGetterSetter(t.Shape, \"fillRadialGradientColorStops\"), t.Factory.addGetterSetter(t.Shape, \"fillPatternRepeat\", \"repeat\"), t.Factory.addGetterSetter(t.Shape, \"fillEnabled\", !0), t.Factory.addGetterSetter(t.Shape, \"strokeEnabled\", !0), t.Factory.addGetterSetter(t.Shape, \"shadowEnabled\", !0), t.Factory.addGetterSetter(t.Shape, \"dashEnabled\", !0), t.Factory.addGetterSetter(t.Shape, \"strokeScaleEnabled\", !0), t.Factory.addGetterSetter(t.Shape, \"fillPriority\", \"color\"), t.Factory.addComponentsGetterSetter(t.Shape, \"fillPatternOffset\", [\"x\", \"y\"]), t.Factory.addGetterSetter(t.Shape, \"fillPatternOffsetX\", 0, t.Validators.getNumberValidator()), t.Factory.addGetterSetter(t.Shape, \"fillPatternOffsetY\", 0, t.Validators.getNumberValidator()), t.Factory.addComponentsGetterSetter(t.Shape, \"fillPatternScale\", [\"x\", \"y\"]), t.Factory.addGetterSetter(t.Shape, \"fillPatternScaleX\", 1, t.Validators.getNumberValidator()), t.Factory.addGetterSetter(t.Shape, \"fillPatternScaleY\", 1, t.Validators.getNumberValidator()), t.Factory.addComponentsGetterSetter(t.Shape, \"fillLinearGradientStartPoint\", [\"x\", \"y\"]), t.Factory.addComponentsGetterSetter(t.Shape, \"strokeLinearGradientStartPoint\", [\"x\", \"y\"]), t.Factory.addGetterSetter(t.Shape, \"fillLinearGradientStartPointX\", 0), t.Factory.addGetterSetter(t.Shape, \"strokeLinearGradientStartPointX\", 0), t.Factory.addGetterSetter(t.Shape, \"fillLinearGradientStartPointY\", 0), t.Factory.addGetterSetter(t.Shape, \"strokeLinearGradientStartPointY\", 0), t.Factory.addComponentsGetterSetter(t.Shape, \"fillLinearGradientEndPoint\", [\"x\", \"y\"]), t.Factory.addComponentsGetterSetter(t.Shape, \"strokeLinearGradientEndPoint\", [\"x\", \"y\"]), t.Factory.addGetterSetter(t.Shape, \"fillLinearGradientEndPointX\", 0), t.Factory.addGetterSetter(t.Shape, \"strokeLinearGradientEndPointX\", 0), t.Factory.addGetterSetter(t.Shape, \"fillLinearGradientEndPointY\", 0), t.Factory.addGetterSetter(t.Shape, \"strokeLinearGradientEndPointY\", 0), t.Factory.addComponentsGetterSetter(t.Shape, \"fillRadialGradientStartPoint\", [\"x\", \"y\"]), t.Factory.addGetterSetter(t.Shape, \"fillRadialGradientStartPointX\", 0), t.Factory.addGetterSetter(t.Shape, \"fillRadialGradientStartPointY\", 0), t.Factory.addComponentsGetterSetter(t.Shape, \"fillRadialGradientEndPoint\", [\"x\", \"y\"]), t.Factory.addGetterSetter(t.Shape, \"fillRadialGradientEndPointX\", 0), t.Factory.addGetterSetter(t.Shape, \"fillRadialGradientEndPointY\", 0), t.Factory.addGetterSetter(t.Shape, \"fillPatternRotation\", 0), t.Factory.backCompat(t.Shape, {\n        dashArray: \"dash\",\n        getDashArray: \"getDash\",\n        setDashArray: \"getDash\",\n        drawFunc: \"sceneFunc\",\n        getDrawFunc: \"getSceneFunc\",\n        setDrawFunc: \"setSceneFunc\",\n        drawHitFunc: \"hitFunc\",\n        getDrawHitFunc: \"getHitFunc\",\n        setDrawHitFunc: \"setHitFunc\"\n      }), t.Collection.mapMethods(t.Shape);\n    }(Konva);\n  }, function (t, e) {\n    !function () {\n      \"use strict\";\n\n      Konva.Container = function (t) {\n        this.__init(t);\n      }, Konva.Util.addMethods(Konva.Container, {\n        __init: function (t) {\n          this.children = new Konva.Collection(), Konva.Node.call(this, t);\n        },\n        getChildren: function (t) {\n          if (!t) return this.children;\n          var e = new Konva.Collection();\n          return this.children.each(function (i) {\n            t(i) && e.push(i);\n          }), e;\n        },\n        hasChildren: function () {\n          return this.getChildren().length > 0;\n        },\n        removeChildren: function () {\n          for (var t, e = Konva.Collection.toCollection(this.children), i = 0; i < e.length; i++) delete (t = e[i]).parent, t.index = 0, t.remove();\n\n          return e = null, this.children = new Konva.Collection(), this;\n        },\n        destroyChildren: function () {\n          for (var t, e = Konva.Collection.toCollection(this.children), i = 0; i < e.length; i++) delete (t = e[i]).parent, t.index = 0, t.destroy();\n\n          return e = null, this.children = new Konva.Collection(), this;\n        },\n        add: function (t) {\n          if (arguments.length > 1) {\n            for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);\n\n            return this;\n          }\n\n          if (t.getParent()) return t.moveTo(this), this;\n          var i = this.children;\n          return this._validateAdd(t), t.index = i.length, t.parent = this, i.push(t), this._fire(\"add\", {\n            child: t\n          }), Konva.DD && t.isDragging() && Konva.DD.anim.setLayers(t.getLayer()), this;\n        },\n        destroy: function () {\n          return this.hasChildren() && this.destroyChildren(), Konva.Node.prototype.destroy.call(this), this;\n        },\n        find: function (t) {\n          return this._generalFind(t, !1);\n        },\n        findOne: function (t) {\n          var e = this._generalFind(t, !0);\n\n          return e.length > 0 ? e[0] : void 0;\n        },\n        _generalFind: function (t, e) {\n          var i = [];\n          return \"string\" == typeof t ? i = this._findByString(t, e) : \"function\" == typeof t && (i = this._findByFunction(t, e)), Konva.Collection.toCollection(i);\n        },\n        _findByString: function (t) {\n          var e,\n              i,\n              n,\n              a,\n              r,\n              o,\n              s,\n              h = [],\n              l = t.replace(/ /g, \"\").split(\",\"),\n              c = l.length;\n\n          for (e = 0; e < c; e++) {\n            if (n = l[e], !Konva.Util.isValidSelector(n)) {\n              var d = 'Selector \"' + n + '\" is invalid. Allowed selectors examples are \"#foo\", \".bar\" or \"Group\".\\nIf you have a custom shape with such className, please change it to start with upper letter like \"Triangle\".\\nKonva is awesome, right?';\n              Konva.Util.warn(d);\n            }\n\n            if (\"#\" === n.charAt(0)) (r = this._getNodeById(n.slice(1))) && h.push(r);else if (\".\" === n.charAt(0)) a = this._getNodesByName(n.slice(1)), h = h.concat(a);else for (s = (o = this.getChildren()).length, i = 0; i < s; i++) h = h.concat(o[i]._get(n));\n          }\n\n          return h;\n        },\n        _findByFunction: function (t, e) {\n          var i = [],\n              n = function (a) {\n            if (!(e && i.length > 0)) {\n              var r = a.getChildren(),\n                  o = r.length;\n              t(a) && (i = i.concat(a));\n\n              for (var s = 0; s < o; s++) n(r[s]);\n            }\n          };\n\n          return n(this), i;\n        },\n        _getNodeById: function (t) {\n          var e = Konva.ids[t];\n          return void 0 !== e && this.isAncestorOf(e) ? e : null;\n        },\n        _getNodesByName: function (t) {\n          var e = Konva.names[t] || [];\n          return this._getDescendants(e);\n        },\n        _get: function (t) {\n          for (var e = Konva.Node.prototype._get.call(this, t), i = this.getChildren(), n = i.length, a = 0; a < n; a++) e = e.concat(i[a]._get(t));\n\n          return e;\n        },\n        toObject: function () {\n          var t = Konva.Node.prototype.toObject.call(this);\n          t.children = [];\n\n          for (var e = this.getChildren(), i = e.length, n = 0; n < i; n++) {\n            var a = e[n];\n            t.children.push(a.toObject());\n          }\n\n          return t;\n        },\n        _getDescendants: function (t) {\n          for (var e = [], i = t.length, n = 0; n < i; n++) {\n            var a = t[n];\n            this.isAncestorOf(a) && e.push(a);\n          }\n\n          return e;\n        },\n        isAncestorOf: function (t) {\n          for (var e = t.getParent(); e;) {\n            if (e._id === this._id) return !0;\n            e = e.getParent();\n          }\n\n          return !1;\n        },\n        clone: function (t) {\n          var e = Konva.Node.prototype.clone.call(this, t);\n          return this.getChildren().each(function (t) {\n            e.add(t.clone());\n          }), e;\n        },\n        getAllIntersections: function (t) {\n          var e = [];\n          return this.find(\"Shape\").each(function (i) {\n            i.isVisible() && i.intersects(t) && e.push(i);\n          }), e;\n        },\n        _setChildrenIndices: function () {\n          this.children.each(function (t, e) {\n            t.index = e;\n          });\n        },\n        drawScene: function (t, e, i) {\n          var n = this.getLayer(),\n              a = t || n && n.getCanvas(),\n              r = a && a.getContext(),\n              o = this._cache.canvas,\n              s = o && o.scene;\n          return (this.isVisible() || i) && (!i && s ? (r.save(), n._applyTransform(this, r, e), this._drawCachedSceneCanvas(r), r.restore()) : this._drawChildren(a, \"drawScene\", e, !1, i)), this;\n        },\n        drawHit: function (t, e, i) {\n          var n = this.getLayer(),\n              a = t || n && n.hitCanvas,\n              r = a && a.getContext(),\n              o = this._cache.canvas,\n              s = o && o.hit;\n          return (this.shouldDrawHit(a) || i) && (n && n.clearHitCache(), !i && s ? (r.save(), n._applyTransform(this, r, e), this._drawCachedHitCanvas(r), r.restore()) : this._drawChildren(a, \"drawHit\", e)), this;\n        },\n        _drawChildren: function (t, e, i, n, a) {\n          var r,\n              o,\n              s = this.getLayer(),\n              h = t && t.getContext(),\n              l = this.getClipWidth(),\n              c = this.getClipHeight(),\n              d = this.getClipFunc(),\n              u = l && c || d;\n\n          if (u && s) {\n            h.save();\n            var f = this.getAbsoluteTransform(i),\n                g = f.getMatrix();\n            h.transform(g[0], g[1], g[2], g[3], g[4], g[5]), h.beginPath(), d ? d.call(this, h, this) : (r = this.getClipX(), o = this.getClipY(), h.rect(r, o, l, c)), h.clip(), g = f.copy().invert().getMatrix(), h.transform(g[0], g[1], g[2], g[3], g[4], g[5]);\n          }\n\n          this.children.each(function (r) {\n            r[e](t, i, n, a);\n          }), u && h.restore();\n        },\n        shouldDrawHit: function (t) {\n          var e = this.getLayer(),\n              i = Konva.DD && Konva.isDragging() && -1 !== Konva.DD.anim.getLayers().indexOf(e);\n          return t && t.isCache || e && e.hitGraphEnabled() && this.isVisible() && !i;\n        },\n        getClientRect: function (t) {\n          var e,\n              i,\n              n,\n              a,\n              r,\n              o = (t = t || {}).skipTransform,\n              s = t.relativeTo,\n              h = this;\n          this.children.each(function (r) {\n            if (r.getVisible()) {\n              var o = r.getClientRect({\n                relativeTo: h,\n                skipShadow: t.skipShadow\n              });\n              0 === o.width && 0 === o.height || (void 0 === e ? (e = o.x, i = o.y, n = o.x + o.width, a = o.y + o.height) : (e = Math.min(e, o.x), i = Math.min(i, o.y), n = Math.max(n, o.x + o.width), a = Math.max(a, o.y + o.height)));\n            }\n          });\n\n          for (var l = this.find(\"Shape\"), c = !1, d = 0; d < l.length; d++) if (l[d]._isVisible(this)) {\n            c = !0;\n            break;\n          }\n\n          return r = c ? {\n            x: e,\n            y: i,\n            width: n - e,\n            height: a - i\n          } : {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n          }, o ? r : this._transformedRect(r, s);\n        }\n      }), Konva.Util.extend(Konva.Container, Konva.Node), Konva.Container.prototype.get = Konva.Container.prototype.find, Konva.Factory.addComponentsGetterSetter(Konva.Container, \"clip\", [\"x\", \"y\", \"width\", \"height\"]), Konva.Factory.addGetterSetter(Konva.Container, \"clipX\", void 0, Konva.Validators.getNumberValidator()), Konva.Factory.addGetterSetter(Konva.Container, \"clipY\", void 0, Konva.Validators.getNumberValidator()), Konva.Factory.addGetterSetter(Konva.Container, \"clipWidth\", void 0, Konva.Validators.getNumberValidator()), Konva.Factory.addGetterSetter(Konva.Container, \"clipHeight\", void 0, Konva.Validators.getNumberValidator()), Konva.Factory.addGetterSetter(Konva.Container, \"clipFunc\"), Konva.Collection.mapMethods(Konva.Container);\n    }();\n  }, function (t, e) {\n    !function (t) {\n      \"use strict\";\n\n      var e = \"Shape\",\n          i = [\"id\"],\n          n = [\"xChange.konva\", \"yChange.konva\", \"scaleXChange.konva\", \"scaleYChange.konva\", \"skewXChange.konva\", \"skewYChange.konva\", \"rotationChange.konva\", \"offsetXChange.konva\", \"offsetYChange.konva\", \"transformsEnabledChange.konva\"].join(\" \"),\n          a = [\"scaleXChange.konva\", \"scaleYChange.konva\"].join(\" \");\n      t.Node = function (t) {\n        this._init(t);\n      }, t.Util.addMethods(t.Node, {\n        _init: function (e) {\n          this._id = t.idCounter++, this.eventListeners = {}, this.attrs = {}, this._cache = {}, this._filterUpToDate = !1, this._isUnderCache = !1, this.setAttrs(e), this.on(n, function () {\n            this._clearCache(\"transform\"), this._clearSelfAndDescendantCache(\"absoluteTransform\");\n          }), this.on(a, function () {\n            this._clearSelfAndDescendantCache(\"absoluteScale\");\n          }), this.on(\"visibleChange.konva\", function () {\n            this._clearSelfAndDescendantCache(\"visible\");\n          }), this.on(\"listeningChange.konva\", function () {\n            this._clearSelfAndDescendantCache(\"listening\");\n          }), this.on(\"opacityChange.konva\", function () {\n            this._clearSelfAndDescendantCache(\"absoluteOpacity\");\n          });\n        },\n        _clearCache: function (t) {\n          t ? delete this._cache[t] : this._cache = {};\n        },\n        _getCache: function (t, e) {\n          return void 0 === this._cache[t] && (this._cache[t] = e.call(this)), this._cache[t];\n        },\n        _clearSelfAndDescendantCache: function (t) {\n          this._clearCache(t), this.children && this.getChildren().each(function (e) {\n            e._clearSelfAndDescendantCache(t);\n          });\n        },\n        clearCache: function () {\n          return delete this._cache.canvas, this._filterUpToDate = !1, this;\n        },\n        cache: function (e) {\n          var i = e || {},\n              n = {};\n          void 0 !== i.x && void 0 !== i.y && void 0 !== i.width && void 0 !== i.height || (n = this.getClientRect({\n            skipTransform: !0,\n            relativeTo: this.getParent()\n          }));\n          var a = i.width || n.width,\n              r = i.height || n.height,\n              o = i.pixelRatio,\n              s = void 0 === i.x ? n.x : i.x,\n              h = void 0 === i.y ? n.y : i.y,\n              l = i.offset || 0,\n              c = i.drawBorder || !1;\n\n          if (a && r) {\n            a += 2 * l, r += 2 * l, s -= l, h -= l;\n            var d = new t.SceneCanvas({\n              pixelRatio: o,\n              width: a,\n              height: r\n            }),\n                u = new t.SceneCanvas({\n              pixelRatio: o,\n              width: a,\n              height: r\n            }),\n                f = new t.HitCanvas({\n              pixelRatio: 1,\n              width: a,\n              height: r\n            }),\n                g = d.getContext(),\n                v = f.getContext();\n            return f.isCache = !0, this.clearCache(), g.save(), v.save(), g.translate(-s, -h), v.translate(-s, -h), this._isUnderCache = !0, this._clearSelfAndDescendantCache(\"absoluteOpacity\"), this._clearSelfAndDescendantCache(\"absoluteScale\"), this.drawScene(d, this, !0), this.drawHit(f, this, !0), this._isUnderCache = !1, g.restore(), v.restore(), c && (g.save(), g.beginPath(), g.rect(0, 0, a, r), g.closePath(), g.setAttr(\"strokeStyle\", \"red\"), g.setAttr(\"lineWidth\", 5), g.stroke(), g.restore()), this._cache.canvas = {\n              scene: d,\n              filter: u,\n              hit: f,\n              x: s,\n              y: h\n            }, this;\n          }\n\n          t.Util.error(\"Can not cache the node. Width or height of the node equals 0. Caching is skipped.\");\n        },\n        getClientRect: function () {\n          throw new Error('abstract \"getClientRect\" method call');\n        },\n        _transformedRect: function (t, e) {\n          var i,\n              n,\n              a,\n              r,\n              o = [{\n            x: t.x,\n            y: t.y\n          }, {\n            x: t.x + t.width,\n            y: t.y\n          }, {\n            x: t.x + t.width,\n            y: t.y + t.height\n          }, {\n            x: t.x,\n            y: t.y + t.height\n          }],\n              s = this.getAbsoluteTransform(e);\n          return o.forEach(function (t) {\n            var e = s.point(t);\n            void 0 === i && (i = a = e.x, n = r = e.y), i = Math.min(i, e.x), n = Math.min(n, e.y), a = Math.max(a, e.x), r = Math.max(r, e.y);\n          }), {\n            x: i,\n            y: n,\n            width: a - i,\n            height: r - n\n          };\n        },\n        _drawCachedSceneCanvas: function (t) {\n          t.save(), t._applyOpacity(this), t._applyGlobalCompositeOperation(this), t.translate(this._cache.canvas.x, this._cache.canvas.y);\n\n          var e = this._getCachedSceneCanvas(),\n              i = e.pixelRatio;\n\n          t.drawImage(e._canvas, 0, 0, e.width / i, e.height / i), t.restore();\n        },\n        _drawCachedHitCanvas: function (t) {\n          var e = this._cache.canvas.hit;\n          t.save(), t.translate(this._cache.canvas.x, this._cache.canvas.y), t.drawImage(e._canvas, 0, 0), t.restore();\n        },\n        _getCachedSceneCanvas: function () {\n          var e,\n              i,\n              n,\n              a,\n              r = this.filters(),\n              o = this._cache.canvas,\n              s = o.scene,\n              h = o.filter,\n              l = h.getContext();\n\n          if (r) {\n            if (!this._filterUpToDate) {\n              var c = s.pixelRatio;\n\n              try {\n                for (e = r.length, l.clear(), l.drawImage(s._canvas, 0, 0, s.getWidth() / c, s.getHeight() / c), i = l.getImageData(0, 0, h.getWidth(), h.getHeight()), n = 0; n < e; n++) \"function\" == typeof (a = r[n]) ? (a.call(this, i), l.putImageData(i, 0, 0)) : t.Util.error(\"Filter should be type of function, but got \" + typeof a + \" insted. Please check correct filters\");\n              } catch (e) {\n                t.Util.error(\"Unable to apply filter. \" + e.message);\n              }\n\n              this._filterUpToDate = !0;\n            }\n\n            return h;\n          }\n\n          return s;\n        },\n        on: function (t, e) {\n          if (3 === arguments.length) return this._delegate.apply(this, arguments);\n          var i,\n              n,\n              a,\n              r,\n              o = t.split(\" \"),\n              s = o.length;\n\n          for (i = 0; i < s; i++) a = (n = o[i].split(\".\"))[0], r = n[1] || \"\", this.eventListeners[a] || (this.eventListeners[a] = []), this.eventListeners[a].push({\n            name: r,\n            handler: e\n          });\n\n          return this;\n        },\n        off: function (t, e) {\n          var i,\n              n,\n              a,\n              r,\n              o,\n              s = (t || \"\").split(\" \"),\n              h = s.length;\n          if (!t) for (n in this.eventListeners) this._off(n);\n\n          for (i = 0; i < h; i++) if (r = (a = s[i].split(\".\"))[0], o = a[1], r) this.eventListeners[r] && this._off(r, o, e);else for (n in this.eventListeners) this._off(n, o, e);\n\n          return this;\n        },\n        dispatchEvent: function (t) {\n          var e = {\n            target: this,\n            type: t.type,\n            evt: t\n          };\n          return this.fire(t.type, e), this;\n        },\n        addEventListener: function (t, e) {\n          return this.on(t, function (t) {\n            e.call(this, t.evt);\n          }), this;\n        },\n        removeEventListener: function (t) {\n          return this.off(t), this;\n        },\n        _delegate: function (e, i, n) {\n          var a = this;\n          this.on(e, function (e) {\n            for (var r = e.target.findAncestors(i, !0, a), o = 0; o < r.length; o++) (e = t.Util.cloneObject(e)).currentTarget = r[o], n.call(r[o], e);\n          });\n        },\n        remove: function () {\n          var t = this.getParent();\n          return t && t.children && (t.children.splice(this.index, 1), t._setChildrenIndices(), delete this.parent), this._clearSelfAndDescendantCache(\"stage\"), this._clearSelfAndDescendantCache(\"absoluteTransform\"), this._clearSelfAndDescendantCache(\"visible\"), this._clearSelfAndDescendantCache(\"listening\"), this._clearSelfAndDescendantCache(\"absoluteOpacity\"), this;\n        },\n        destroy: function () {\n          t._removeId(this.getId());\n\n          for (var e = (this.getName() || \"\").split(/\\s/g), i = 0; i < e.length; i++) {\n            var n = e[i];\n\n            t._removeName(n, this._id);\n          }\n\n          return this.remove(), this;\n        },\n        getAttr: function (e) {\n          var i = \"get\" + t.Util._capitalize(e);\n\n          return t.Util._isFunction(this[i]) ? this[i]() : this.attrs[e];\n        },\n        getAncestors: function () {\n          for (var e = this.getParent(), i = new t.Collection(); e;) i.push(e), e = e.getParent();\n\n          return i;\n        },\n        getAttrs: function () {\n          return this.attrs || {};\n        },\n        setAttrs: function (e) {\n          var i, n;\n          if (!e) return this;\n\n          for (i in e) \"children\" !== i && (n = \"set\" + t.Util._capitalize(i), t.Util._isFunction(this[n]) ? this[n](e[i]) : this._setAttr(i, e[i]));\n\n          return this;\n        },\n        isListening: function () {\n          return this._getCache(\"listening\", this._isListening);\n        },\n        _isListening: function () {\n          var t = this.getListening(),\n              e = this.getParent();\n          return \"inherit\" === t ? !e || e.isListening() : t;\n        },\n        isVisible: function () {\n          return this._getCache(\"visible\", this._isVisible);\n        },\n        _isVisible: function (t) {\n          var e = this.getVisible(),\n              i = this.getParent();\n          return t === i && \"inherit\" === e || (t === i ? e : \"inherit\" === e ? !i || i._isVisible(t) : e);\n        },\n        shouldDrawHit: function () {\n          var t = this.getLayer();\n          return !t && this.isListening() && this.isVisible() || t && t.hitGraphEnabled() && this.isListening() && this.isVisible();\n        },\n        show: function () {\n          return this.setVisible(!0), this;\n        },\n        hide: function () {\n          return this.setVisible(!1), this;\n        },\n        getZIndex: function () {\n          return this.index || 0;\n        },\n        getAbsoluteZIndex: function () {\n          var t,\n              i,\n              n,\n              a,\n              r = this.getDepth(),\n              o = this,\n              s = 0;\n          return \"Stage\" !== o.nodeType && function h(l) {\n            for (t = [], i = l.length, n = 0; n < i; n++) a = l[n], s++, a.nodeType !== e && (t = t.concat(a.getChildren().toArray())), a._id === o._id && (n = i);\n\n            t.length > 0 && t[0].getDepth() <= r && h(t);\n          }(o.getStage().getChildren()), s;\n        },\n        getDepth: function () {\n          for (var t = 0, e = this.parent; e;) t++, e = e.parent;\n\n          return t;\n        },\n        setPosition: function (t) {\n          return this.setX(t.x), this.setY(t.y), this;\n        },\n        getPosition: function () {\n          return {\n            x: this.getX(),\n            y: this.getY()\n          };\n        },\n        getAbsolutePosition: function (e) {\n          var i = this.getAbsoluteTransform(e).getMatrix(),\n              n = new t.Transform(),\n              a = this.offset();\n          return n.m = i.slice(), n.translate(a.x, a.y), n.getTranslation();\n        },\n        setAbsolutePosition: function (t) {\n          var e,\n              i = this._clearTransform();\n\n          return this.attrs.x = i.x, this.attrs.y = i.y, delete i.x, delete i.y, (e = this.getAbsoluteTransform()).invert(), e.translate(t.x, t.y), t = {\n            x: this.attrs.x + e.getTranslation().x,\n            y: this.attrs.y + e.getTranslation().y\n          }, this.setPosition({\n            x: t.x,\n            y: t.y\n          }), this._setTransform(i), this;\n        },\n        _setTransform: function (t) {\n          var e;\n\n          for (e in t) this.attrs[e] = t[e];\n\n          this._clearCache(\"transform\"), this._clearSelfAndDescendantCache(\"absoluteTransform\");\n        },\n        _clearTransform: function () {\n          var t = {\n            x: this.getX(),\n            y: this.getY(),\n            rotation: this.getRotation(),\n            scaleX: this.getScaleX(),\n            scaleY: this.getScaleY(),\n            offsetX: this.getOffsetX(),\n            offsetY: this.getOffsetY(),\n            skewX: this.getSkewX(),\n            skewY: this.getSkewY()\n          };\n          return this.attrs.x = 0, this.attrs.y = 0, this.attrs.rotation = 0, this.attrs.scaleX = 1, this.attrs.scaleY = 1, this.attrs.offsetX = 0, this.attrs.offsetY = 0, this.attrs.skewX = 0, this.attrs.skewY = 0, this._clearCache(\"transform\"), this._clearSelfAndDescendantCache(\"absoluteTransform\"), t;\n        },\n        move: function (t) {\n          var e = t.x,\n              i = t.y,\n              n = this.getX(),\n              a = this.getY();\n          return void 0 !== e && (n += e), void 0 !== i && (a += i), this.setPosition({\n            x: n,\n            y: a\n          }), this;\n        },\n        _eachAncestorReverse: function (t, e) {\n          var i,\n              n,\n              a = [],\n              r = this.getParent();\n          if (e && e._id === this._id) t(this);else {\n            for (a.unshift(this); r && (!e || r._id !== e._id);) a.unshift(r), r = r.parent;\n\n            for (i = a.length, n = 0; n < i; n++) t(a[n]);\n          }\n        },\n        rotate: function (t) {\n          return this.setRotation(this.getRotation() + t), this;\n        },\n        moveToTop: function () {\n          if (!this.parent) return t.Util.warn(\"Node has no parent. moveToTop function is ignored.\"), !1;\n          var e = this.index;\n          return this.parent.children.splice(e, 1), this.parent.children.push(this), this.parent._setChildrenIndices(), !0;\n        },\n        moveUp: function () {\n          if (!this.parent) return t.Util.warn(\"Node has no parent. moveUp function is ignored.\"), !1;\n          var e = this.index;\n          return e < this.parent.getChildren().length - 1 && (this.parent.children.splice(e, 1), this.parent.children.splice(e + 1, 0, this), this.parent._setChildrenIndices(), !0);\n        },\n        moveDown: function () {\n          if (!this.parent) return t.Util.warn(\"Node has no parent. moveDown function is ignored.\"), !1;\n          var e = this.index;\n          return e > 0 && (this.parent.children.splice(e, 1), this.parent.children.splice(e - 1, 0, this), this.parent._setChildrenIndices(), !0);\n        },\n        moveToBottom: function () {\n          if (!this.parent) return t.Util.warn(\"Node has no parent. moveToBottom function is ignored.\"), !1;\n          var e = this.index;\n          return e > 0 && (this.parent.children.splice(e, 1), this.parent.children.unshift(this), this.parent._setChildrenIndices(), !0);\n        },\n        setZIndex: function (e) {\n          if (!this.parent) return t.Util.warn(\"Node has no parent. zIndex parameter is ignored.\"), !1;\n          var i = this.index;\n          return this.parent.children.splice(i, 1), this.parent.children.splice(e, 0, this), this.parent._setChildrenIndices(), this;\n        },\n        getAbsoluteOpacity: function () {\n          return this._getCache(\"absoluteOpacity\", this._getAbsoluteOpacity);\n        },\n        _getAbsoluteOpacity: function () {\n          var t = this.getOpacity(),\n              e = this.getParent();\n          return e && !e._isUnderCache && (t *= this.getParent().getAbsoluteOpacity()), t;\n        },\n        moveTo: function (t) {\n          return this.getParent() !== t && ((this.__originalRemove || this.remove).call(this), t.add(this)), this;\n        },\n        toObject: function () {\n          var e,\n              i,\n              n,\n              a,\n              r = {},\n              o = this.getAttrs();\n\n          for (e in r.attrs = {}, o) i = o[e], n = \"function\" == typeof this[e] && this[e], delete o[e], a = n ? n.call(this) : null, o[e] = i, a !== i && (r.attrs[e] = i);\n\n          return r.className = this.getClassName(), t.Util._prepareToStringify(r);\n        },\n        toJSON: function () {\n          return JSON.stringify(this.toObject());\n        },\n        getParent: function () {\n          return this.parent;\n        },\n        findAncestors: function (t, e, i) {\n          var n = [];\n          e && this._isMatch(t) && n.push(this);\n\n          for (var a = this.parent; a;) {\n            if (a === i) return n;\n            a._isMatch(t) && n.push(a), a = a.parent;\n          }\n\n          return n;\n        },\n        findAncestor: function (t, e, i) {\n          return this.findAncestors(t, e, i)[0];\n        },\n        _isMatch: function (e) {\n          if (!e) return !1;\n          var i,\n              n,\n              a = e.replace(/ /g, \"\").split(\",\"),\n              r = a.length;\n\n          for (i = 0; i < r; i++) if (n = a[i], t.Util.isValidSelector(n) || (t.Util.warn('Selector \"' + n + '\" is invalid. Allowed selectors examples are \"#foo\", \".bar\" or \"Group\".'), t.Util.warn('If you have a custom shape with such className, please change it to start with upper letter like \"Triangle\".'), t.Util.warn(\"Konva is awesome, right?\")), \"#\" === n.charAt(0)) {\n            if (this.id() === n.slice(1)) return !0;\n          } else if (\".\" === n.charAt(0)) {\n            if (this.hasName(n.slice(1))) return !0;\n          } else if (0 !== this._get(n).length) return !0;\n\n          return !1;\n        },\n        getLayer: function () {\n          var t = this.getParent();\n          return t ? t.getLayer() : null;\n        },\n        getStage: function () {\n          return this._getCache(\"stage\", this._getStage);\n        },\n        _getStage: function () {\n          var t = this.getParent();\n          return t ? t.getStage() : void 0;\n        },\n        fire: function (t, e, i) {\n          return (e = e || {}).target = e.target || this, i ? this._fireAndBubble(t, e) : this._fire(t, e), this;\n        },\n        getAbsoluteTransform: function (t) {\n          return t ? this._getAbsoluteTransform(t) : this._getCache(\"absoluteTransform\", this._getAbsoluteTransform);\n        },\n        _getAbsoluteTransform: function (e) {\n          var i = new t.Transform();\n          return this._eachAncestorReverse(function (t) {\n            var e = t.transformsEnabled();\n            \"all\" === e ? i.multiply(t.getTransform()) : \"position\" === e && i.translate(t.getX() - t.getOffsetX(), t.getY() - t.getOffsetY());\n          }, e), i;\n        },\n        getAbsoluteScale: function (t) {\n          return t ? this._getAbsoluteScale(t) : this._getCache(\"absoluteScale\", this._getAbsoluteScale);\n        },\n        _getAbsoluteScale: function (t) {\n          for (var e = this; e;) e._isUnderCache && (t = e), e = e.getParent();\n\n          var i = 1,\n              n = 1;\n          return this._eachAncestorReverse(function (t) {\n            i *= t.scaleX(), n *= t.scaleY();\n          }, t), {\n            x: i,\n            y: n\n          };\n        },\n        getTransform: function () {\n          return this._getCache(\"transform\", this._getTransform);\n        },\n        _getTransform: function () {\n          var e = new t.Transform(),\n              i = this.getX(),\n              n = this.getY(),\n              a = t.getAngle(this.getRotation()),\n              r = this.getScaleX(),\n              o = this.getScaleY(),\n              s = this.getSkewX(),\n              h = this.getSkewY(),\n              l = this.getOffsetX(),\n              c = this.getOffsetY();\n          return 0 === i && 0 === n || e.translate(i, n), 0 !== a && e.rotate(a), 0 === s && 0 === h || e.skew(s, h), 1 === r && 1 === o || e.scale(r, o), 0 === l && 0 === c || e.translate(-1 * l, -1 * c), e;\n        },\n        clone: function (e) {\n          var n,\n              a,\n              r,\n              o,\n              s,\n              h = t.Util.cloneObject(this.attrs);\n\n          for (var l in i) delete h[i[l]];\n\n          for (n in e) h[n] = e[n];\n\n          var c = new this.constructor(h);\n\n          for (n in this.eventListeners) for (r = (a = this.eventListeners[n]).length, o = 0; o < r; o++) (s = a[o]).name.indexOf(\"konva\") < 0 && (c.eventListeners[n] || (c.eventListeners[n] = []), c.eventListeners[n].push(s));\n\n          return c;\n        },\n        _toKonvaCanvas: function (e) {\n          e = e || {};\n          var i = this.getClientRect(),\n              n = this.getStage(),\n              a = void 0 !== e.x ? e.x : i.x,\n              r = void 0 !== e.y ? e.y : i.y,\n              o = e.pixelRatio || 1,\n              s = new t.SceneCanvas({\n            width: e.width || i.width || (n ? n.getWidth() : 0),\n            height: e.height || i.height || (n ? n.getHeight() : 0),\n            pixelRatio: o\n          }),\n              h = s.getContext();\n          return h.save(), (a || r) && h.translate(-1 * a, -1 * r), this.drawScene(s), h.restore(), s;\n        },\n        toCanvas: function (t) {\n          return this._toKonvaCanvas(t)._canvas;\n        },\n        toDataURL: function (t) {\n          var e = (t = t || {}).mimeType || null,\n              i = t.quality || null,\n              n = this._toKonvaCanvas(t).toDataURL(e, i);\n\n          return t.callback && t.callback(n), n;\n        },\n        toImage: function (e) {\n          if (!e || !e.callback) throw \"callback required for toImage method config argument\";\n          var i = e.callback;\n          delete e.callback, t.Util._getImage(this.toDataURL(e), function (t) {\n            i(t);\n          });\n        },\n        setSize: function (t) {\n          return this.setWidth(t.width), this.setHeight(t.height), this;\n        },\n        getSize: function () {\n          return {\n            width: this.getWidth(),\n            height: this.getHeight()\n          };\n        },\n        getWidth: function () {\n          return this.attrs.width || 0;\n        },\n        getHeight: function () {\n          return this.attrs.height || 0;\n        },\n        getClassName: function () {\n          return this.className || this.nodeType;\n        },\n        getType: function () {\n          return this.nodeType;\n        },\n        getDragDistance: function () {\n          return void 0 !== this.attrs.dragDistance ? this.attrs.dragDistance : this.parent ? this.parent.getDragDistance() : t.dragDistance;\n        },\n        _get: function (t) {\n          return this.className === t || this.nodeType === t ? [this] : [];\n        },\n        _off: function (t, e, i) {\n          var n,\n              a,\n              r,\n              o = this.eventListeners[t];\n\n          for (n = 0; n < o.length; n++) if (a = o[n].name, r = o[n].handler, !(\"konva\" === a && \"konva\" !== e || e && a !== e || i && i !== r)) {\n            if (o.splice(n, 1), 0 === o.length) {\n              delete this.eventListeners[t];\n              break;\n            }\n\n            n--;\n          }\n        },\n        _fireChangeEvent: function (t, e, i) {\n          this._fire(t + \"Change\", {\n            oldVal: e,\n            newVal: i\n          });\n        },\n        setId: function (e) {\n          var i = this.getId();\n          return t._removeId(i), t._addId(this, e), this._setAttr(\"id\", e), this;\n        },\n        setName: function (e) {\n          var i,\n              n,\n              a = (this.getName() || \"\").split(/\\s/g),\n              r = (e || \"\").split(/\\s/g);\n\n          for (n = 0; n < a.length; n++) i = a[n], -1 === r.indexOf(i) && i && t._removeName(i, this._id);\n\n          for (n = 0; n < r.length; n++) i = r[n], -1 === a.indexOf(i) && i && t._addName(this, i);\n\n          return this._setAttr(\"name\", e), this;\n        },\n        addName: function (t) {\n          if (!this.hasName(t)) {\n            var e = this.name(),\n                i = e ? e + \" \" + t : t;\n            this.setName(i);\n          }\n\n          return this;\n        },\n        hasName: function (t) {\n          return -1 !== (this.name() || \"\").split(/\\s/g).indexOf(t);\n        },\n        removeName: function (t) {\n          var e = (this.name() || \"\").split(/\\s/g),\n              i = e.indexOf(t);\n          return -1 !== i && (e.splice(i, 1), this.setName(e.join(\" \"))), this;\n        },\n        setAttr: function (e, i) {\n          var n = this[\"set\" + t.Util._capitalize(e)];\n\n          return t.Util._isFunction(n) ? n.call(this, i) : this._setAttr(e, i), this;\n        },\n        _setAttr: function (e, i) {\n          var n;\n          (n = this.attrs[e]) === i && !t.Util.isObject(i) || (void 0 === i || null === i ? delete this.attrs[e] : this.attrs[e] = i, this._fireChangeEvent(e, n, i));\n        },\n        _setComponentAttr: function (t, e, i) {\n          var n;\n          void 0 !== i && ((n = this.attrs[t]) || (this.attrs[t] = this.getAttr(t)), this.attrs[t][e] = i, this._fireChangeEvent(t, n, i));\n        },\n        _fireAndBubble: function (t, i, n) {\n          var a = !0;\n\n          if (i && this.nodeType === e && (i.target = this), \"mouseenter\" === t && n && (this._id === n._id || this.isAncestorOf && this.isAncestorOf(n)) ? a = !1 : \"mouseleave\" === t && n && (this._id === n._id || this.isAncestorOf && this.isAncestorOf(n)) && (a = !1), a) {\n            this._fire(t, i);\n\n            var r = (\"mouseenter\" === t || \"mouseleave\" === t) && n && n.isAncestorOf && n.isAncestorOf(this) && !n.isAncestorOf(this.parent);\n            (i && !i.cancelBubble || !i) && this.parent && this.parent.isListening() && !r && (n && n.parent ? this._fireAndBubble.call(this.parent, t, i, n.parent) : this._fireAndBubble.call(this.parent, t, i));\n          }\n        },\n        _fire: function (t, e) {\n          var i,\n              n = this.eventListeners[t];\n          if ((e = e || {}).currentTarget = this, e.type = t, n) for (i = 0; i < n.length; i++) n[i].handler.call(this, e);\n        },\n        draw: function () {\n          return this.drawScene(), this.drawHit(), this;\n        }\n      }), t.Node.create = function (e, i) {\n        return t.Util._isString(e) && (e = JSON.parse(e)), this._createNode(e, i);\n      }, t.Node._createNode = function (e, i) {\n        var n,\n            a,\n            r,\n            o = t.Node.prototype.getClassName.call(e),\n            s = e.children;\n        if (i && (e.attrs.container = i), n = new t[o](e.attrs), s) for (a = s.length, r = 0; r < a; r++) n.add(this._createNode(s[r]));\n        return n;\n      }, t.Factory.addOverloadedGetterSetter(t.Node, \"position\"), t.Factory.addGetterSetter(t.Node, \"x\", 0, t.Validators.getNumberValidator()), t.Factory.addGetterSetter(t.Node, \"y\", 0, t.Validators.getNumberValidator()), t.Factory.addGetterSetter(t.Node, \"globalCompositeOperation\", \"source-over\", t.Validators.getStringValidator()), t.Factory.addGetterSetter(t.Node, \"opacity\", 1, t.Validators.getNumberValidator()), t.Factory.addGetter(t.Node, \"name\"), t.Factory.addOverloadedGetterSetter(t.Node, \"name\"), t.Factory.addGetter(t.Node, \"id\"), t.Factory.addOverloadedGetterSetter(t.Node, \"id\"), t.Factory.addGetterSetter(t.Node, \"rotation\", 0, t.Validators.getNumberValidator()), t.Factory.addComponentsGetterSetter(t.Node, \"scale\", [\"x\", \"y\"]), t.Factory.addGetterSetter(t.Node, \"scaleX\", 1, t.Validators.getNumberValidator()), t.Factory.addGetterSetter(t.Node, \"scaleY\", 1, t.Validators.getNumberValidator()), t.Factory.addComponentsGetterSetter(t.Node, \"skew\", [\"x\", \"y\"]), t.Factory.addGetterSetter(t.Node, \"skewX\", 0, t.Validators.getNumberValidator()), t.Factory.addGetterSetter(t.Node, \"skewY\", 0, t.Validators.getNumberValidator()), t.Factory.addComponentsGetterSetter(t.Node, \"offset\", [\"x\", \"y\"]), t.Factory.addGetterSetter(t.Node, \"offsetX\", 0, t.Validators.getNumberValidator()), t.Factory.addGetterSetter(t.Node, \"offsetY\", 0, t.Validators.getNumberValidator()), t.Factory.addSetter(t.Node, \"dragDistance\", t.Validators.getNumberValidator()), t.Factory.addOverloadedGetterSetter(t.Node, \"dragDistance\"), t.Factory.addSetter(t.Node, \"width\", t.Validators.getNumberValidator()), t.Factory.addOverloadedGetterSetter(t.Node, \"width\"), t.Factory.addSetter(t.Node, \"height\", t.Validators.getNumberValidator()), t.Factory.addOverloadedGetterSetter(t.Node, \"height\"), t.Factory.addGetterSetter(t.Node, \"listening\", \"inherit\", function (e) {\n        return !0 === e || !1 === e || \"inherit\" === e || t.Util.warn(e + ' is a not valid value for \"listening\" attribute. The value may be true, false or \"inherit\".'), e;\n      }), t.Factory.addGetterSetter(t.Node, \"preventDefault\", !0, t.Validators.getBooleanValidator()), t.Factory.addGetterSetter(t.Node, \"filters\", null, function (t) {\n        return this._filterUpToDate = !1, t;\n      }), t.Factory.addGetterSetter(t.Node, \"visible\", \"inherit\", function (e) {\n        return !0 === e || !1 === e || \"inherit\" === e || t.Util.warn(e + ' is a not valid value for \"visible\" attribute. The value may be true, false or \"inherit\".'), e;\n      }), t.Factory.addGetterSetter(t.Node, \"transformsEnabled\", \"all\", t.Validators.getStringValidator()), t.Factory.addOverloadedGetterSetter(t.Node, \"size\"), t.Factory.backCompat(t.Node, {\n        rotateDeg: \"rotate\",\n        setRotationDeg: \"setRotation\",\n        getRotationDeg: \"getRotation\"\n      }), t.Collection.mapMethods(t.Node);\n    }(Konva);\n  }, function (t, e) {\n    !function () {\n      \"use strict\";\n\n      Konva.Factory = {\n        addGetterSetter: function (t, e, i, n, a) {\n          this.addGetter(t, e, i), this.addSetter(t, e, n, a), this.addOverloadedGetterSetter(t, e);\n        },\n        addGetter: function (t, e, i) {\n          var n = \"get\" + Konva.Util._capitalize(e);\n\n          t.prototype[n] = function () {\n            var t = this.attrs[e];\n            return void 0 === t ? i : t;\n          };\n        },\n        addSetter: function (t, e, i, n) {\n          var a = \"set\" + Konva.Util._capitalize(e);\n\n          t.prototype[a] = function (t) {\n            return i && void 0 !== t && null !== t && (t = i.call(this, t, e)), this._setAttr(e, t), n && n.call(this), this;\n          };\n        },\n        addComponentsGetterSetter: function (t, e, i, n, a) {\n          var r,\n              o,\n              s = i.length,\n              h = Konva.Util._capitalize,\n              l = \"get\" + h(e),\n              c = \"set\" + h(e);\n          t.prototype[l] = function () {\n            var t = {};\n\n            for (r = 0; r < s; r++) t[o = i[r]] = this.getAttr(e + h(o));\n\n            return t;\n          }, t.prototype[c] = function (t) {\n            var i,\n                r = this.attrs[e];\n\n            for (i in n && (t = n.call(this, t)), t) t.hasOwnProperty(i) && this._setAttr(e + h(i), t[i]);\n\n            return this._fireChangeEvent(e, r, t), a && a.call(this), this;\n          }, this.addOverloadedGetterSetter(t, e);\n        },\n        addOverloadedGetterSetter: function (t, e) {\n          var i = Konva.Util._capitalize(e),\n              n = \"set\" + i,\n              a = \"get\" + i;\n\n          t.prototype[e] = function () {\n            return arguments.length ? (this[n](arguments[0]), this) : this[a]();\n          };\n        },\n        addDeprecatedGetterSetter: function (t, e, i, n) {\n          Konva.Util.error(\"Adding deprecated \" + e);\n\n          var a = \"get\" + Konva.Util._capitalize(e),\n              r = e + \" property is deprecated and will be removed soon. Look at Konva change log for more information.\";\n\n          t.prototype[a] = function () {\n            Konva.Util.error(r);\n            var t = this.attrs[e];\n            return void 0 === t ? i : t;\n          }, this.addSetter(t, e, n, function () {\n            Konva.Util.error(r);\n          }), this.addOverloadedGetterSetter(t, e);\n        },\n        backCompat: function (t, e) {\n          Konva.Util.each(e, function (e, i) {\n            var n = t.prototype[i],\n                a = \"get\" + Konva.Util._capitalize(e),\n                r = \"set\" + Konva.Util._capitalize(e);\n\n            function o() {\n              n.apply(this, arguments), Konva.Util.error('\"' + e + '\" method is deprecated and will be removed soon. Use \"\"' + i + '\" instead.');\n            }\n\n            t.prototype[e] = o, t.prototype[a] = o, t.prototype[r] = o;\n          });\n        },\n        afterSetFilter: function () {\n          this._filterUpToDate = !1;\n        }\n      }, Konva.Validators = {\n        RGBComponent: function (t) {\n          return t > 255 ? 255 : t < 0 ? 0 : Math.round(t);\n        },\n        alphaComponent: function (t) {\n          return t > 1 ? 1 : t < 1e-4 ? 1e-4 : t;\n        },\n        _formatValue: function (t) {\n          return Konva.Util._isString(t) ? '\"' + t + '\"' : \"[object Number]\" === Object.prototype.toString.call(t) ? t : Konva.Util._isBoolean(t) ? t : Object.prototype.toString.call(t);\n        },\n        getNumberValidator: function () {\n          if (Konva.isUnminified) return function (t, e) {\n            return Konva.Util._isNumber(t) || Konva.Util.warn(Konva.Validators._formatValue(t) + ' is a not valid value for \"' + e + '\" attribute. The value should be a number.'), t;\n          };\n        },\n        getNumberOrAutoValidator: function () {\n          if (Konva.isUnminified) return function (t, e) {\n            return Konva.Util._isNumber(t) || \"auto\" === t || Konva.Util.warn(Konva.Validators._formatValue(t) + ' is a not valid value for \"' + e + '\" attribute. The value should be a number or \"auto\".'), t;\n          };\n        },\n        getStringValidator: function () {\n          if (Konva.isUnminified) return function (t, e) {\n            return Konva.Util._isString(t) || Konva.Util.warn(Konva.Validators._formatValue(t) + ' is a not valid value for \"' + e + '\" attribute. The value should be a string.'), t;\n          };\n        },\n        getFunctionValidator: function () {\n          if (Konva.isUnminified) return function (t, e) {\n            return Konva.Util._isFunction(t) || Konva.Util.warn(Konva.Validators._formatValue(t) + ' is a not valid value for \"' + e + '\" attribute. The value should be a function.'), t;\n          };\n        },\n        getNumberArrayValidator: function () {\n          if (Konva.isUnminified) return function (t, e) {\n            return Konva.Util._isArray(t) ? t.forEach(function (t) {\n              Konva.Util._isNumber(t) || Konva.Util.warn('\"' + e + '\" attribute has non numeric element ' + t + \". Make sure that all elements are numbers.\");\n            }) : Konva.Util.warn(Konva.Validators._formatValue(t) + ' is a not valid value for \"' + e + '\" attribute. The value should be a array of numbers.'), t;\n          };\n        },\n        getBooleanValidator: function () {\n          if (Konva.isUnminified) return function (t, e) {\n            return !0 === t || !1 === t || Konva.Util.warn(Konva.Validators._formatValue(t) + ' is a not valid value for \"' + e + '\" attribute. The value should be a boolean.'), t;\n          };\n        }\n      };\n    }();\n  }, function (t, e) {\n    !function () {\n      \"use strict\";\n\n      var t = [\"arc\", \"arcTo\", \"beginPath\", \"bezierCurveTo\", \"clearRect\", \"clip\", \"closePath\", \"createLinearGradient\", \"createPattern\", \"createRadialGradient\", \"drawImage\", \"fill\", \"fillText\", \"getImageData\", \"createImageData\", \"lineTo\", \"moveTo\", \"putImageData\", \"quadraticCurveTo\", \"rect\", \"restore\", \"rotate\", \"save\", \"scale\", \"setLineDash\", \"setTransform\", \"stroke\", \"strokeText\", \"transform\", \"translate\"];\n      Konva.Context = function (t) {\n        this.init(t);\n      }, Konva.Context.prototype = {\n        init: function (t) {\n          this.canvas = t, this._context = t._canvas.getContext(\"2d\"), Konva.enableTrace && (this.traceArr = [], this._enableTrace());\n        },\n        fillShape: function (t) {\n          t.getFillEnabled() && this._fill(t);\n        },\n        strokeShape: function (t) {\n          t.getStrokeEnabled() && this._stroke(t);\n        },\n        fillStrokeShape: function (t) {\n          t.getFillEnabled() && this._fill(t), t.getStrokeEnabled() && this._stroke(t);\n        },\n        getTrace: function (t) {\n          var e,\n              i,\n              n,\n              a,\n              r = this.traceArr,\n              o = r.length,\n              s = \"\";\n\n          for (e = 0; e < o; e++) (n = (i = r[e]).method) ? (a = i.args, s += n, t ? s += \"()\" : Konva.Util._isArray(a[0]) ? s += \"([\" + a.join(\",\") + \"])\" : s += \"(\" + a.join(\",\") + \")\") : (s += i.property, t || (s += \"=\" + i.val)), s += \";\";\n\n          return s;\n        },\n        clearTrace: function () {\n          this.traceArr = [];\n        },\n        _trace: function (t) {\n          var e = this.traceArr;\n          e.push(t), e.length >= Konva.traceArrMax && e.shift();\n        },\n        reset: function () {\n          var t = this.getCanvas().getPixelRatio();\n          this.setTransform(1 * t, 0, 0, 1 * t, 0, 0);\n        },\n        getCanvas: function () {\n          return this.canvas;\n        },\n        clear: function (t) {\n          var e = this.getCanvas();\n          t ? this.clearRect(t.x || 0, t.y || 0, t.width || 0, t.height || 0) : this.clearRect(0, 0, e.getWidth() / e.pixelRatio, e.getHeight() / e.pixelRatio);\n        },\n        _applyLineCap: function (t) {\n          var e = t.getLineCap();\n          e && this.setAttr(\"lineCap\", e);\n        },\n        _applyOpacity: function (t) {\n          var e = t.getAbsoluteOpacity();\n          1 !== e && this.setAttr(\"globalAlpha\", e);\n        },\n        _applyLineJoin: function (t) {\n          var e = t.getLineJoin();\n          e && this.setAttr(\"lineJoin\", e);\n        },\n        setAttr: function (t, e) {\n          this._context[t] = e;\n        },\n        arc: function () {\n          var t = arguments;\n\n          this._context.arc(t[0], t[1], t[2], t[3], t[4], t[5]);\n        },\n        beginPath: function () {\n          this._context.beginPath();\n        },\n        bezierCurveTo: function () {\n          var t = arguments;\n\n          this._context.bezierCurveTo(t[0], t[1], t[2], t[3], t[4], t[5]);\n        },\n        clearRect: function () {\n          var t = arguments;\n\n          this._context.clearRect(t[0], t[1], t[2], t[3]);\n        },\n        clip: function () {\n          this._context.clip();\n        },\n        closePath: function () {\n          this._context.closePath();\n        },\n        createImageData: function () {\n          var t = arguments;\n          return 2 === t.length ? this._context.createImageData(t[0], t[1]) : 1 === t.length ? this._context.createImageData(t[0]) : void 0;\n        },\n        createLinearGradient: function () {\n          var t = arguments;\n          return this._context.createLinearGradient(t[0], t[1], t[2], t[3]);\n        },\n        createPattern: function () {\n          var t = arguments;\n          return this._context.createPattern(t[0], t[1]);\n        },\n        createRadialGradient: function () {\n          var t = arguments;\n          return this._context.createRadialGradient(t[0], t[1], t[2], t[3], t[4], t[5]);\n        },\n        drawImage: function () {\n          var t = arguments,\n              e = this._context;\n          3 === t.length ? e.drawImage(t[0], t[1], t[2]) : 5 === t.length ? e.drawImage(t[0], t[1], t[2], t[3], t[4]) : 9 === t.length && e.drawImage(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]);\n        },\n        isPointInPath: function (t, e) {\n          return this._context.isPointInPath(t, e);\n        },\n        fill: function () {\n          this._context.fill();\n        },\n        fillRect: function (t, e, i, n) {\n          this._context.fillRect(t, e, i, n);\n        },\n        strokeRect: function (t, e, i, n) {\n          this._context.strokeRect(t, e, i, n);\n        },\n        fillText: function () {\n          var t = arguments;\n\n          this._context.fillText(t[0], t[1], t[2]);\n        },\n        measureText: function (t) {\n          return this._context.measureText(t);\n        },\n        getImageData: function () {\n          var t = arguments;\n          return this._context.getImageData(t[0], t[1], t[2], t[3]);\n        },\n        lineTo: function () {\n          var t = arguments;\n\n          this._context.lineTo(t[0], t[1]);\n        },\n        moveTo: function () {\n          var t = arguments;\n\n          this._context.moveTo(t[0], t[1]);\n        },\n        rect: function () {\n          var t = arguments;\n\n          this._context.rect(t[0], t[1], t[2], t[3]);\n        },\n        putImageData: function () {\n          var t = arguments;\n\n          this._context.putImageData(t[0], t[1], t[2]);\n        },\n        quadraticCurveTo: function () {\n          var t = arguments;\n\n          this._context.quadraticCurveTo(t[0], t[1], t[2], t[3]);\n        },\n        restore: function () {\n          this._context.restore();\n        },\n        rotate: function () {\n          var t = arguments;\n\n          this._context.rotate(t[0]);\n        },\n        save: function () {\n          this._context.save();\n        },\n        scale: function () {\n          var t = arguments;\n\n          this._context.scale(t[0], t[1]);\n        },\n        setLineDash: function () {\n          var t = arguments,\n              e = this._context;\n          this._context.setLineDash ? e.setLineDash(t[0]) : \"mozDash\" in e ? e.mozDash = t[0] : \"webkitLineDash\" in e && (e.webkitLineDash = t[0]);\n        },\n        getLineDash: function () {\n          return this._context.getLineDash();\n        },\n        setTransform: function () {\n          var t = arguments;\n\n          this._context.setTransform(t[0], t[1], t[2], t[3], t[4], t[5]);\n        },\n        stroke: function () {\n          this._context.stroke();\n        },\n        strokeText: function () {\n          var t = arguments;\n\n          this._context.strokeText(t[0], t[1], t[2]);\n        },\n        transform: function () {\n          var t = arguments;\n\n          this._context.transform(t[0], t[1], t[2], t[3], t[4], t[5]);\n        },\n        translate: function () {\n          var t = arguments;\n\n          this._context.translate(t[0], t[1]);\n        },\n        _enableTrace: function () {\n          var e,\n              i,\n              n = this,\n              a = t.length,\n              r = Konva.Util._simplifyArray,\n              o = this.setAttr,\n              s = function (t) {\n            var e,\n                a = n[t];\n\n            n[t] = function () {\n              return i = r(Array.prototype.slice.call(arguments, 0)), e = a.apply(n, arguments), n._trace({\n                method: t,\n                args: i\n              }), e;\n            };\n          };\n\n          for (e = 0; e < a; e++) s(t[e]);\n\n          n.setAttr = function () {\n            o.apply(n, arguments);\n            var t = arguments[0],\n                e = arguments[1];\n            \"shadowOffsetX\" !== t && \"shadowOffsetY\" !== t && \"shadowBlur\" !== t || (e /= this.canvas.getPixelRatio()), n._trace({\n              property: t,\n              val: e\n            });\n          };\n        }\n      }, [\"fillStyle\", \"strokeStyle\", \"shadowColor\", \"shadowBlur\", \"shadowOffsetX\", \"shadowOffsetY\", \"lineCap\", \"lineDashOffset\", \"lineJoin\", \"lineWidth\", \"miterLimit\", \"font\", \"textAlign\", \"textBaseline\", \"globalAlpha\", \"globalCompositeOperation\"].forEach(function (t) {\n        Object.defineProperty(Konva.Context.prototype, t, {\n          get: function () {\n            return this._context[t];\n          },\n          set: function (e) {\n            this._context[t] = e;\n          }\n        });\n      }), Konva.SceneContext = function (t) {\n        Konva.Context.call(this, t);\n      }, Konva.SceneContext.prototype = {\n        _fillColor: function (t) {\n          var e = t.fill();\n          this.setAttr(\"fillStyle\", e), t._fillFunc(this);\n        },\n        _fillPattern: function (t) {\n          var e = t.getFillPatternX(),\n              i = t.getFillPatternY(),\n              n = t.getFillPatternScale(),\n              a = Konva.getAngle(t.getFillPatternRotation()),\n              r = t.getFillPatternOffset();\n          (e || i) && this.translate(e || 0, i || 0), a && this.rotate(a), n && this.scale(n.x, n.y), r && this.translate(-1 * r.x, -1 * r.y), this.setAttr(\"fillStyle\", this.createPattern(t.getFillPatternImage(), t.getFillPatternRepeat() || \"repeat\")), this.fill();\n        },\n        _fillLinearGradient: function (t) {\n          var e = t.getFillLinearGradientStartPoint(),\n              i = t.getFillLinearGradientEndPoint(),\n              n = t.getFillLinearGradientColorStops(),\n              a = this.createLinearGradient(e.x, e.y, i.x, i.y);\n\n          if (n) {\n            for (var r = 0; r < n.length; r += 2) a.addColorStop(n[r], n[r + 1]);\n\n            this.setAttr(\"fillStyle\", a), t._fillFunc(this);\n          }\n        },\n        _fillRadialGradient: function (t) {\n          for (var e = t.getFillRadialGradientStartPoint(), i = t.getFillRadialGradientEndPoint(), n = t.getFillRadialGradientStartRadius(), a = t.getFillRadialGradientEndRadius(), r = t.getFillRadialGradientColorStops(), o = this.createRadialGradient(e.x, e.y, n, i.x, i.y, a), s = 0; s < r.length; s += 2) o.addColorStop(r[s], r[s + 1]);\n\n          this.setAttr(\"fillStyle\", o), this.fill();\n        },\n        _fill: function (t) {\n          var e = t.fill(),\n              i = t.getFillPriority();\n          if (e && \"color\" === i) this._fillColor(t);else {\n            var n = t.getFillPatternImage();\n            if (n && \"pattern\" === i) this._fillPattern(t);else {\n              var a = t.getFillLinearGradientColorStops();\n              if (a && \"linear-gradient\" === i) this._fillLinearGradient(t);else {\n                var r = t.getFillRadialGradientColorStops();\n                r && \"radial-gradient\" === i ? this._fillRadialGradient(t) : e ? this._fillColor(t) : n ? this._fillPattern(t) : a ? this._fillLinearGradient(t) : r && this._fillRadialGradient(t);\n              }\n            }\n          }\n        },\n        _strokeLinearGradient: function (t) {\n          var e = t.getStrokeLinearGradientStartPoint(),\n              i = t.getStrokeLinearGradientEndPoint(),\n              n = t.getStrokeLinearGradientColorStops(),\n              a = this.createLinearGradient(e.x, e.y, i.x, i.y);\n\n          if (n) {\n            for (var r = 0; r < n.length; r += 2) a.addColorStop(n[r], n[r + 1]);\n\n            this.setAttr(\"strokeStyle\", a);\n          }\n        },\n        _stroke: function (t) {\n          var e = t.dash(),\n              i = t.getStrokeScaleEnabled() || t instanceof Konva.Text;\n          t.hasStroke() && (i || (this.save(), this.setTransform(1, 0, 0, 1, 0, 0)), this._applyLineCap(t), e && t.dashEnabled() && (this.setLineDash(e), this.setAttr(\"lineDashOffset\", t.dashOffset())), this.setAttr(\"lineWidth\", t.strokeWidth()), t.getShadowForStrokeEnabled() || this.setAttr(\"shadowColor\", \"rgba(0,0,0,0)\"), t.getStrokeLinearGradientColorStops() ? this._strokeLinearGradient(t) : this.setAttr(\"strokeStyle\", t.stroke()), t._strokeFunc(this), i || this.restore());\n        },\n        _applyShadow: function (t) {\n          var e = Konva.Util,\n              i = e.get(t.getShadowRGBA(), \"black\"),\n              n = e.get(t.getShadowBlur(), 5),\n              a = e.get(t.getShadowOffset(), {\n            x: 0,\n            y: 0\n          }),\n              r = t.getAbsoluteScale(),\n              o = this.canvas.getPixelRatio(),\n              s = r.x * o,\n              h = r.y * o;\n          this.setAttr(\"shadowColor\", i), this.setAttr(\"shadowBlur\", n * Math.min(Math.abs(s), Math.abs(h))), this.setAttr(\"shadowOffsetX\", a.x * s), this.setAttr(\"shadowOffsetY\", a.y * h);\n        },\n        _applyGlobalCompositeOperation: function (t) {\n          var e = t.getGlobalCompositeOperation();\n          \"source-over\" !== e && this.setAttr(\"globalCompositeOperation\", e);\n        }\n      }, Konva.Util.extend(Konva.SceneContext, Konva.Context), Konva.HitContext = function (t) {\n        Konva.Context.call(this, t);\n      }, Konva.HitContext.prototype = {\n        _fill: function (t) {\n          this.save(), this.setAttr(\"fillStyle\", t.colorKey), t._fillFuncHit(this), this.restore();\n        },\n        _stroke: function (t) {\n          if (t.hasStroke() && t.strokeHitEnabled()) {\n            var e = t.getStrokeScaleEnabled() || t instanceof Konva.Text;\n            e || (this.save(), this.setTransform(1, 0, 0, 1, 0, 0)), this._applyLineCap(t), this.setAttr(\"lineWidth\", t.strokeWidth()), this.setAttr(\"strokeStyle\", t.colorKey), t._strokeFuncHit(this), e || this.restore();\n          }\n        }\n      }, Konva.Util.extend(Konva.HitContext, Konva.Context);\n    }();\n  }, function (t, e) {\n    !function () {\n      \"use strict\";\n\n      var t;\n      Konva.Canvas = function (t) {\n        this.init(t);\n      }, Konva.Canvas.prototype = {\n        init: function (e) {\n          var i = (e || {}).pixelRatio || Konva.pixelRatio || function () {\n            if (t) return t;\n            var e = Konva.Util.createCanvasElement().getContext(\"2d\");\n            return t = (Konva.window.devicePixelRatio || 1) / (e.webkitBackingStorePixelRatio || e.mozBackingStorePixelRatio || e.msBackingStorePixelRatio || e.oBackingStorePixelRatio || e.backingStorePixelRatio || 1);\n          }();\n\n          this.pixelRatio = i, this._canvas = Konva.Util.createCanvasElement(), this._canvas.style.padding = 0, this._canvas.style.margin = 0, this._canvas.style.border = 0, this._canvas.style.background = \"transparent\", this._canvas.style.position = \"absolute\", this._canvas.style.top = 0, this._canvas.style.left = 0;\n        },\n        getContext: function () {\n          return this.context;\n        },\n        getPixelRatio: function () {\n          return this.pixelRatio;\n        },\n        setPixelRatio: function (t) {\n          var e = this.pixelRatio;\n          this.pixelRatio = t, this.setSize(this.getWidth() / e, this.getHeight() / e);\n        },\n        setWidth: function (t) {\n          this.width = this._canvas.width = t * this.pixelRatio, this._canvas.style.width = t + \"px\";\n          var e = this.pixelRatio;\n\n          this.getContext()._context.scale(e, e);\n        },\n        setHeight: function (t) {\n          this.height = this._canvas.height = t * this.pixelRatio, this._canvas.style.height = t + \"px\";\n          var e = this.pixelRatio;\n\n          this.getContext()._context.scale(e, e);\n        },\n        getWidth: function () {\n          return this.width;\n        },\n        getHeight: function () {\n          return this.height;\n        },\n        setSize: function (t, e) {\n          this.setWidth(t), this.setHeight(e);\n        },\n        toDataURL: function (t, e) {\n          try {\n            return this._canvas.toDataURL(t, e);\n          } catch (t) {\n            try {\n              return this._canvas.toDataURL();\n            } catch (t) {\n              return Konva.Util.warn(\"Unable to get data URL. \" + t.message), \"\";\n            }\n          }\n        }\n      }, Konva.SceneCanvas = function (t) {\n        var e = t || {},\n            i = e.width || 0,\n            n = e.height || 0;\n        Konva.Canvas.call(this, e), this.context = new Konva.SceneContext(this), this.setSize(i, n);\n      }, Konva.Util.extend(Konva.SceneCanvas, Konva.Canvas), Konva.HitCanvas = function (t) {\n        var e = t || {},\n            i = e.width || 0,\n            n = e.height || 0;\n        Konva.Canvas.call(this, e), this.context = new Konva.HitContext(this), this.setSize(i, n), this.hitCanvas = !0;\n      }, Konva.Util.extend(Konva.HitCanvas, Konva.Canvas);\n    }();\n  }, function (t, e) {\n    !function () {\n      \"use strict\";\n\n      Konva.Collection = function () {\n        var t = [].slice.call(arguments),\n            e = t.length,\n            i = 0;\n\n        for (this.length = e; i < e; i++) this[i] = t[i];\n\n        return this;\n      }, Konva.Collection.prototype = [], Konva.Collection.prototype.each = function (t) {\n        for (var e = 0; e < this.length; e++) t(this[e], e);\n      }, Konva.Collection.prototype.toArray = function () {\n        var t,\n            e = [],\n            i = this.length;\n\n        for (t = 0; t < i; t++) e.push(this[t]);\n\n        return e;\n      }, Konva.Collection.toCollection = function (t) {\n        var e,\n            i = new Konva.Collection(),\n            n = t.length;\n\n        for (e = 0; e < n; e++) i.push(t[e]);\n\n        return i;\n      }, Konva.Collection._mapMethod = function (t) {\n        Konva.Collection.prototype[t] = function () {\n          var e,\n              i = this.length,\n              n = [].slice.call(arguments);\n\n          for (e = 0; e < i; e++) this[e][t].apply(this[e], n);\n\n          return this;\n        };\n      }, Konva.Collection.mapMethods = function (t) {\n        var e = t.prototype;\n\n        for (var i in e) Konva.Collection._mapMethod(i);\n      }, Konva.Transform = function (t) {\n        this.m = t && t.slice() || [1, 0, 0, 1, 0, 0];\n      }, Konva.Transform.prototype = {\n        copy: function () {\n          return new Konva.Transform(this.m);\n        },\n        point: function (t) {\n          var e = this.m;\n          return {\n            x: e[0] * t.x + e[2] * t.y + e[4],\n            y: e[1] * t.x + e[3] * t.y + e[5]\n          };\n        },\n        translate: function (t, e) {\n          return this.m[4] += this.m[0] * t + this.m[2] * e, this.m[5] += this.m[1] * t + this.m[3] * e, this;\n        },\n        scale: function (t, e) {\n          return this.m[0] *= t, this.m[1] *= t, this.m[2] *= e, this.m[3] *= e, this;\n        },\n        rotate: function (t) {\n          var e = Math.cos(t),\n              i = Math.sin(t),\n              n = this.m[0] * e + this.m[2] * i,\n              a = this.m[1] * e + this.m[3] * i,\n              r = this.m[0] * -i + this.m[2] * e,\n              o = this.m[1] * -i + this.m[3] * e;\n          return this.m[0] = n, this.m[1] = a, this.m[2] = r, this.m[3] = o, this;\n        },\n        getTranslation: function () {\n          return {\n            x: this.m[4],\n            y: this.m[5]\n          };\n        },\n        skew: function (t, e) {\n          var i = this.m[0] + this.m[2] * e,\n              n = this.m[1] + this.m[3] * e,\n              a = this.m[2] + this.m[0] * t,\n              r = this.m[3] + this.m[1] * t;\n          return this.m[0] = i, this.m[1] = n, this.m[2] = a, this.m[3] = r, this;\n        },\n        multiply: function (t) {\n          var e = this.m[0] * t.m[0] + this.m[2] * t.m[1],\n              i = this.m[1] * t.m[0] + this.m[3] * t.m[1],\n              n = this.m[0] * t.m[2] + this.m[2] * t.m[3],\n              a = this.m[1] * t.m[2] + this.m[3] * t.m[3],\n              r = this.m[0] * t.m[4] + this.m[2] * t.m[5] + this.m[4],\n              o = this.m[1] * t.m[4] + this.m[3] * t.m[5] + this.m[5];\n          return this.m[0] = e, this.m[1] = i, this.m[2] = n, this.m[3] = a, this.m[4] = r, this.m[5] = o, this;\n        },\n        invert: function () {\n          var t = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]),\n              e = this.m[3] * t,\n              i = -this.m[1] * t,\n              n = -this.m[2] * t,\n              a = this.m[0] * t,\n              r = t * (this.m[2] * this.m[5] - this.m[3] * this.m[4]),\n              o = t * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);\n          return this.m[0] = e, this.m[1] = i, this.m[2] = n, this.m[3] = a, this.m[4] = r, this.m[5] = o, this;\n        },\n        getMatrix: function () {\n          return this.m;\n        },\n        setAbsolutePosition: function (t, e) {\n          var i = this.m[0],\n              n = this.m[1],\n              a = this.m[2],\n              r = this.m[3],\n              o = this.m[4],\n              s = (i * (e - this.m[5]) - n * (t - o)) / (i * r - n * a),\n              h = (t - o - a * s) / i;\n          return this.translate(h, s);\n        }\n      };\n      var t = Math.PI / 180,\n          e = 180 / Math.PI,\n          i = {\n        aliceblue: [240, 248, 255],\n        antiquewhite: [250, 235, 215],\n        aqua: [0, 255, 255],\n        aquamarine: [127, 255, 212],\n        azure: [240, 255, 255],\n        beige: [245, 245, 220],\n        bisque: [255, 228, 196],\n        black: [0, 0, 0],\n        blanchedalmond: [255, 235, 205],\n        blue: [0, 0, 255],\n        blueviolet: [138, 43, 226],\n        brown: [165, 42, 42],\n        burlywood: [222, 184, 135],\n        cadetblue: [95, 158, 160],\n        chartreuse: [127, 255, 0],\n        chocolate: [210, 105, 30],\n        coral: [255, 127, 80],\n        cornflowerblue: [100, 149, 237],\n        cornsilk: [255, 248, 220],\n        crimson: [220, 20, 60],\n        cyan: [0, 255, 255],\n        darkblue: [0, 0, 139],\n        darkcyan: [0, 139, 139],\n        darkgoldenrod: [184, 132, 11],\n        darkgray: [169, 169, 169],\n        darkgreen: [0, 100, 0],\n        darkgrey: [169, 169, 169],\n        darkkhaki: [189, 183, 107],\n        darkmagenta: [139, 0, 139],\n        darkolivegreen: [85, 107, 47],\n        darkorange: [255, 140, 0],\n        darkorchid: [153, 50, 204],\n        darkred: [139, 0, 0],\n        darksalmon: [233, 150, 122],\n        darkseagreen: [143, 188, 143],\n        darkslateblue: [72, 61, 139],\n        darkslategray: [47, 79, 79],\n        darkslategrey: [47, 79, 79],\n        darkturquoise: [0, 206, 209],\n        darkviolet: [148, 0, 211],\n        deeppink: [255, 20, 147],\n        deepskyblue: [0, 191, 255],\n        dimgray: [105, 105, 105],\n        dimgrey: [105, 105, 105],\n        dodgerblue: [30, 144, 255],\n        firebrick: [178, 34, 34],\n        floralwhite: [255, 255, 240],\n        forestgreen: [34, 139, 34],\n        fuchsia: [255, 0, 255],\n        gainsboro: [220, 220, 220],\n        ghostwhite: [248, 248, 255],\n        gold: [255, 215, 0],\n        goldenrod: [218, 165, 32],\n        gray: [128, 128, 128],\n        green: [0, 128, 0],\n        greenyellow: [173, 255, 47],\n        grey: [128, 128, 128],\n        honeydew: [240, 255, 240],\n        hotpink: [255, 105, 180],\n        indianred: [205, 92, 92],\n        indigo: [75, 0, 130],\n        ivory: [255, 255, 240],\n        khaki: [240, 230, 140],\n        lavender: [230, 230, 250],\n        lavenderblush: [255, 240, 245],\n        lawngreen: [124, 252, 0],\n        lemonchiffon: [255, 250, 205],\n        lightblue: [173, 216, 230],\n        lightcoral: [240, 128, 128],\n        lightcyan: [224, 255, 255],\n        lightgoldenrodyellow: [250, 250, 210],\n        lightgray: [211, 211, 211],\n        lightgreen: [144, 238, 144],\n        lightgrey: [211, 211, 211],\n        lightpink: [255, 182, 193],\n        lightsalmon: [255, 160, 122],\n        lightseagreen: [32, 178, 170],\n        lightskyblue: [135, 206, 250],\n        lightslategray: [119, 136, 153],\n        lightslategrey: [119, 136, 153],\n        lightsteelblue: [176, 196, 222],\n        lightyellow: [255, 255, 224],\n        lime: [0, 255, 0],\n        limegreen: [50, 205, 50],\n        linen: [250, 240, 230],\n        magenta: [255, 0, 255],\n        maroon: [128, 0, 0],\n        mediumaquamarine: [102, 205, 170],\n        mediumblue: [0, 0, 205],\n        mediumorchid: [186, 85, 211],\n        mediumpurple: [147, 112, 219],\n        mediumseagreen: [60, 179, 113],\n        mediumslateblue: [123, 104, 238],\n        mediumspringgreen: [0, 250, 154],\n        mediumturquoise: [72, 209, 204],\n        mediumvioletred: [199, 21, 133],\n        midnightblue: [25, 25, 112],\n        mintcream: [245, 255, 250],\n        mistyrose: [255, 228, 225],\n        moccasin: [255, 228, 181],\n        navajowhite: [255, 222, 173],\n        navy: [0, 0, 128],\n        oldlace: [253, 245, 230],\n        olive: [128, 128, 0],\n        olivedrab: [107, 142, 35],\n        orange: [255, 165, 0],\n        orangered: [255, 69, 0],\n        orchid: [218, 112, 214],\n        palegoldenrod: [238, 232, 170],\n        palegreen: [152, 251, 152],\n        paleturquoise: [175, 238, 238],\n        palevioletred: [219, 112, 147],\n        papayawhip: [255, 239, 213],\n        peachpuff: [255, 218, 185],\n        peru: [205, 133, 63],\n        pink: [255, 192, 203],\n        plum: [221, 160, 203],\n        powderblue: [176, 224, 230],\n        purple: [128, 0, 128],\n        rebeccapurple: [102, 51, 153],\n        red: [255, 0, 0],\n        rosybrown: [188, 143, 143],\n        royalblue: [65, 105, 225],\n        saddlebrown: [139, 69, 19],\n        salmon: [250, 128, 114],\n        sandybrown: [244, 164, 96],\n        seagreen: [46, 139, 87],\n        seashell: [255, 245, 238],\n        sienna: [160, 82, 45],\n        silver: [192, 192, 192],\n        skyblue: [135, 206, 235],\n        slateblue: [106, 90, 205],\n        slategray: [119, 128, 144],\n        slategrey: [119, 128, 144],\n        snow: [255, 255, 250],\n        springgreen: [0, 255, 127],\n        steelblue: [70, 130, 180],\n        tan: [210, 180, 140],\n        teal: [0, 128, 128],\n        thistle: [216, 191, 216],\n        transparent: [255, 255, 255, 0],\n        tomato: [255, 99, 71],\n        turquoise: [64, 224, 208],\n        violet: [238, 130, 238],\n        wheat: [245, 222, 179],\n        white: [255, 255, 255],\n        whitesmoke: [245, 245, 245],\n        yellow: [255, 255, 0],\n        yellowgreen: [154, 205, 5]\n      },\n          n = /rgb\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)/;\n      Konva.Util = {\n        _isElement: function (t) {\n          return !(!t || 1 != t.nodeType);\n        },\n        _isFunction: function (t) {\n          return !!(t && t.constructor && t.call && t.apply);\n        },\n        _isObject: function (t) {\n          return !!t && t.constructor === Object;\n        },\n        _isArray: function (t) {\n          return \"[object Array]\" === Object.prototype.toString.call(t);\n        },\n        _isNumber: function (t) {\n          return \"[object Number]\" === Object.prototype.toString.call(t) && !isNaN(t) && isFinite(t);\n        },\n        _isString: function (t) {\n          return \"[object String]\" === Object.prototype.toString.call(t);\n        },\n        _isBoolean: function (t) {\n          return \"[object Boolean]\" === Object.prototype.toString.call(t);\n        },\n        isObject: function (t) {\n          return t instanceof Object;\n        },\n        isValidSelector: function (t) {\n          if (\"string\" != typeof t) return !1;\n          var e = t[0];\n          return \"#\" === e || \".\" === e || e === e.toUpperCase();\n        },\n        _sign: function (t) {\n          return 0 === t ? 0 : t > 0 ? 1 : -1;\n        },\n        createCanvasElement: function () {\n          var t = Konva.isBrowser ? Konva.document.createElement(\"canvas\") : new Konva._nodeCanvas();\n\n          try {\n            t.style = t.style || {};\n          } catch (t) {}\n\n          return t;\n        },\n        _isInDocument: function (t) {\n          for (; t = t.parentNode;) if (t == Konva.document) return !0;\n\n          return !1;\n        },\n        _simplifyArray: function (t) {\n          var e,\n              i,\n              n = [],\n              a = t.length,\n              r = Konva.Util;\n\n          for (e = 0; e < a; e++) i = t[e], r._isNumber(i) ? i = Math.round(1e3 * i) / 1e3 : r._isString(i) || (i = i.toString()), n.push(i);\n\n          return n;\n        },\n        _getImage: function (t, e) {\n          var i, n;\n          t ? this._isElement(t) ? e(t) : this._isString(t) ? ((i = new Konva.window.Image()).onload = function () {\n            e(i);\n          }, i.src = t) : t.data ? ((n = Konva.Util.createCanvasElement()).width = t.width, n.height = t.height, n.getContext(\"2d\").putImageData(t, 0, 0), this._getImage(n.toDataURL(), e)) : e(null) : e(null);\n        },\n        _getRGBAString: function (t) {\n          return [\"rgba(\", t.red || 0, \",\", t.green || 0, \",\", t.blue || 0, \",\", t.alpha || 1, \")\"].join(\"\");\n        },\n        _rgbToHex: function (t, e, i) {\n          return ((1 << 24) + (t << 16) + (e << 8) + i).toString(16).slice(1);\n        },\n        _hexToRgb: function (t) {\n          t = t.replace(\"#\", \"\");\n          var e = parseInt(t, 16);\n          return {\n            r: e >> 16 & 255,\n            g: e >> 8 & 255,\n            b: 255 & e\n          };\n        },\n        getRandomColor: function () {\n          for (var t = (16777215 * Math.random() << 0).toString(16); t.length < 6;) t = \"0\" + t;\n\n          return \"#\" + t;\n        },\n        get: function (t, e) {\n          return void 0 === t ? e : t;\n        },\n        getRGB: function (t) {\n          var e;\n          return t in i ? {\n            r: (e = i[t])[0],\n            g: e[1],\n            b: e[2]\n          } : \"#\" === t[0] ? this._hexToRgb(t.substring(1)) : \"rgb(\" === t.substr(0, 4) ? (e = n.exec(t.replace(/ /g, \"\")), {\n            r: parseInt(e[1], 10),\n            g: parseInt(e[2], 10),\n            b: parseInt(e[3], 10)\n          }) : {\n            r: 0,\n            g: 0,\n            b: 0\n          };\n        },\n        colorToRGBA: function (t) {\n          return t = t || \"black\", Konva.Util._namedColorToRBA(t) || Konva.Util._hex3ColorToRGBA(t) || Konva.Util._hex6ColorToRGBA(t) || Konva.Util._rgbColorToRGBA(t) || Konva.Util._rgbaColorToRGBA(t);\n        },\n        _namedColorToRBA: function (t) {\n          var e = i[t.toLowerCase()];\n          return e ? {\n            r: e[0],\n            g: e[1],\n            b: e[2],\n            a: 1\n          } : null;\n        },\n        _rgbColorToRGBA: function (t) {\n          if (0 === t.indexOf(\"rgb(\")) {\n            var e = (t = t.match(/rgb\\(([^)]+)\\)/)[1]).split(/ *, */).map(Number);\n            return {\n              r: e[0],\n              g: e[1],\n              b: e[2],\n              a: 1\n            };\n          }\n        },\n        _rgbaColorToRGBA: function (t) {\n          if (0 === t.indexOf(\"rgba(\")) {\n            var e = (t = t.match(/rgba\\(([^)]+)\\)/)[1]).split(/ *, */).map(Number);\n            return {\n              r: e[0],\n              g: e[1],\n              b: e[2],\n              a: e[3]\n            };\n          }\n        },\n        _hex6ColorToRGBA: function (t) {\n          if (\"#\" === t[0] && 7 === t.length) return {\n            r: parseInt(t.slice(1, 3), 16),\n            g: parseInt(t.slice(3, 5), 16),\n            b: parseInt(t.slice(5, 7), 16),\n            a: 1\n          };\n        },\n        _hex3ColorToRGBA: function (t) {\n          if (\"#\" === t[0] && 4 === t.length) return {\n            r: parseInt(t[1] + t[1], 16),\n            g: parseInt(t[2] + t[2], 16),\n            b: parseInt(t[3] + t[3], 16),\n            a: 1\n          };\n        },\n        _merge: function (t, e) {\n          var i = this._clone(e);\n\n          for (var n in t) this._isObject(t[n]) ? i[n] = this._merge(t[n], i[n]) : i[n] = t[n];\n\n          return i;\n        },\n        trimRight: function (t) {\n          return t.replace(/\\s+$/, \"\");\n        },\n        trimLeft: function (t) {\n          return t.replace(/^\\s+/, \"\");\n        },\n        haveIntersection: function (t, e) {\n          return !(e.x > t.x + t.width || e.x + e.width < t.x || e.y > t.y + t.height || e.y + e.height < t.y);\n        },\n        cloneObject: function (t) {\n          var e = {};\n\n          for (var i in t) this._isObject(t[i]) ? e[i] = this.cloneObject(t[i]) : this._isArray(t[i]) ? e[i] = this.cloneArray(t[i]) : e[i] = t[i];\n\n          return e;\n        },\n        cloneArray: function (t) {\n          return t.slice(0);\n        },\n        _degToRad: function (e) {\n          return e * t;\n        },\n        _radToDeg: function (t) {\n          return t * e;\n        },\n        _capitalize: function (t) {\n          return t.charAt(0).toUpperCase() + t.slice(1);\n        },\n        throw: function (t) {\n          throw new Error(\"Konva error: \" + t);\n        },\n        error: function (t) {\n          console.error(\"Konva error: \" + t);\n        },\n        warn: function (t) {\n          Konva.global.console && console.warn && Konva.showWarnings && console.warn(\"Konva warning: \" + t);\n        },\n        extend: function (t, e) {\n          function i() {\n            this.constructor = t;\n          }\n\n          i.prototype = e.prototype;\n          var n = t.prototype;\n\n          for (var a in t.prototype = new i(), n) n.hasOwnProperty(a) && (t.prototype[a] = n[a]);\n\n          t.__super__ = e.prototype, t.super = e;\n        },\n        addMethods: function (t, e) {\n          var i;\n\n          for (i in e) t.prototype[i] = e[i];\n        },\n        _getControlPoints: function (t, e, i, n, a, r, o) {\n          var s = Math.sqrt(Math.pow(i - t, 2) + Math.pow(n - e, 2)),\n              h = Math.sqrt(Math.pow(a - i, 2) + Math.pow(r - n, 2)),\n              l = o * s / (s + h),\n              c = o * h / (s + h);\n          return [i - l * (a - t), n - l * (r - e), i + c * (a - t), n + c * (r - e)];\n        },\n        _expandPoints: function (t, e) {\n          var i,\n              n,\n              a = t.length,\n              r = [];\n\n          for (i = 2; i < a - 2; i += 2) n = Konva.Util._getControlPoints(t[i - 2], t[i - 1], t[i], t[i + 1], t[i + 2], t[i + 3], e), r.push(n[0]), r.push(n[1]), r.push(t[i]), r.push(t[i + 1]), r.push(n[2]), r.push(n[3]);\n\n          return r;\n        },\n        _removeLastLetter: function (t) {\n          return t.substring(0, t.length - 1);\n        },\n        each: function (t, e) {\n          for (var i in t) e(i, t[i]);\n        },\n        _inRange: function (t, e, i) {\n          return e <= t && t < i;\n        },\n        _getProjectionToSegment: function (t, e, i, n, a, r) {\n          var o,\n              s,\n              h,\n              l = (t - i) * (t - i) + (e - n) * (e - n);\n          if (0 == l) o = t, s = e, h = (a - i) * (a - i) + (r - n) * (r - n);else {\n            var c = ((a - t) * (i - t) + (r - e) * (n - e)) / l;\n            c < 0 ? (o = t, s = e, h = (t - a) * (t - a) + (e - r) * (e - r)) : c > 1 ? (o = i, s = n, h = (i - a) * (i - a) + (n - r) * (n - r)) : h = ((o = t + c * (i - t)) - a) * (o - a) + ((s = e + c * (n - e)) - r) * (s - r);\n          }\n          return [o, s, h];\n        },\n        _getProjectionToLine: function (t, e, i) {\n          var n = Konva.Util.cloneObject(t),\n              a = Number.MAX_VALUE;\n          return e.forEach(function (r, o) {\n            if (i || o !== e.length - 1) {\n              var s = e[(o + 1) % e.length],\n                  h = Konva.Util._getProjectionToSegment(r.x, r.y, s.x, s.y, t.x, t.y),\n                  l = h[0],\n                  c = h[1],\n                  d = h[2];\n\n              d < a && (n.x = l, n.y = c, a = d);\n            }\n          }), n;\n        },\n        _prepareArrayForTween: function (t, e, i) {\n          var n,\n              a = [],\n              r = [];\n\n          if (t.length > e.length) {\n            var o = e;\n            e = t, t = o;\n          }\n\n          for (n = 0; n < t.length; n += 2) a.push({\n            x: t[n],\n            y: t[n + 1]\n          });\n\n          for (n = 0; n < e.length; n += 2) r.push({\n            x: e[n],\n            y: e[n + 1]\n          });\n\n          var s = [];\n          return r.forEach(function (t) {\n            var e = Konva.Util._getProjectionToLine(t, a, i);\n\n            s.push(e.x), s.push(e.y);\n          }), s;\n        },\n        _prepareToStringify: function (t) {\n          var e;\n\n          for (var i in t.visitedByCircularReferenceRemoval = !0, t) if (t.hasOwnProperty(i) && t[i] && \"object\" == typeof t[i]) if (e = Object.getOwnPropertyDescriptor(t, i), t[i].visitedByCircularReferenceRemoval || Konva.Util._isElement(t[i])) {\n            if (!e.configurable) return null;\n            delete t[i];\n          } else if (null === Konva.Util._prepareToStringify(t[i])) {\n            if (!e.configurable) return null;\n            delete t[i];\n          }\n\n          return delete t.visitedByCircularReferenceRemoval, t;\n        }\n      };\n    }();\n  }, function (t, e) {\n    var i;\n\n    i = function () {\n      return this;\n    }();\n\n    try {\n      i = i || Function(\"return this\")() || (0, eval)(\"this\");\n    } catch (t) {\n      \"object\" == typeof window && (i = window);\n    }\n\n    t.exports = i;\n  }, function (t, e, i) {\n    (function (e) {\n      /*\n       * Konva JavaScript Framework v@@version\n       * http://konvajs.github.io/\n       * Licensed under the MIT\n       * Date: @@date\n       *\n       * Original work Copyright (C) 2011 - 2013 by Eric Rowell (KineticJS)\n       * Modified work Copyright (C) 2014 - present by Anton Lavrenov (Konva)\n       *\n       * @license\n       */\n      !function () {\n        \"use strict\";\n\n        var i = Math.PI / 180,\n            n = {\n          version: \"@@version\",\n          stages: [],\n          idCounter: 0,\n          ids: {},\n          names: {},\n          shapes: {},\n          listenClickTap: !1,\n          inDblClickWindow: !1,\n          isBrowser: \"undefined\" != typeof window && (\"[object Window]\" === {}.toString.call(window) || \"[object global]\" === {}.toString.call(window)),\n          isUnminified: /comment/.test(function () {}),\n          enableTrace: !1,\n          traceArrMax: 100,\n          dblClickWindow: 400,\n          pixelRatio: void 0,\n          dragDistance: 3,\n          angleDeg: !0,\n          showWarnings: !0,\n          Filters: {},\n          isDragging: function () {\n            var t = n.DD;\n            return !!t && t.isDragging;\n          },\n          isDragReady: function () {\n            var t = n.DD;\n            return !!t && !!t.node;\n          },\n          _addId: function (t, e) {\n            e && (this.ids[e] = t);\n          },\n          _removeId: function (t) {\n            void 0 !== t && delete this.ids[t];\n          },\n          _addName: function (t, e) {\n            e && (this.names[e] || (this.names[e] = []), this.names[e].push(t));\n          },\n          _removeName: function (t, e) {\n            if (t) {\n              var i = this.names[t];\n\n              if (i) {\n                for (var n = 0; n < i.length; n++) i[n]._id === e && i.splice(n, 1);\n\n                0 === i.length && delete this.names[t];\n              }\n            }\n          },\n          getAngle: function (t) {\n            return this.angleDeg ? t * i : t;\n          },\n          _detectIE: function (t) {\n            var e = t.indexOf(\"msie \");\n            if (e > 0) return parseInt(t.substring(e + 5, t.indexOf(\".\", e)), 10);\n\n            if (t.indexOf(\"trident/\") > 0) {\n              var i = t.indexOf(\"rv:\");\n              return parseInt(t.substring(i + 3, t.indexOf(\".\", i)), 10);\n            }\n\n            var n = t.indexOf(\"edge/\");\n            return n > 0 && parseInt(t.substring(n + 5, t.indexOf(\".\", n)), 10);\n          },\n          _parseUA: function (t) {\n            var e = t.toLowerCase(),\n                i = /(chrome)[ /]([\\w.]+)/.exec(e) || /(webkit)[ /]([\\w.]+)/.exec(e) || /(opera)(?:.*version|)[ /]([\\w.]+)/.exec(e) || /(msie) ([\\w.]+)/.exec(e) || e.indexOf(\"compatible\") < 0 && /(mozilla)(?:.*? rv:([\\w.]+)|)/.exec(e) || [],\n                a = !!t.match(/Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile/i),\n                r = !!t.match(/IEMobile/i);\n            return {\n              browser: i[1] || \"\",\n              version: i[2] || \"0\",\n              isIE: n._detectIE(e),\n              mobile: a,\n              ieMobile: r\n            };\n          },\n          UA: void 0\n        },\n            a = void 0 !== e ? e : \"undefined\" != typeof window ? window : \"undefined\" != typeof WorkerGlobalScope ? self : {};\n        n.UA = n._parseUA(a.navigator && a.navigator.userAgent || \"\"), a.Konva && console.error(\"Konva instance is already exist in current eviroment. Please use only one instance.\"), a.Konva = n, n.global = a, n.window = a, n.document = a.document, t.exports = n;\n      }();\n    }).call(this, i(20));\n  }, function (t, e, i) {\n    \"use strict\";\n\n    i.r(e);\n    var n = i(0),\n        a = i.n(n),\n        r = i(1),\n        o = i.n(r);\n\n    function s(t) {\n      return (s = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n        return typeof t;\n      } : function (t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n      })(t);\n    }\n\n    function h(t) {\n      for (var e = 1; e < arguments.length; e++) {\n        var i = null != arguments[e] ? arguments[e] : {},\n            n = Object.keys(i);\n        \"function\" == typeof Object.getOwnPropertySymbols && (n = n.concat(Object.getOwnPropertySymbols(i).filter(function (t) {\n          return Object.getOwnPropertyDescriptor(i, t).enumerable;\n        }))), n.forEach(function (e) {\n          f(t, e, i[e]);\n        });\n      }\n\n      return t;\n    }\n\n    function l(t, e) {\n      for (var i = 0; i < e.length; i++) {\n        var n = e[i];\n        n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n      }\n    }\n\n    function c(t) {\n      return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {\n        return t.__proto__ || Object.getPrototypeOf(t);\n      })(t);\n    }\n\n    function d(t) {\n      if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return t;\n    }\n\n    function u(t, e) {\n      return (u = Object.setPrototypeOf || function (t, e) {\n        return t.__proto__ = e, t;\n      })(t, e);\n    }\n\n    function f(t, e, i) {\n      return e in t ? Object.defineProperty(t, e, {\n        value: i,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : t[e] = i, t;\n    }\n\n    i(7), i(6), i(5), i(4), i(3), i(2);\n\n    var g = function (t) {\n      function e(t) {\n        var i, n;\n        !function (t, e) {\n          if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, e);\n        var a = (i = !(n = c(e).call(this, t)) || \"object\" !== s(n) && \"function\" != typeof n ? d(this) : n).generateHash(\"avatar_container\"),\n            r = i.generateHash(\"avatar_loader\");\n        return i.onFileLoad = i.onFileLoad.bind(d(i)), i.onCloseClick = i.onCloseClick.bind(d(i)), i.state = {\n          imgWidth: 0,\n          imgHeight: 0,\n          scale: 1,\n          containerId: a,\n          loaderId: r,\n          lastMouseY: 0,\n          showLoader: !(i.props.src || i.props.img)\n        }, i;\n      }\n\n      var i, n;\n      return function (t, e) {\n        if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n        t.prototype = Object.create(e && e.prototype, {\n          constructor: {\n            value: t,\n            writable: !0,\n            configurable: !0\n          }\n        }), e && u(t, e);\n      }(e, a.a.Component), i = e, (n = [{\n        key: \"generateHash\",\n        value: function (t) {\n          var e = function () {\n            return Math.floor(65536 * (1 + Math.random())).toString(16).substring(1);\n          };\n\n          return t + \"-\" + e() + \"-\" + e() + \"-\" + e();\n        }\n      }, {\n        key: \"onCloseCallback\",\n        value: function () {\n          this.props.onClose();\n        }\n      }, {\n        key: \"onCropCallback\",\n        value: function (t) {\n          this.props.onCrop(t);\n        }\n      }, {\n        key: \"onFileLoadCallback\",\n        value: function (t) {\n          this.props.onFileLoad(t);\n        }\n      }, {\n        key: \"onBeforeFileLoadCallback\",\n        value: function (t) {\n          this.props.onBeforeFileLoad(t);\n        }\n      }, {\n        key: \"onImageLoadCallback\",\n        value: function (t) {\n          this.props.onImageLoad(t);\n        }\n      }, {\n        key: \"componentDidMount\",\n        value: function () {\n          var t = this;\n\n          if (!this.state.showLoader) {\n            var e = this.props.img || new Image();\n            !this.props.img && this.props.src && (e.src = this.props.src), this.setState({\n              image: e\n            }, function () {\n              if (t.image.complete) return t.init();\n\n              t.image.onload = function () {\n                t.onImageLoadCallback(t.image), t.init();\n              };\n            });\n          }\n        }\n      }, {\n        key: \"onFileLoad\",\n        value: function (t) {\n          if (t.preventDefault(), this.onBeforeFileLoadCallback(t), t.target.value) {\n            var e = new FileReader(),\n                i = t.target.files[0];\n            this.onFileLoadCallback(i);\n            var n = new Image(),\n                a = this;\n            e.onloadend = function () {\n              n.src = e.result, a.setState({\n                image: n,\n                file: i,\n                showLoader: !1\n              }, function () {\n                if (a.image.complete) return a.init();\n\n                a.image.onload = function () {\n                  return a.init();\n                };\n              });\n            }, e.readAsDataURL(i);\n          }\n        }\n      }, {\n        key: \"onCloseClick\",\n        value: function () {\n          var t = this;\n          this.setState({\n            showLoader: !0\n          }, function () {\n            return t.onCloseCallback();\n          });\n        }\n      }, {\n        key: \"init\",\n        value: function () {\n          var t,\n              e,\n              i = this.props,\n              n = i.height,\n              a = i.minCropRadius,\n              r = i.cropRadius,\n              o = this.image.width,\n              s = this.image.height,\n              h = s / o,\n              l = this.props,\n              c = l.imageWidth,\n              d = l.imageHeight;\n          d && c && console.warn(\"The imageWidth and imageHeight properties can not be set together, using only imageWidth.\"), d && !c ? e = (t = d || s) / h : c ? t = (e = c) * h || s : e = (t = n || s) / h;\n          var u = t / s,\n              f = Math.max(a, r || Math.min(e, t) / 3);\n          this.setState({\n            imgWidth: e,\n            imgHeight: t,\n            scale: u,\n            cropRadius: f\n          }, this.initCanvas);\n        }\n      }, {\n        key: \"initCanvas\",\n        value: function () {\n          var t = this,\n              e = this.initStage(),\n              i = this.initBackground(),\n              n = this.initShading(),\n              a = this.initCrop(),\n              r = this.initCropStroke(),\n              s = this.initResize(),\n              h = this.initResizeIcon(),\n              l = new o.a.Layer();\n          l.add(i), l.add(n), l.add(r), l.add(a), l.add(s), l.add(h), e.add(l);\n\n          var c = function () {\n            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;\n            return a.radius() - t;\n          },\n              d = function (t) {\n            return a.x() - c(t) < 0;\n          },\n              u = function (t) {\n            return a.y() - c(t) < 0;\n          },\n              f = function (t) {\n            return a.x() + c(t) > e.width();\n          },\n              g = function (t) {\n            return a.y() + c(t) > e.height();\n          },\n              v = function (e) {\n            return c(e) >= t.minCropRadius ? e : a.radius() - t.minCropRadius;\n          },\n              p = function (t) {\n            return t + .86 * a.radius();\n          },\n              m = function (t) {\n            return t - .5 * a.radius();\n          },\n              y = function (t, e) {\n            s.x(p(t) - 8), s.y(m(e) - 8), h.x(p(t) - 8), h.y(m(e) - 10);\n          },\n              _ = function () {\n            return a.toDataURL({\n              x: a.x() - a.radius(),\n              y: a.y() - a.radius(),\n              width: 2 * a.radius(),\n              height: 2 * a.radius()\n            });\n          },\n              b = function (t) {\n            var e = t > 0 || function (t) {\n              return !(d(t) || f(t) || g(t) || u(t));\n            }(t) ? t : 0;\n            r.radius(r.radius() - v(e)), a.radius(a.radius() - v(e)), s.fire(\"resize\");\n          };\n\n          this.onCropCallback(_()), a.on(\"dragmove\", function () {\n            return a.fire(\"resize\");\n          }), a.on(\"dragend\", function () {\n            return t.onCropCallback(_());\n          }), a.on(\"resize\", function () {\n            var i = d() ? a.radius() + 1 : f() ? e.width() - a.radius() - 1 : a.x(),\n                n = u() ? a.radius() + 1 : g() ? e.height() - a.radius() - 1 : a.y();\n            y(i, n), a.setFillPatternOffset({\n              x: i / t.scale,\n              y: n / t.scale\n            }), a.x(i), r.x(i), a.y(n), r.y(n);\n          }), a.on(\"mouseenter\", function () {\n            return e.container().style.cursor = \"move\";\n          }), a.on(\"mouseleave\", function () {\n            return e.container().style.cursor = \"default\";\n          }), a.on(\"dragstart\", function () {\n            return e.container().style.cursor = \"move\";\n          }), a.on(\"dragend\", function () {\n            return e.container().style.cursor = \"default\";\n          }), s.on(\"touchstart\", function (e) {\n            s.on(\"dragmove\", function (i) {\n              if (\"touchmove\" === i.evt.type) {\n                var n = i.evt.changedTouches[0].pageY - e.evt.changedTouches[0].pageY || 0;\n                b(n * t.mobileScaleSpeed);\n              }\n            });\n          }), s.on(\"dragmove\", function (e) {\n            if (\"touchmove\" !== e.evt.type) {\n              var i = e.evt.y,\n                  n = i ? i - t.state.lastMouseY : void 0,\n                  a = e.evt.movementY || n || 0;\n              t.setState({\n                lastMouseY: i\n              }), b(a);\n            }\n          }), s.on(\"dragend\", function () {\n            return t.onCropCallback(_());\n          }), s.on(\"resize\", function () {\n            return y(a.x(), a.y());\n          }), s.on(\"mouseenter\", function () {\n            return e.container().style.cursor = \"nesw-resize\";\n          }), s.on(\"mouseleave\", function () {\n            return e.container().style.cursor = \"default\";\n          }), s.on(\"dragstart\", function (i) {\n            t.setState({\n              lastMouseY: i.evt.y\n            }), e.container().style.cursor = \"nesw-resize\";\n          }), s.on(\"dragend\", function () {\n            return e.container().style.cursor = \"default\";\n          });\n        }\n      }, {\n        key: \"initStage\",\n        value: function () {\n          return new o.a.Stage({\n            container: this.containerId,\n            width: this.width,\n            height: this.height\n          });\n        }\n      }, {\n        key: \"initBackground\",\n        value: function () {\n          return new o.a.Image({\n            x: 0,\n            y: 0,\n            width: this.width,\n            height: this.height,\n            image: this.image\n          });\n        }\n      }, {\n        key: \"initShading\",\n        value: function () {\n          return new o.a.Rect({\n            x: 0,\n            y: 0,\n            width: this.width,\n            height: this.height,\n            fill: this.shadingColor,\n            strokeWidth: 4,\n            opacity: this.shadingOpacity\n          });\n        }\n      }, {\n        key: \"initCrop\",\n        value: function () {\n          return new o.a.Circle({\n            x: this.halfWidth,\n            y: this.halfHeight,\n            radius: this.cropRadius,\n            fillPatternImage: this.image,\n            fillPatternOffset: {\n              x: this.halfWidth / this.scale,\n              y: this.halfHeight / this.scale\n            },\n            fillPatternScale: {\n              x: this.scale,\n              y: this.scale\n            },\n            opacity: 1,\n            draggable: !0,\n            dashEnabled: !0,\n            dash: [10, 5]\n          });\n        }\n      }, {\n        key: \"initCropStroke\",\n        value: function () {\n          return new o.a.Circle({\n            x: this.halfWidth,\n            y: this.halfHeight,\n            radius: this.cropRadius,\n            stroke: this.cropColor,\n            strokeWidth: this.lineWidth,\n            strokeScaleEnabled: !0,\n            dashEnabled: !0,\n            dash: [10, 5]\n          });\n        }\n      }, {\n        key: \"initResize\",\n        value: function () {\n          return new o.a.Rect({\n            x: this.halfWidth + .86 * this.cropRadius - 8,\n            y: this.halfHeight + -.5 * this.cropRadius - 8,\n            width: 16,\n            height: 16,\n            draggable: !0,\n            dragBoundFunc: function (t) {\n              return {\n                x: this.getAbsolutePosition().x,\n                y: t.y\n              };\n            }\n          });\n        }\n      }, {\n        key: \"initResizeIcon\",\n        value: function () {\n          return new o.a.Path({\n            x: this.halfWidth + .86 * this.cropRadius - 8,\n            y: this.halfHeight + -.5 * this.cropRadius - 10,\n            data: \"M47.624,0.124l12.021,9.73L44.5,24.5l10,10l14.661-15.161l9.963,12.285v-31.5H47.624z M24.5,44.5   L9.847,59.653L0,47.5V79h31.5l-12.153-9.847L34.5,54.5L24.5,44.5z\",\n            fill: this.cropColor,\n            scale: {\n              x: .2,\n              y: .2\n            }\n          });\n        }\n      }, {\n        key: \"render\",\n        value: function () {\n          var t = this,\n              e = this.props,\n              i = e.width,\n              n = e.height,\n              r = {\n            display: \"flex\",\n            justifyContent: \"center\",\n            backgroundColor: this.backgroundColor,\n            width: i || this.width,\n            position: \"relative\"\n          },\n              o = this.props.label,\n              s = h({}, this.props.labelStyle, {\n            lineHeight: (n || 200) + \"px\"\n          }),\n              l = h({}, this.props.borderStyle, {\n            width: i || 200,\n            height: n || 200\n          });\n          return a.a.createElement(\"div\", null, this.state.showLoader ? a.a.createElement(\"div\", {\n            style: l\n          }, a.a.createElement(\"input\", {\n            onChange: function (e) {\n              return t.onFileLoad(e);\n            },\n            name: this.loaderId,\n            type: \"file\",\n            id: this.loaderId,\n            style: {\n              width: .1,\n              height: .1,\n              opacity: 0,\n              overflow: \"hidden\",\n              position: \"absolute\",\n              zIndex: -1\n            },\n            accept: this.mimeTypes\n          }), a.a.createElement(\"label\", {\n            htmlFor: this.loaderId,\n            style: s\n          }, o)) : a.a.createElement(\"div\", {\n            style: r\n          }, a.a.createElement(\"svg\", {\n            onClick: this.onCloseClick,\n            style: {\n              position: \"absolute\",\n              zIndex: 999,\n              cursor: \"pointer\",\n              left: \"10px\",\n              top: \"10px\"\n            },\n            viewBox: \"0 0 475.2 475.2\",\n            width: \"20px\",\n            height: \"20px\"\n          }, a.a.createElement(\"g\", null, a.a.createElement(\"path\", {\n            d: \"M405.6,69.6C360.7,24.7,301.1,0,237.6,0s-123.1,24.7-168,69.6S0,174.1,0,237.6s24.7,123.1,69.6,168s104.5,69.6,168,69.6    s123.1-24.7,168-69.6s69.6-104.5,69.6-168S450.5,114.5,405.6,69.6z M386.5,386.5c-39.8,39.8-92.7,61.7-148.9,61.7    s-109.1-21.9-148.9-61.7c-82.1-82.1-82.1-215.7,0-297.8C128.5,48.9,181.4,27,237.6,27s109.1,21.9,148.9,61.7    C468.6,170.8,468.6,304.4,386.5,386.5z\",\n            fill: this.closeIconColor\n          }), a.a.createElement(\"path\", {\n            d: \"M342.3,132.9c-5.3-5.3-13.8-5.3-19.1,0l-85.6,85.6L152,132.9c-5.3-5.3-13.8-5.3-19.1,0c-5.3,5.3-5.3,13.8,0,19.1    l85.6,85.6l-85.6,85.6c-5.3,5.3-5.3,13.8,0,19.1c2.6,2.6,6.1,4,9.5,4s6.9-1.3,9.5-4l85.6-85.6l85.6,85.6c2.6,2.6,6.1,4,9.5,4    c3.5,0,6.9-1.3,9.5-4c5.3-5.3,5.3-13.8,0-19.1l-85.4-85.6l85.6-85.6C347.6,146.7,347.6,138.2,342.3,132.9z\",\n            fill: this.closeIconColor\n          }))), a.a.createElement(\"div\", {\n            id: this.containerId\n          })));\n        }\n      }, {\n        key: \"lineWidth\",\n        get: function () {\n          return this.props.lineWidth;\n        }\n      }, {\n        key: \"containerId\",\n        get: function () {\n          return this.state.containerId;\n        }\n      }, {\n        key: \"closeIconColor\",\n        get: function () {\n          return this.props.closeIconColor;\n        }\n      }, {\n        key: \"cropColor\",\n        get: function () {\n          return this.props.cropColor;\n        }\n      }, {\n        key: \"loaderId\",\n        get: function () {\n          return this.state.loaderId;\n        }\n      }, {\n        key: \"mimeTypes\",\n        get: function () {\n          return this.props.mimeTypes;\n        }\n      }, {\n        key: \"backgroundColor\",\n        get: function () {\n          return this.props.backgroundColor;\n        }\n      }, {\n        key: \"shadingColor\",\n        get: function () {\n          return this.props.shadingColor;\n        }\n      }, {\n        key: \"shadingOpacity\",\n        get: function () {\n          return this.props.shadingOpacity;\n        }\n      }, {\n        key: \"mobileScaleSpeed\",\n        get: function () {\n          return this.props.mobileScaleSpeed;\n        }\n      }, {\n        key: \"cropRadius\",\n        get: function () {\n          return this.state.cropRadius;\n        }\n      }, {\n        key: \"minCropRadius\",\n        get: function () {\n          return this.props.minCropRadius;\n        }\n      }, {\n        key: \"scale\",\n        get: function () {\n          return this.state.scale;\n        }\n      }, {\n        key: \"width\",\n        get: function () {\n          return this.state.imgWidth;\n        }\n      }, {\n        key: \"halfWidth\",\n        get: function () {\n          return this.state.imgWidth / 2;\n        }\n      }, {\n        key: \"height\",\n        get: function () {\n          return this.state.imgHeight;\n        }\n      }, {\n        key: \"halfHeight\",\n        get: function () {\n          return this.state.imgHeight / 2;\n        }\n      }, {\n        key: \"image\",\n        get: function () {\n          return this.state.image;\n        }\n      }]) && l(i.prototype, n), e;\n    }();\n\n    f(g, \"defaultProps\", {\n      shadingColor: \"grey\",\n      shadingOpacity: .6,\n      cropColor: \"white\",\n      closeIconColor: \"white\",\n      lineWidth: 4,\n      minCropRadius: 30,\n      backgroundColor: \"grey\",\n      mimeTypes: \"image/jpeg,image/png\",\n      mobileScaleSpeed: .5,\n      onClose: function () {},\n      onCrop: function () {},\n      onFileLoad: function () {},\n      onImageLoad: function () {},\n      onBeforeFileLoad: function () {},\n      label: \"Choose a file\",\n      labelStyle: {\n        fontSize: \"1.25em\",\n        fontWeight: \"700\",\n        color: \"black\",\n        display: \"inline-block\",\n        fontFamily: \"sans-serif\",\n        cursor: \"pointer\"\n      },\n      borderStyle: {\n        border: \"2px solid #979797\",\n        borderStyle: \"dashed\",\n        borderRadius: \"8px\",\n        textAlign: \"center\"\n      }\n    }), e.default = g;\n  }]);\n});","map":null,"metadata":{},"sourceType":"script"}