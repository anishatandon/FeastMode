{"ast":null,"code":"'use strict'; // Load modules\n\nconst Hoek = require('hoek');\n\nconst Any = require('./any');\n\nconst Cast = require('./cast');\n\nconst Ref = require('./ref'); // Declare internals\n\n\nconst internals = {};\ninternals.Alternatives = class extends Any {\n  constructor() {\n    super();\n    this._type = 'alternatives';\n\n    this._invalids.remove(null);\n\n    this._inner.matches = [];\n  }\n\n  _base(value, state, options) {\n    let errors = [];\n    const il = this._inner.matches.length;\n    const baseType = this._settings && this._settings.baseType;\n\n    for (let i = 0; i < il; ++i) {\n      const item = this._inner.matches[i];\n      const schema = item.schema;\n\n      if (!schema) {\n        const failed = item.is._validate(item.ref(state.parent, options), null, options, state.parent).errors;\n\n        if (failed) {\n          if (item.otherwise) {\n            return item.otherwise._validate(value, state, options);\n          } else if (baseType && i === il - 1) {\n            return baseType._validate(value, state, options);\n          }\n        } else if (item.then || baseType) {\n          return (item.then || baseType)._validate(value, state, options);\n        }\n\n        continue;\n      }\n\n      const result = schema._validate(value, state, options);\n\n      if (!result.errors) {\n        // Found a valid match\n        return result;\n      }\n\n      errors = errors.concat(result.errors);\n    }\n\n    return {\n      errors: errors.length ? errors : this.createError('alternatives.base', null, state, options)\n    };\n  }\n\n  try()\n  /* schemas */\n  {\n    const schemas = Hoek.flatten(Array.prototype.slice.call(arguments));\n    Hoek.assert(schemas.length, 'Cannot add other alternatives without at least one schema');\n    const obj = this.clone();\n\n    for (let i = 0; i < schemas.length; ++i) {\n      const cast = Cast.schema(schemas[i]);\n\n      if (cast._refs.length) {\n        obj._refs = obj._refs.concat(cast._refs);\n      }\n\n      obj._inner.matches.push({\n        schema: cast\n      });\n    }\n\n    return obj;\n  }\n\n  when(ref, options) {\n    Hoek.assert(Ref.isRef(ref) || typeof ref === 'string', 'Invalid reference:', ref);\n    Hoek.assert(options, 'Missing options');\n    Hoek.assert(typeof options === 'object', 'Invalid options');\n    Hoek.assert(options.hasOwnProperty('is'), 'Missing \"is\" directive');\n    Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n    const obj = this.clone();\n    let is = Cast.schema(options.is);\n\n    if (options.is === null || !(Ref.isRef(options.is) || options.is instanceof Any)) {\n      // Only apply required if this wasn't already a schema or a ref, we'll suppose people know what they're doing\n      is = is.required();\n    }\n\n    const item = {\n      ref: Cast.ref(ref),\n      is,\n      then: options.then !== undefined ? Cast.schema(options.then) : undefined,\n      otherwise: options.otherwise !== undefined ? Cast.schema(options.otherwise) : undefined\n    };\n\n    if (obj._settings && obj._settings.baseType) {\n      item.then = item.then && obj._settings.baseType.concat(item.then);\n      item.otherwise = item.otherwise && obj._settings.baseType.concat(item.otherwise);\n    }\n\n    Ref.push(obj._refs, item.ref);\n    obj._refs = obj._refs.concat(item.is._refs);\n\n    if (item.then && item.then._refs) {\n      obj._refs = obj._refs.concat(item.then._refs);\n    }\n\n    if (item.otherwise && item.otherwise._refs) {\n      obj._refs = obj._refs.concat(item.otherwise._refs);\n    }\n\n    obj._inner.matches.push(item);\n\n    return obj;\n  }\n\n  describe() {\n    const description = Any.prototype.describe.call(this);\n    const alternatives = [];\n\n    for (let i = 0; i < this._inner.matches.length; ++i) {\n      const item = this._inner.matches[i];\n\n      if (item.schema) {\n        // try()\n        alternatives.push(item.schema.describe());\n      } else {\n        // when()\n        const when = {\n          ref: item.ref.toString(),\n          is: item.is.describe()\n        };\n\n        if (item.then) {\n          when.then = item.then.describe();\n        }\n\n        if (item.otherwise) {\n          when.otherwise = item.otherwise.describe();\n        }\n\n        alternatives.push(when);\n      }\n    }\n\n    description.alternatives = alternatives;\n    return description;\n  }\n\n};\nmodule.exports = new internals.Alternatives();","map":null,"metadata":{},"sourceType":"script"}