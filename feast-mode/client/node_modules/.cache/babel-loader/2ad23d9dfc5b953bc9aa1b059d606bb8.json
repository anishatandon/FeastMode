{"ast":null,"code":"'use strict'; // Load modules\n\nconst Hoek = require('hoek'); // Declare internals\n\n\nconst internals = {};\n\nexports = module.exports = internals.Topo = function () {\n  this._items = [];\n  this.nodes = [];\n};\n\ninternals.Topo.prototype.add = function (nodes, options) {\n  options = options || {}; // Validate rules\n\n  const before = [].concat(options.before || []);\n  const after = [].concat(options.after || []);\n  const group = options.group || '?';\n  const sort = options.sort || 0; // Used for merging only\n\n  Hoek.assert(before.indexOf(group) === -1, 'Item cannot come before itself:', group);\n  Hoek.assert(before.indexOf('?') === -1, 'Item cannot come before unassociated items');\n  Hoek.assert(after.indexOf(group) === -1, 'Item cannot come after itself:', group);\n  Hoek.assert(after.indexOf('?') === -1, 'Item cannot come after unassociated items');\n  [].concat(nodes).forEach((node, i) => {\n    const item = {\n      seq: this._items.length,\n      sort: sort,\n      before: before,\n      after: after,\n      group: group,\n      node: node\n    };\n\n    this._items.push(item);\n  }); // Insert event\n\n  const error = this._sort();\n\n  Hoek.assert(!error, 'item', group !== '?' ? 'added into group ' + group : '', 'created a dependencies error');\n  return this.nodes;\n};\n\ninternals.Topo.prototype.merge = function (others) {\n  others = [].concat(others);\n\n  for (let i = 0; i < others.length; ++i) {\n    const other = others[i];\n\n    if (other) {\n      for (let j = 0; j < other._items.length; ++j) {\n        const item = Hoek.shallow(other._items[j]);\n\n        this._items.push(item);\n      }\n    }\n  } // Sort items\n\n\n  this._items.sort(internals.mergeSort);\n\n  for (let i = 0; i < this._items.length; ++i) {\n    this._items[i].seq = i;\n  }\n\n  const error = this._sort();\n\n  Hoek.assert(!error, 'merge created a dependencies error');\n  return this.nodes;\n};\n\ninternals.mergeSort = function (a, b) {\n  return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;\n};\n\ninternals.Topo.prototype._sort = function () {\n  // Construct graph\n  const graph = {};\n  const graphAfters = Object.create(null); // A prototype can bungle lookups w/ false positives\n\n  const groups = Object.create(null);\n\n  for (let i = 0; i < this._items.length; ++i) {\n    const item = this._items[i];\n    const seq = item.seq; // Unique across all items\n\n    const group = item.group; // Determine Groups\n\n    groups[group] = groups[group] || [];\n    groups[group].push(seq); // Build intermediary graph using 'before'\n\n    graph[seq] = item.before; // Build second intermediary graph with 'after'\n\n    const after = item.after;\n\n    for (let j = 0; j < after.length; ++j) {\n      graphAfters[after[j]] = (graphAfters[after[j]] || []).concat(seq);\n    }\n  } // Expand intermediary graph\n\n\n  let graphNodes = Object.keys(graph);\n\n  for (let i = 0; i < graphNodes.length; ++i) {\n    const node = graphNodes[i];\n    const expandedGroups = [];\n    const graphNodeItems = Object.keys(graph[node]);\n\n    for (let j = 0; j < graphNodeItems.length; ++j) {\n      const group = graph[node][graphNodeItems[j]];\n      groups[group] = groups[group] || [];\n\n      for (let k = 0; k < groups[group].length; ++k) {\n        expandedGroups.push(groups[group][k]);\n      }\n    }\n\n    graph[node] = expandedGroups;\n  } // Merge intermediary graph using graphAfters into final graph\n\n\n  const afterNodes = Object.keys(graphAfters);\n\n  for (let i = 0; i < afterNodes.length; ++i) {\n    const group = afterNodes[i];\n\n    if (groups[group]) {\n      for (let j = 0; j < groups[group].length; ++j) {\n        const node = groups[group][j];\n        graph[node] = graph[node].concat(graphAfters[group]);\n      }\n    }\n  } // Compile ancestors\n\n\n  let children;\n  const ancestors = {};\n  graphNodes = Object.keys(graph);\n\n  for (let i = 0; i < graphNodes.length; ++i) {\n    const node = graphNodes[i];\n    children = graph[node];\n\n    for (let j = 0; j < children.length; ++j) {\n      ancestors[children[j]] = (ancestors[children[j]] || []).concat(node);\n    }\n  } // Topo sort\n\n\n  const visited = {};\n  const sorted = [];\n\n  for (let i = 0; i < this._items.length; ++i) {\n    let next = i;\n\n    if (ancestors[i]) {\n      next = null;\n\n      for (let j = 0; j < this._items.length; ++j) {\n        if (visited[j] === true) {\n          continue;\n        }\n\n        if (!ancestors[j]) {\n          ancestors[j] = [];\n        }\n\n        const shouldSeeCount = ancestors[j].length;\n        let seenCount = 0;\n\n        for (let k = 0; k < shouldSeeCount; ++k) {\n          if (sorted.indexOf(ancestors[j][k]) >= 0) {\n            ++seenCount;\n          }\n        }\n\n        if (seenCount === shouldSeeCount) {\n          next = j;\n          break;\n        }\n      }\n    }\n\n    if (next !== null) {\n      next = next.toString(); // Normalize to string TODO: replace with seq\n\n      visited[next] = true;\n      sorted.push(next);\n    }\n  }\n\n  if (sorted.length !== this._items.length) {\n    return new Error('Invalid dependencies');\n  }\n\n  const seqIndex = {};\n\n  for (let i = 0; i < this._items.length; ++i) {\n    const item = this._items[i];\n    seqIndex[item.seq] = item;\n  }\n\n  const sortedNodes = [];\n  this._items = sorted.map(value => {\n    const sortedItem = seqIndex[value];\n    sortedNodes.push(sortedItem.node);\n    return sortedItem;\n  });\n  this.nodes = sortedNodes;\n};","map":null,"metadata":{},"sourceType":"script"}