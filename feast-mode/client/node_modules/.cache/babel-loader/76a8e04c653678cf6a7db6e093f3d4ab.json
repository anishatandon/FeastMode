{"ast":null,"code":"'use strict'; // Load modules\n\nconst Crypto = require('crypto');\n\nconst Path = require('path');\n\nconst Util = require('util');\n\nconst Escape = require('./escape'); // Declare internals\n\n\nconst internals = {}; // Clone object or array\n\nexports.clone = function (obj, seen) {\n  if (typeof obj !== 'object' || obj === null) {\n    return obj;\n  }\n\n  seen = seen || new Map();\n  const lookup = seen.get(obj);\n\n  if (lookup) {\n    return lookup;\n  }\n\n  let newObj;\n  let cloneDeep = false;\n\n  if (!Array.isArray(obj)) {\n    if (Buffer.isBuffer(obj)) {\n      newObj = new Buffer(obj);\n    } else if (obj instanceof Date) {\n      newObj = new Date(obj.getTime());\n    } else if (obj instanceof RegExp) {\n      newObj = new RegExp(obj);\n    } else {\n      const proto = Object.getPrototypeOf(obj);\n\n      if (proto && proto.isImmutable) {\n        newObj = obj;\n      } else {\n        newObj = Object.create(proto);\n        cloneDeep = true;\n      }\n    }\n  } else {\n    newObj = [];\n    cloneDeep = true;\n  }\n\n  seen.set(obj, newObj);\n\n  if (cloneDeep) {\n    const keys = Object.getOwnPropertyNames(obj);\n\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n\n      if (descriptor && (descriptor.get || descriptor.set)) {\n        Object.defineProperty(newObj, key, descriptor);\n      } else {\n        newObj[key] = exports.clone(obj[key], seen);\n      }\n    }\n  }\n\n  return newObj;\n}; // Merge all the properties of source into target, source wins in conflict, and by default null and undefined from source are applied\n\n/*eslint-disable */\n\n\nexports.merge = function (target, source, isNullOverride\n/* = true */\n, isMergeArrays\n/* = true */\n) {\n  /*eslint-enable */\n  exports.assert(target && typeof target === 'object', 'Invalid target value: must be an object');\n  exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');\n\n  if (!source) {\n    return target;\n  }\n\n  if (Array.isArray(source)) {\n    exports.assert(Array.isArray(target), 'Cannot merge array onto an object');\n\n    if (isMergeArrays === false) {\n      // isMergeArrays defaults to true\n      target.length = 0; // Must not change target assignment\n    }\n\n    for (let i = 0; i < source.length; ++i) {\n      target.push(exports.clone(source[i]));\n    }\n\n    return target;\n  }\n\n  const keys = Object.keys(source);\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n\n    if (key === '__proto__') {\n      continue;\n    }\n\n    const value = source[key];\n\n    if (value && typeof value === 'object') {\n      if (!target[key] || typeof target[key] !== 'object' || Array.isArray(target[key]) !== Array.isArray(value) || value instanceof Date || Buffer.isBuffer(value) || value instanceof RegExp) {\n        target[key] = exports.clone(value);\n      } else {\n        exports.merge(target[key], value, isNullOverride, isMergeArrays);\n      }\n    } else {\n      if (value !== null && value !== undefined) {\n        // Explicit to preserve empty strings\n        target[key] = value;\n      } else if (isNullOverride !== false) {\n        // Defaults to true\n        target[key] = value;\n      }\n    }\n  }\n\n  return target;\n}; // Apply options to a copy of the defaults\n\n\nexports.applyToDefaults = function (defaults, options, isNullOverride) {\n  exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n  exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');\n\n  if (!options) {\n    // If no options, return null\n    return null;\n  }\n\n  const copy = exports.clone(defaults);\n\n  if (options === true) {\n    // If options is set to true, use defaults\n    return copy;\n  }\n\n  return exports.merge(copy, options, isNullOverride === true, false);\n}; // Clone an object except for the listed keys which are shallow copied\n\n\nexports.cloneWithShallow = function (source, keys) {\n  if (!source || typeof source !== 'object') {\n    return source;\n  }\n\n  const storage = internals.store(source, keys); // Move shallow copy items to storage\n\n  const copy = exports.clone(source); // Deep copy the rest\n\n  internals.restore(copy, source, storage); // Shallow copy the stored items and restore\n\n  return copy;\n};\n\ninternals.store = function (source, keys) {\n  const storage = {};\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    const value = exports.reach(source, key);\n\n    if (value !== undefined) {\n      storage[key] = value;\n      internals.reachSet(source, key, undefined);\n    }\n  }\n\n  return storage;\n};\n\ninternals.restore = function (copy, source, storage) {\n  const keys = Object.keys(storage);\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    internals.reachSet(copy, key, storage[key]);\n    internals.reachSet(source, key, storage[key]);\n  }\n};\n\ninternals.reachSet = function (obj, key, value) {\n  const path = key.split('.');\n  let ref = obj;\n\n  for (let i = 0; i < path.length; ++i) {\n    const segment = path[i];\n\n    if (i + 1 === path.length) {\n      ref[segment] = value;\n    }\n\n    ref = ref[segment];\n  }\n}; // Apply options to defaults except for the listed keys which are shallow copied from option without merging\n\n\nexports.applyToDefaultsWithShallow = function (defaults, options, keys) {\n  exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n  exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');\n  exports.assert(keys && Array.isArray(keys), 'Invalid keys');\n\n  if (!options) {\n    // If no options, return null\n    return null;\n  }\n\n  const copy = exports.cloneWithShallow(defaults, keys);\n\n  if (options === true) {\n    // If options is set to true, use defaults\n    return copy;\n  }\n\n  const storage = internals.store(options, keys); // Move shallow copy items to storage\n\n  exports.merge(copy, options, false, false); // Deep copy the rest\n\n  internals.restore(copy, options, storage); // Shallow copy the stored items and restore\n\n  return copy;\n}; // Deep object or array comparison\n\n\nexports.deepEqual = function (obj, ref, options, seen) {\n  options = options || {\n    prototype: true\n  };\n  const type = typeof obj;\n\n  if (type !== typeof ref) {\n    return false;\n  }\n\n  if (type !== 'object' || obj === null || ref === null) {\n    if (obj === ref) {\n      // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql\n      return obj !== 0 || 1 / obj === 1 / ref; // -0 / +0\n    }\n\n    return obj !== obj && ref !== ref; // NaN\n  }\n\n  seen = seen || [];\n\n  if (seen.indexOf(obj) !== -1) {\n    return true; // If previous comparison failed, it would have stopped execution\n  }\n\n  seen.push(obj);\n\n  if (Array.isArray(obj)) {\n    if (!Array.isArray(ref)) {\n      return false;\n    }\n\n    if (!options.part && obj.length !== ref.length) {\n      return false;\n    }\n\n    for (let i = 0; i < obj.length; ++i) {\n      if (options.part) {\n        let found = false;\n\n        for (let j = 0; j < ref.length; ++j) {\n          if (exports.deepEqual(obj[i], ref[j], options)) {\n            found = true;\n            break;\n          }\n        }\n\n        return found;\n      }\n\n      if (!exports.deepEqual(obj[i], ref[i], options)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (Buffer.isBuffer(obj)) {\n    if (!Buffer.isBuffer(ref)) {\n      return false;\n    }\n\n    if (obj.length !== ref.length) {\n      return false;\n    }\n\n    for (let i = 0; i < obj.length; ++i) {\n      if (obj[i] !== ref[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (obj instanceof Date) {\n    return ref instanceof Date && obj.getTime() === ref.getTime();\n  }\n\n  if (obj instanceof RegExp) {\n    return ref instanceof RegExp && obj.toString() === ref.toString();\n  }\n\n  if (options.prototype) {\n    if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {\n      return false;\n    }\n  }\n\n  const keys = Object.getOwnPropertyNames(obj);\n\n  if (!options.part && keys.length !== Object.getOwnPropertyNames(ref).length) {\n    return false;\n  }\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n\n    if (descriptor.get) {\n      if (!exports.deepEqual(descriptor, Object.getOwnPropertyDescriptor(ref, key), options, seen)) {\n        return false;\n      }\n    } else if (!exports.deepEqual(obj[key], ref[key], options, seen)) {\n      return false;\n    }\n  }\n\n  return true;\n}; // Remove duplicate items from array\n\n\nexports.unique = (array, key) => {\n  let result;\n\n  if (key) {\n    result = [];\n    const index = new Set();\n    array.forEach(item => {\n      const identifier = item[key];\n\n      if (!index.has(identifier)) {\n        index.add(identifier);\n        result.push(item);\n      }\n    });\n  } else {\n    result = Array.from(new Set(array));\n  }\n\n  return result;\n}; // Convert array into object\n\n\nexports.mapToObject = function (array, key) {\n  if (!array) {\n    return null;\n  }\n\n  const obj = {};\n\n  for (let i = 0; i < array.length; ++i) {\n    if (key) {\n      if (array[i][key]) {\n        obj[array[i][key]] = true;\n      }\n    } else {\n      obj[array[i]] = true;\n    }\n  }\n\n  return obj;\n}; // Find the common unique items in two arrays\n\n\nexports.intersect = function (array1, array2, justFirst) {\n  if (!array1 || !array2) {\n    return [];\n  }\n\n  const common = [];\n  const hash = Array.isArray(array1) ? exports.mapToObject(array1) : array1;\n  const found = {};\n\n  for (let i = 0; i < array2.length; ++i) {\n    if (hash[array2[i]] && !found[array2[i]]) {\n      if (justFirst) {\n        return array2[i];\n      }\n\n      common.push(array2[i]);\n      found[array2[i]] = true;\n    }\n  }\n\n  return justFirst ? null : common;\n}; // Test if the reference contains the values\n\n\nexports.contain = function (ref, values, options) {\n  /*\n      string -> string(s)\n      array -> item(s)\n      object -> key(s)\n      object -> object (key:value)\n  */\n  let valuePairs = null;\n\n  if (typeof ref === 'object' && typeof values === 'object' && !Array.isArray(ref) && !Array.isArray(values)) {\n    valuePairs = values;\n    values = Object.keys(values);\n  } else {\n    values = [].concat(values);\n  }\n\n  options = options || {}; // deep, once, only, part\n\n  exports.assert(arguments.length >= 2, 'Insufficient arguments');\n  exports.assert(typeof ref === 'string' || typeof ref === 'object', 'Reference must be string or an object');\n  exports.assert(values.length, 'Values array cannot be empty');\n  let compare;\n  let compareFlags;\n\n  if (options.deep) {\n    compare = exports.deepEqual;\n    const hasOnly = options.hasOwnProperty('only');\n    const hasPart = options.hasOwnProperty('part');\n    compareFlags = {\n      prototype: hasOnly ? options.only : hasPart ? !options.part : false,\n      part: hasOnly ? !options.only : hasPart ? options.part : true\n    };\n  } else {\n    compare = (a, b) => a === b;\n  }\n\n  let misses = false;\n  const matches = new Array(values.length);\n\n  for (let i = 0; i < matches.length; ++i) {\n    matches[i] = 0;\n  }\n\n  if (typeof ref === 'string') {\n    let pattern = '(';\n\n    for (let i = 0; i < values.length; ++i) {\n      const value = values[i];\n      exports.assert(typeof value === 'string', 'Cannot compare string reference to non-string value');\n      pattern += (i ? '|' : '') + exports.escapeRegex(value);\n    }\n\n    const regex = new RegExp(pattern + ')', 'g');\n    const leftovers = ref.replace(regex, ($0, $1) => {\n      const index = values.indexOf($1);\n      ++matches[index];\n      return ''; // Remove from string\n    });\n    misses = !!leftovers;\n  } else if (Array.isArray(ref)) {\n    for (let i = 0; i < ref.length; ++i) {\n      let matched = false;\n\n      for (let j = 0; j < values.length && matched === false; ++j) {\n        matched = compare(values[j], ref[i], compareFlags) && j;\n      }\n\n      if (matched !== false) {\n        ++matches[matched];\n      } else {\n        misses = true;\n      }\n    }\n  } else {\n    const keys = Object.getOwnPropertyNames(ref);\n\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      const pos = values.indexOf(key);\n\n      if (pos !== -1) {\n        if (valuePairs && !compare(valuePairs[key], ref[key], compareFlags)) {\n          return false;\n        }\n\n        ++matches[pos];\n      } else {\n        misses = true;\n      }\n    }\n  }\n\n  let result = false;\n\n  for (let i = 0; i < matches.length; ++i) {\n    result = result || !!matches[i];\n\n    if (options.once && matches[i] > 1 || !options.part && !matches[i]) {\n      return false;\n    }\n  }\n\n  if (options.only && misses) {\n    return false;\n  }\n\n  return result;\n}; // Flatten array\n\n\nexports.flatten = function (array, target) {\n  const result = target || [];\n\n  for (let i = 0; i < array.length; ++i) {\n    if (Array.isArray(array[i])) {\n      exports.flatten(array[i], result);\n    } else {\n      result.push(array[i]);\n    }\n  }\n\n  return result;\n}; // Convert an object key chain string ('a.b.c') to reference (object[a][b][c])\n\n\nexports.reach = function (obj, chain, options) {\n  if (chain === false || chain === null || typeof chain === 'undefined') {\n    return obj;\n  }\n\n  options = options || {};\n\n  if (typeof options === 'string') {\n    options = {\n      separator: options\n    };\n  }\n\n  const path = chain.split(options.separator || '.');\n  let ref = obj;\n\n  for (let i = 0; i < path.length; ++i) {\n    let key = path[i];\n\n    if (key[0] === '-' && Array.isArray(ref)) {\n      key = key.slice(1, key.length);\n      key = ref.length - key;\n    }\n\n    if (!ref || !((typeof ref === 'object' || typeof ref === 'function') && key in ref) || typeof ref !== 'object' && options.functions === false) {\n      // Only object and function can have properties\n      exports.assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);\n      exports.assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);\n      ref = options.default;\n      break;\n    }\n\n    ref = ref[key];\n  }\n\n  return ref;\n};\n\nexports.reachTemplate = function (obj, template, options) {\n  return template.replace(/{([^}]+)}/g, ($0, chain) => {\n    const value = exports.reach(obj, chain, options);\n    return value === undefined || value === null ? '' : value;\n  });\n};\n\nexports.formatStack = function (stack) {\n  const trace = [];\n\n  for (let i = 0; i < stack.length; ++i) {\n    const item = stack[i];\n    trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);\n  }\n\n  return trace;\n};\n\nexports.formatTrace = function (trace) {\n  const display = [];\n\n  for (let i = 0; i < trace.length; ++i) {\n    const row = trace[i];\n    display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');\n  }\n\n  return display;\n};\n\nexports.callStack = function (slice) {\n  // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n  const v8 = Error.prepareStackTrace;\n\n  Error.prepareStackTrace = function (_, stack) {\n    return stack;\n  };\n\n  const capture = {};\n  Error.captureStackTrace(capture, this); // arguments.callee is not supported in strict mode so we use this and slice the trace of this off the result\n\n  const stack = capture.stack;\n  Error.prepareStackTrace = v8;\n  const trace = exports.formatStack(stack);\n  return trace.slice(1 + slice);\n};\n\nexports.displayStack = function (slice) {\n  const trace = exports.callStack(slice === undefined ? 1 : slice + 1);\n  return exports.formatTrace(trace);\n};\n\nexports.abortThrow = false;\n\nexports.abort = function (message, hideStack) {\n  if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {\n    throw new Error(message || 'Unknown error');\n  }\n\n  let stack = '';\n\n  if (!hideStack) {\n    stack = exports.displayStack(1).join('\\n\\t');\n  }\n\n  console.log('ABORT: ' + message + '\\n\\t' + stack);\n  process.exit(1);\n};\n\nexports.assert = function (condition\n/*, msg1, msg2, msg3 */\n) {\n  if (condition) {\n    return;\n  }\n\n  if (arguments.length === 2 && arguments[1] instanceof Error) {\n    throw arguments[1];\n  }\n\n  let msgs = [];\n\n  for (let i = 1; i < arguments.length; ++i) {\n    if (arguments[i] !== '') {\n      msgs.push(arguments[i]); // Avoids Array.slice arguments leak, allowing for V8 optimizations\n    }\n  }\n\n  msgs = msgs.map(msg => {\n    return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : exports.stringify(msg);\n  });\n  throw new Error(msgs.join(' ') || 'Unknown error');\n};\n\nexports.Timer = function () {\n  this.ts = 0;\n  this.reset();\n};\n\nexports.Timer.prototype.reset = function () {\n  this.ts = Date.now();\n};\n\nexports.Timer.prototype.elapsed = function () {\n  return Date.now() - this.ts;\n};\n\nexports.Bench = function () {\n  this.ts = 0;\n  this.reset();\n};\n\nexports.Bench.prototype.reset = function () {\n  this.ts = exports.Bench.now();\n};\n\nexports.Bench.prototype.elapsed = function () {\n  return exports.Bench.now() - this.ts;\n};\n\nexports.Bench.now = function () {\n  const ts = process.hrtime();\n  return ts[0] * 1e3 + ts[1] / 1e6;\n}; // Escape string for Regex construction\n\n\nexports.escapeRegex = function (string) {\n  // Escape ^$.*+-?=!:|\\/()[]{},\n  return string.replace(/[\\^\\$\\.\\*\\+\\-\\?\\=\\!\\:\\|\\\\\\/\\(\\)\\[\\]\\{\\}\\,]/g, '\\\\$&');\n}; // Base64url (RFC 4648) encode\n\n\nexports.base64urlEncode = function (value, encoding) {\n  exports.assert(typeof value === 'string' || Buffer.isBuffer(value), 'value must be string or buffer');\n  const buf = Buffer.isBuffer(value) ? value : new Buffer(value, encoding || 'binary');\n  return buf.toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=/g, '');\n}; // Base64url (RFC 4648) decode\n\n\nexports.base64urlDecode = function (value, encoding) {\n  if (typeof value !== 'string') {\n    return new Error('Value not a string');\n  }\n\n  if (!/^[\\w\\-]*$/.test(value)) {\n    return new Error('Invalid character');\n  }\n\n  const buf = new Buffer(value, 'base64');\n  return encoding === 'buffer' ? buf : buf.toString(encoding || 'binary');\n}; // Escape attribute value for use in HTTP header\n\n\nexports.escapeHeaderAttribute = function (attribute) {\n  // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \\, \"\n  exports.assert(/^[ \\w\\!#\\$%&'\\(\\)\\*\\+,\\-\\.\\/\\:;<\\=>\\?@\\[\\]\\^`\\{\\|\\}~\\\"\\\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');\n  return attribute.replace(/\\\\/g, '\\\\\\\\').replace(/\\\"/g, '\\\\\"'); // Escape quotes and slash\n};\n\nexports.escapeHtml = function (string) {\n  return Escape.escapeHtml(string);\n};\n\nexports.escapeJavaScript = function (string) {\n  return Escape.escapeJavaScript(string);\n};\n\nexports.escapeJson = function (string) {\n  return Escape.escapeJson(string);\n};\n\nexports.nextTick = function (callback) {\n  return function () {\n    const args = arguments;\n    process.nextTick(() => {\n      callback.apply(null, args);\n    });\n  };\n};\n\nexports.once = function (method) {\n  if (method._hoekOnce) {\n    return method;\n  }\n\n  let once = false;\n\n  const wrapped = function () {\n    if (!once) {\n      once = true;\n      method.apply(null, arguments);\n    }\n  };\n\n  wrapped._hoekOnce = true;\n  return wrapped;\n};\n\nexports.isInteger = Number.isSafeInteger;\n\nexports.ignore = function () {};\n\nexports.inherits = Util.inherits;\nexports.format = Util.format;\n\nexports.transform = function (source, transform, options) {\n  exports.assert(source === null || source === undefined || typeof source === 'object' || Array.isArray(source), 'Invalid source object: must be null, undefined, an object, or an array');\n  const separator = typeof options === 'object' && options !== null ? options.separator || '.' : '.';\n\n  if (Array.isArray(source)) {\n    const results = [];\n\n    for (let i = 0; i < source.length; ++i) {\n      results.push(exports.transform(source[i], transform, options));\n    }\n\n    return results;\n  }\n\n  const result = {};\n  const keys = Object.keys(transform);\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    const path = key.split(separator);\n    const sourcePath = transform[key];\n    exports.assert(typeof sourcePath === 'string', 'All mappings must be \".\" delineated strings');\n    let segment;\n    let res = result;\n\n    while (path.length > 1) {\n      segment = path.shift();\n\n      if (!res[segment]) {\n        res[segment] = {};\n      }\n\n      res = res[segment];\n    }\n\n    segment = path.shift();\n    res[segment] = exports.reach(source, sourcePath, options);\n  }\n\n  return result;\n};\n\nexports.uniqueFilename = function (path, extension) {\n  if (extension) {\n    extension = extension[0] !== '.' ? '.' + extension : extension;\n  } else {\n    extension = '';\n  }\n\n  path = Path.resolve(path);\n  const name = [Date.now(), process.pid, Crypto.randomBytes(8).toString('hex')].join('-') + extension;\n  return Path.join(path, name);\n};\n\nexports.stringify = function () {\n  try {\n    return JSON.stringify.apply(null, arguments);\n  } catch (err) {\n    return '[Cannot display object: ' + err.message + ']';\n  }\n};\n\nexports.shallow = function (source) {\n  const target = {};\n  const keys = Object.keys(source);\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    target[key] = source[key];\n  }\n\n  return target;\n};","map":null,"metadata":{},"sourceType":"script"}