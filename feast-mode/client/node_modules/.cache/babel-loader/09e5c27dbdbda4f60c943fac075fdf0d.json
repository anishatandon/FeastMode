{"ast":null,"code":"'use strict'; // Load modules\n\nconst Any = require('./any');\n\nconst Ref = require('./ref');\n\nconst Hoek = require('hoek');\n\nconst Moment = require('moment'); // Declare internals\n\n\nconst internals = {};\ninternals.isoDate = /^(?:\\d{4}(?!\\d{2}\\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\\1(?:[12]\\d|0[1-9]|3[01]))?|W(?:[0-4]\\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\\d|[12]\\d{2}|3(?:[0-5]\\d|6[1-6])))(?![T]$|[T][\\d]+Z$)(?:[T\\s](?:(?:(?:[01]\\d|2[0-3])(?:(:?)[0-5]\\d)?|24\\:?00)(?:[.,]\\d+(?!:))?)(?:\\2[0-5]\\d(?:[.,]\\d+)?)?(?:[Z]|(?:[+-])(?:[01]\\d|2[0-3])(?::?[0-5]\\d)?)?)?)?$/;\ninternals.invalidDate = new Date('');\n\ninternals.isIsoDate = (() => {\n  const isoString = internals.isoDate.toString();\n  return date => {\n    return date && date.toString() === isoString;\n  };\n})();\n\ninternals.Date = class extends Any {\n  constructor() {\n    super();\n    this._type = 'date';\n  }\n\n  _base(value, state, options) {\n    const result = {\n      value: options.convert && internals.Date.toDate(value, this._flags.format, this._flags.timestamp, this._flags.multiplier) || value\n    };\n\n    if (result.value instanceof Date && !isNaN(result.value.getTime())) {\n      result.errors = null;\n    } else if (!options.convert) {\n      result.errors = this.createError('date.strict', null, state, options);\n    } else {\n      let context = null;\n      let type;\n\n      if (internals.isIsoDate(this._flags.format)) {\n        type = 'isoDate';\n      } else if (this._flags.timestamp) {\n        type = 'timestamp.' + this._flags.timestamp;\n      } else if (this._flags.format) {\n        type = 'format';\n        context = {\n          format: this._flags.format\n        };\n      } else {\n        type = 'base';\n      }\n\n      result.errors = this.createError('date.' + type, context, state, options);\n    }\n\n    return result;\n  }\n\n  static toDate(value, format, timestamp, multiplier) {\n    if (value instanceof Date) {\n      return value;\n    }\n\n    if (typeof value === 'string' || typeof value === 'number' && !isNaN(value) && isFinite(value)) {\n      if (typeof value === 'string' && /^[+-]?\\d+(\\.\\d+)?$/.test(value)) {\n        value = parseFloat(value);\n      }\n\n      let date;\n\n      if (format) {\n        if (internals.isIsoDate(format)) {\n          date = format.test(value) ? new Date(value) : internals.invalidDate;\n        } else {\n          date = Moment(value, format, true);\n          date = date.isValid() ? date.toDate() : internals.invalidDate;\n        }\n      } else if (timestamp && multiplier) {\n        date = new Date(value * multiplier);\n      } else {\n        date = new Date(value);\n      }\n\n      if (!isNaN(date.getTime())) {\n        return date;\n      }\n    }\n\n    return null;\n  }\n\n  format(format) {\n    Hoek.assert(typeof format === 'string' || Array.isArray(format) && format.every(f => typeof f === 'string'), 'Invalid format.');\n    const obj = this.clone();\n    obj._flags.format = format;\n    return obj;\n  }\n\n  iso() {\n    const obj = this.clone();\n    obj._flags.format = internals.isoDate;\n    return obj;\n  }\n\n  timestamp(type) {\n    type = type || 'javascript';\n    const allowed = ['javascript', 'unix'];\n    Hoek.assert(allowed.indexOf(type) !== -1, '\"type\" must be one of \"' + allowed.join('\", \"') + '\"');\n    const obj = this.clone();\n    obj._flags.timestamp = type;\n    obj._flags.multiplier = type === 'unix' ? 1000 : 1;\n    return obj;\n  }\n\n  _isIsoDate(value) {\n    return internals.isoDate.test(value);\n  }\n\n};\n\ninternals.compare = function (type, compare) {\n  return function (date) {\n    const isNow = date === 'now';\n    const isRef = Ref.isRef(date);\n\n    if (!isNow && !isRef) {\n      date = internals.Date.toDate(date);\n    }\n\n    Hoek.assert(date, 'Invalid date format');\n    return this._test(type, date, function (value, state, options) {\n      let compareTo;\n\n      if (isNow) {\n        compareTo = Date.now();\n      } else if (isRef) {\n        compareTo = internals.Date.toDate(date(state.parent, options));\n\n        if (!compareTo) {\n          return this.createError('date.ref', {\n            ref: date.key\n          }, state, options);\n        }\n\n        compareTo = compareTo.getTime();\n      } else {\n        compareTo = date.getTime();\n      }\n\n      if (compare(value.getTime(), compareTo)) {\n        return value;\n      }\n\n      return this.createError('date.' + type, {\n        limit: new Date(compareTo)\n      }, state, options);\n    });\n  };\n};\n\ninternals.Date.prototype.min = internals.compare('min', (value, date) => value >= date);\ninternals.Date.prototype.max = internals.compare('max', (value, date) => value <= date);\nmodule.exports = new internals.Date();","map":null,"metadata":{},"sourceType":"script"}