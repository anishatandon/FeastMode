{"ast":null,"code":"'use strict'; // Load modules\n\nconst Hoek = require('hoek');\n\nconst Language = require('./language'); // Declare internals\n\n\nconst internals = {};\n\ninternals.stringify = function (value, wrapArrays) {\n  const type = typeof value;\n\n  if (value === null) {\n    return 'null';\n  }\n\n  if (type === 'string') {\n    return value;\n  }\n\n  if (value instanceof exports.Err || type === 'function') {\n    return value.toString();\n  }\n\n  if (type === 'object') {\n    if (Array.isArray(value)) {\n      let partial = '';\n\n      for (let i = 0; i < value.length; ++i) {\n        partial = partial + (partial.length ? ', ' : '') + internals.stringify(value[i], wrapArrays);\n      }\n\n      return wrapArrays ? '[' + partial + ']' : partial;\n    }\n\n    return value.toString();\n  }\n\n  return JSON.stringify(value);\n};\n\nexports.Err = class {\n  constructor(type, context, state, options, flags) {\n    this.isJoi = true;\n    this.type = type;\n    this.context = context || {};\n    this.context.key = state.key;\n    this.path = state.path;\n    this.options = options;\n    this.flags = flags;\n  }\n\n  toString() {\n    const localized = this.options.language;\n\n    if (this.flags.label) {\n      this.context.key = this.flags.label;\n    } else if (this.context.key === '' || this.context.key === null) {\n      this.context.key = localized.root || Language.errors.root;\n    }\n\n    let format = Hoek.reach(localized, this.type) || Hoek.reach(Language.errors, this.type);\n    const hasKey = /\\{\\{\\!?key\\}\\}/.test(format);\n    const skipKey = format.length > 2 && format[0] === '!' && format[1] === '!';\n\n    if (skipKey) {\n      format = format.slice(2);\n    }\n\n    if (!hasKey && !skipKey) {\n      format = (Hoek.reach(localized, 'key') || Hoek.reach(Language.errors, 'key')) + format;\n    }\n\n    let wrapArrays = Hoek.reach(localized, 'messages.wrapArrays');\n\n    if (typeof wrapArrays !== 'boolean') {\n      wrapArrays = Language.errors.messages.wrapArrays;\n    }\n\n    return format.replace(/\\{\\{(\\!?)([^}]+)\\}\\}/g, ($0, isSecure, name) => {\n      const value = Hoek.reach(this.context, name);\n      const normalized = internals.stringify(value, wrapArrays);\n      return isSecure ? Hoek.escapeHtml(normalized) : normalized;\n    });\n  }\n\n};\n\nexports.create = function (type, context, state, options, flags) {\n  return new exports.Err(type, context, state, options, flags);\n};\n\nexports.process = function (errors, object) {\n  if (!errors || !errors.length) {\n    return null;\n  } // Construct error\n\n\n  let message = '';\n  const details = [];\n\n  const processErrors = function (localErrors, parent) {\n    for (let i = 0; i < localErrors.length; ++i) {\n      const item = localErrors[i];\n\n      if (item.flags.error) {\n        return item.flags.error;\n      }\n\n      let itemMessage;\n\n      if (parent === undefined) {\n        itemMessage = item.toString();\n        message = message + (message ? '. ' : '') + itemMessage;\n      } // Do not push intermediate errors, we're only interested in leafs\n\n\n      if (item.context.reason && item.context.reason.length) {\n        const override = processErrors(item.context.reason, item.path);\n\n        if (override) {\n          return override;\n        }\n      } else {\n        details.push({\n          message: itemMessage || item.toString(),\n          path: internals.getPath(item),\n          type: item.type,\n          context: item.context\n        });\n      }\n    }\n  };\n\n  const override = processErrors(errors);\n\n  if (override) {\n    return override;\n  }\n\n  const error = new Error(message);\n  error.isJoi = true;\n  error.name = 'ValidationError';\n  error.details = details;\n  error._object = object;\n  error.annotate = internals.annotate;\n  return error;\n};\n\ninternals.getPath = function (item) {\n  return item.path || item.context.key;\n}; // Inspired by json-stringify-safe\n\n\ninternals.safeStringify = function (obj, spaces) {\n  return JSON.stringify(obj, internals.serializer(), spaces);\n};\n\ninternals.serializer = function () {\n  const keys = [];\n  const stack = [];\n\n  const cycleReplacer = (key, value) => {\n    if (stack[0] === value) {\n      return '[Circular ~]';\n    }\n\n    return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';\n  };\n\n  return function (key, value) {\n    if (stack.length > 0) {\n      const thisPos = stack.indexOf(this);\n\n      if (~thisPos) {\n        stack.length = thisPos + 1;\n        keys.length = thisPos + 1;\n        keys[thisPos] = key;\n      } else {\n        stack.push(this);\n        keys.push(key);\n      }\n\n      if (~stack.indexOf(value)) {\n        value = cycleReplacer.call(this, key, value);\n      }\n    } else {\n      stack.push(value);\n    }\n\n    if (Array.isArray(value) && value.placeholders) {\n      const placeholders = value.placeholders;\n      const arrWithPlaceholders = [];\n\n      for (let i = 0; i < value.length; ++i) {\n        if (placeholders[i]) {\n          arrWithPlaceholders.push(placeholders[i]);\n        }\n\n        arrWithPlaceholders.push(value[i]);\n      }\n\n      value = arrWithPlaceholders;\n    }\n\n    if (value === Infinity || value === -Infinity || Number.isNaN(value) || typeof value === 'function' || typeof value === 'symbol') {\n      return '[' + value.toString() + ']';\n    }\n\n    return value;\n  };\n};\n\ninternals.annotate = function (stripColorCodes) {\n  const redFgEscape = stripColorCodes ? '' : '\\u001b[31m';\n  const redBgEscape = stripColorCodes ? '' : '\\u001b[41m';\n  const endColor = stripColorCodes ? '' : '\\u001b[0m';\n\n  if (typeof this._object !== 'object') {\n    return this.details[0].message;\n  }\n\n  const obj = Hoek.clone(this._object || {});\n  const lookup = {};\n\n  for (let i = this.details.length - 1; i >= 0; --i) {\n    // Reverse order to process deepest child first\n    const pos = i + 1;\n    const error = this.details[i];\n    const path = error.path.split('.');\n    let ref = obj;\n\n    for (let j = 0; j < path.length && ref; ++j) {\n      const seg = path[j];\n\n      if (j + 1 < path.length) {\n        ref = ref[seg];\n      } else {\n        const value = ref[seg];\n\n        if (Array.isArray(ref)) {\n          const arrayLabel = \"_$idx$_\".concat(pos, \"_$end$_\");\n\n          if (!ref.placeholders) {\n            ref.placeholders = {};\n          }\n\n          if (ref.placeholders[seg]) {\n            ref.placeholders[seg] = ref.placeholders[seg].replace('_$end$_', \", \".concat(pos, \"_$end$_\"));\n          } else {\n            ref.placeholders[seg] = arrayLabel;\n          }\n        } else {\n          if (value !== undefined) {\n            delete ref[seg];\n            const objectLabel = \"\".concat(seg, \"_$key$_\").concat(pos, \"_$end$_\");\n            ref[objectLabel] = value;\n            lookup[error.path] = objectLabel;\n          } else if (lookup[error.path]) {\n            const replacement = lookup[error.path];\n            const appended = replacement.replace('_$end$_', \", \".concat(pos, \"_$end$_\"));\n            ref[appended] = ref[replacement];\n            lookup[error.path] = appended;\n            delete ref[replacement];\n          } else {\n            ref[\"_$miss$_\".concat(seg, \"|\").concat(pos, \"_$end$_\")] = '__missing__';\n          }\n        }\n      }\n    }\n  }\n\n  const replacers = {\n    key: /_\\$key\\$_([, \\d]+)_\\$end\\$_\\\"/g,\n    missing: /\\\"_\\$miss\\$_([^\\|]+)\\|(\\d+)_\\$end\\$_\\\"\\: \\\"__missing__\\\"/g,\n    arrayIndex: /\\s*\\\"_\\$idx\\$_([, \\d]+)_\\$end\\$_\\\",?\\n(.*)/g,\n    specials: /\"\\[(NaN|Symbol.*|-?Infinity|function.*|\\(.*)\\]\"/g\n  };\n  let message = internals.safeStringify(obj, 2).replace(replacers.key, ($0, $1) => \"\\\" \".concat(redFgEscape, \"[\").concat($1, \"]\").concat(endColor)).replace(replacers.missing, ($0, $1, $2) => \"\".concat(redBgEscape, \"\\\"\").concat($1, \"\\\"\").concat(endColor).concat(redFgEscape, \" [\").concat($2, \"]: -- missing --\").concat(endColor)).replace(replacers.arrayIndex, ($0, $1, $2) => \"\\n\".concat($2, \" \").concat(redFgEscape, \"[\").concat($1, \"]\").concat(endColor)).replace(replacers.specials, ($0, $1) => $1);\n  message = \"\".concat(message, \"\\n\").concat(redFgEscape);\n\n  for (let i = 0; i < this.details.length; ++i) {\n    const pos = i + 1;\n    message = \"\".concat(message, \"\\n[\").concat(pos, \"] \").concat(this.details[i].message);\n  }\n\n  message = message + endColor;\n  return message;\n};","map":null,"metadata":{},"sourceType":"script"}