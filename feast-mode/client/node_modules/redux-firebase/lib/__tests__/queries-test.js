'use strict';

var _immutable = require('immutable');

jest.dontMock('../queries').dontMock('../resolvers').dontMock('../types');

describe('queries', function () {
  var queries = undefined;
  var resolvers = undefined;
  var types = undefined;

  var mockCache = undefined;
  var mockState = undefined;

  beforeEach(function () {
    var _mockState;

    queries = require('../queries');
    resolvers = require('../resolvers');
    types = require('../types');

    mockCache = _immutable.fromJS({
      one: {
        two: 3
      }
    });
    mockState = (_mockState = {}, _mockState[queries.CACHE_KEY] = mockCache, _mockState.testing = 'omg', _mockState);
  });

  it('gets the cache from store state', function () {
    var _queries = queries;
    var getCache = _queries.getCache;

    expect(getCache(mockState).equals(mockCache)).toBe(true);
  });

  it('flattens queries', function () {
    var _queries2 = queries;
    var flatten = _queries2.flatten;

    var mockFn = function mockFn() {};
    var mockQuery = _immutable.fromJS({ one: { two: mockFn } });
    expect(flatten(mockQuery).toArray()).toEqual([[['one', 'two'], mockFn]]);
  });

  it('correctly checks if a query isLoading', function () {
    var _queries3 = queries;
    var isLoading = _queries3.isLoading;
    var resolve = _queries3.resolve;
    var _resolvers = resolvers;
    var value = _resolvers.value;

    expect(isLoading(resolve(function () {
      return { one: { two: value } };
    }, mockState))).toEqual(false);
    expect(isLoading(resolve(function () {
      return { three: { four: value } };
    }, mockState))).toEqual(true);
  });

  it('hydrates a query funtion', function () {
    var _queries4 = queries;
    var hydrate = _queries4.hydrate;
    var _resolvers2 = resolvers;
    var value = _resolvers2.value;

    var query = function query(_ref2, _ref3) {
      var testing = _ref2.testing;

      var _ref;

      var myProp = _ref3.myProp;
      return _ref = {}, _ref[testing] = { wow: value }, _ref[myProp] = { frosted: value }, _ref;
    };
    expect(hydrate(query, mockState, { myProp: 'butts' }).toArray()).toEqual([[['omg', 'wow'], value], [['butts', 'frosted'], value]]);
  });

  it('resolves a query against a cache', function () {
    var _queries5 = queries;
    var resolve = _queries5.resolve;
    var _resolvers3 = resolvers;
    var value = _resolvers3.value;

    var query = function query() {
      return { one: { two: value } };
    };
    expect(resolve(query, mockState).toJS()).toEqual({
      one: {
        two: 3
      }
    });
  });

  it('returns UNRESOLVED for uncached paths', function () {
    var _queries6 = queries;
    var resolve = _queries6.resolve;
    var _resolvers4 = resolvers;
    var value = _resolvers4.value;
    var _types = types;
    var UNRESOLVED = _types.UNRESOLVED;

    var query = function query() {
      return { one: { other: value } };
    };
    expect(resolve(query, mockState).toJS()).toEqual({
      one: {
        other: UNRESOLVED.toJS()
      }
    });
  });

  it('extracts subscriptions', function () {
    var _queries7 = queries;
    var subscriptions = _queries7.subscriptions;
    var _resolvers5 = resolvers;
    var value = _resolvers5.value;

    var query = function query() {
      return {
        one: { two: value },
        three: {
          four: { five: value }
        }
      };
    };
    expect(subscriptions(query).toJS()).toEqual([['one', 'two'], ['three', 'four', 'five']]);
  });
});