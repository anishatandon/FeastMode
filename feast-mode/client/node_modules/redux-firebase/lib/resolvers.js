'use strict';

exports.__esModule = true;
exports.byIndex = byIndex;
exports.value = value;
exports.get = get;
exports.getIn = getIn;
exports.index = index;
exports.key = key;

var _immutable = require('immutable');

var _types = require('./types');

var emptyResolver = _types.Resolver();

function cget(cache, path) {
  if (cache.hasIn(path)) {
    return cache.getIn(path);
  }
  return _types.UNRESOLVED;
}

function byIndex(pathToIndex) {
  pathToIndex = _immutable.List(pathToIndex);
  return emptyResolver.merge({
    subscriptions: function subscriptions(_, keyPath, cache) {
      var indexVal = cget(cache, pathToIndex);
      if (_types.isUnresolved(indexVal)) {
        return [pathToIndex];
      }
      return indexVal ? indexVal.keySeq().map(function (id) {
        return keyPath.push(id);
      }).concat([pathToIndex]).toSet() : _immutable.Set();
    },
    resolve: function resolve(allItems, cache) {
      var indexVal = cget(cache, pathToIndex);
      if (_types.isUnresolved(indexVal)) {
        return _types.UNRESOLVED;
      }
      return indexVal ? indexVal.map(function (_, id) {
        var res = cget(allItems, [id]);
        if (!res) {
          return res;
        }
        return res.set('_path', pathToIndex.push(id));
      }) : _immutable.OrderedMap();
    }
  });
}

function value(val) {
  return val;
}

function get(key) {
  var _ref;

  return _ref = {}, _ref[key] = value, _ref;
}

function getIn(head) {
  var _ref2;

  for (var _len = arguments.length, tail = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    tail[_key - 1] = arguments[_key];
  }

  if (!tail.length) {
    return get(head);
  }
  return _ref2 = {}, _ref2[head] = getIn.apply(undefined, tail), _ref2;
}

var each = function each(resolver) {
  return function (val) {
    if (_types.isUnresolved(val)) {
      return val;
    }
    return val ? val.map(function () {
      return _immutable.fromJS(resolver);
    }) : _immutable.OrderedMap();
  };
};

exports.each = each;

function index(pathTo) {
  pathTo = _immutable.List(pathTo);
  return emptyResolver.merge({
    subscriptions: function subscriptions(val, keyPath) {
      if (_types.isUnresolved(val)) {
        return [keyPath];
      }
      return val.keySeq().map(function (id) {
        return pathTo.push(id);
      }).concat([keyPath]).toSet();
    },
    resolve: function resolve(indexMap, cache) {
      return indexMap ? indexMap.map(function (_, id) {
        return cget(cache, pathTo.push(id));
      }) : _immutable.OrderedMap();
    }
  });
}

function key(pathTo) {
  pathTo = _immutable.List(pathTo);
  return emptyResolver.merge({
    subscriptions: function subscriptions(id, keyPath) {
      if (_types.isUnresolved(id)) {
        return [keyPath];
      }
      return [keyPath, pathTo.push(id)];
    },
    resolve: function resolve(id, cache) {
      var path = pathTo.push(id);
      return cget(cache, path).set('_path', path);
    }
  });
}